<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>生产力工具记录</title>
    <url>/archives/1.html</url>
    <content><![CDATA[<h1 id="生产力工具记录"><a href="#生产力工具记录" class="headerlink" title="生产力工具记录"></a>生产力工具记录</h1><p><a id="0"></a></p>
<p>下面是一些生产力工具</p>
<ul>
<li><a href="#1">Hexo</a></li>
<li><a href="#2">draw.io</a></li>
<li><a href="#3">vim/tmux/cscope/ctags/fzf/taglist/ag</a></li>
<li><a href="#4">HHKB types</a></li>
<li><a href="#5">git</a></li>
<li><a href="#6">meld&amp;diffuse</a></li>
</ul>
<a id="more"></a> 
<hr>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p><a id="1"></a><br>hexo官网链接：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<p>本地主要维护两个仓库： </p>
<blockquote>
<p>1.hexo-blog维护 博客hexo源代码 私有库<br>2.xiaer1921.github.io  维护博客hexo 生产代码</p>
</blockquote>
<h3 id="本地实践记录："><a href="#本地实践记录：" class="headerlink" title="本地实践记录："></a>本地实践记录：</h3><ol>
<li>在执行hexo g之后，如果需要将代码部署到github，需要额外在public文件夹中新加文件CNAME，内容为你的域名，比如sholck.top.或者在source文件中增加CNAME文件，这样在hexo g时会自动复制到public文件下。  </li>
<li>需要将配置的md文件配置为644权限  </li>
<li>本地安装配置</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">npm config set registry https:<span class="regexp">//</span>registry.npm.taobao.org  <span class="regexp">//</span>增加淘宝源</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">hexo -v </span><br><span class="line">报错 <span class="regexp">/usr/</span>bin/env: node: 没有那个文件或目录</span><br><span class="line">解决：为node增加软链接 sudo ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/nodejs /u</span>sr<span class="regexp">/bin/</span>node</span><br><span class="line"></span><br><span class="line">报错 SyntaxError: Use of const <span class="keyword">in</span> strict mode. </span><br><span class="line">原因: node版本过低 node -v 查看版本</span><br><span class="line">解决：升级nodejs </span><br><span class="line">npm cache clean -f</span><br><span class="line">sudo npm install -g n</span><br><span class="line">sudo n stable</span><br><span class="line"></span><br><span class="line">重新安装hexo-cli</span><br><span class="line"><span class="comment">#hexo -v 正确打印各插件版本信息</span></span><br></pre></td></tr></table></figure>

<h3 id="功能学习"><a href="#功能学习" class="headerlink" title="功能学习"></a>功能学习</h3><ol>
<li>当前文本无法高亮,使用==text==无效，使用以下第三种方法</li>
</ol>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. hexo支持，但是有道云不支持</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;红色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:green&quot;</span>&gt;绿色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:yellow&quot;</span>&gt;黄色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:blue&quot;</span>&gt;蓝色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. ==text== 有道云支持，但是hexo不支持</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. &lt;<span class="built_in">font</span> <span class="built_in">color</span>=#2196F3 &gt;text&lt;/<span class="built_in">font</span>&gt; 兼容</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>代码高亮配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">在_config.yml中增加如下配置：</span><br><span class="line"><span class="attr">highlight_theme:</span> night eightie <span class="comment">//主题</span></span><br><span class="line">auto_detect 设置为<span class="literal">true</span></span><br><span class="line">themes<span class="regexp">/next/</span>source/lib </span><br><span class="line">路径下下载主题git clone git<span class="meta">@github</span>.<span class="attr">com:</span>chriskempson/tomorrow-theme.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用命令</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">clean 清理生成文件</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g 生成文件</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">s 启动hexo服务</span></span><br><span class="line"><span class="attr">http</span>:<span class="string">//localhost:4000/  可查看hexo启动运行的hexo服务界面</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>图片加载</p>
</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">先把图片放在<span class="keyword">source</span><span class="regexp">/images/</span></span><br><span class="line">eg：<span class="keyword">source</span><span class="regexp">/images/</span>CR-hal-chi-camx.png</span><br><span class="line">    </span><br><span class="line">在md中加入:</span><br><span class="line">    ![alt](<span class="regexp">/images/</span>PCR-hal-chi-camx.png)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>置顶+标签</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">置顶+标签：</span><br><span class="line"><span class="keyword">tags:</span> Camx</span><br><span class="line">top: true</span><br><span class="line">多tags配置：</span><br><span class="line"><span class="keyword">tags:</span> </span><br><span class="line">    - Camera-Camx</span><br><span class="line">    - PCR</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加分类页</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>categories 创建分类页</span><br><span class="line">在文章增加如下部分：</span><br><span class="line"></span><br><span class="line">categories: Hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>折叠</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>代码与文本对齐<br>需要三个反单引号和前面的文本对齐</p>
</li>
<li><p>跳转</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在需要跳转的前面增加</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用跳转</span><br><span class="line"><span class="bullet">-</span> [<span class="string">前言 基本概念的简介</span>](<span class="link">#1</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>折叠</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  文本和标题空一行，且文本前最好多一个table</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h2><p><a id="2"></a><br><a href="#0">返回主目录</a><br>制图神器，与github相关联，通过XML来描述图片元素之间关系，每次修改都会push到github，制图相关的还有XMind,StarUML,但是StarUML界面不太友好<br>目前使用到的是时序图，实现比较简单，但是发现想要在完成的时序图中间增加流程比较困难。</p>
<hr>
<h2 id="vim-neovim-zsh-tmux-cscope-ctags-fzf-taglist"><a href="#vim-neovim-zsh-tmux-cscope-ctags-fzf-taglist" class="headerlink" title="vim/neovim/zsh/tmux/cscope/ctags/fzf/taglist"></a>vim/neovim/zsh/tmux/cscope/ctags/fzf/taglist</h2><p><a id="3"></a><br><a href="#0">返回主目录</a><br>用了vim已经有5年了，一路上磕磕巴巴，插件也试了不少，tmux，fzf都是慢慢中间开始学过来的，终究没有从vim脱坑，配置文件改了又改，可惜一直没有记录，现在像一个大杂烩。故重新复习，总结，修炼。</p>
<h3 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h3><p>因为vim上配置markdown-preview不生效，所以改为使用neovim<br><a href="https://github.com/neovim/neovim/wiki/Installing-Neovim">neovim-github</a><br><a href="https://neovim.io/">neovim-home</a></p>
<h4 id="neovim安装配置"><a href="#neovim安装配置" class="headerlink" title="neovim安装配置"></a>neovim安装配置</h4><p><a href="https://github.com/neovim/neovim/wiki/Installing-Neovim#ubuntu">neovim-github-ubuntu安装</a></p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">//pip install neovim 不推荐</span><br><span class="line">//本地采用稳定源找不到neovim安装包，故采用unstable安装</span><br><span class="line">sudo<span class="built_in"> add-apt-repository </span>ppa:neovim-ppa/unstable</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install neovim</span><br><span class="line">在~/.zshrc中增加alias vim=&#x27;nvim&#x27;</span><br></pre></td></tr></table></figure>
<p><a href="https://neovim.io/doc/user/nvim.html#nvim-from-vim">nvim复用vim的配置</a></p>
<h3 id="zsh学习"><a href="#zsh学习" class="headerlink" title="zsh学习"></a>zsh学习</h3><p>zsh配置到一半发现ubuntu子系统运行命令卡顿，也没有专门去处理。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">bash切到zsh,一般ubuntu会自带zsh.</span><br><span class="line"></span><br><span class="line">https:<span class="regexp">//</span>ohmyz.sh/<span class="comment">#install提示的命令无法下载，故选择github下载安装</span></span><br><span class="line"></span><br><span class="line">执行sh install.sh会进行安装，配置完成会提示配置文件为~/.zshrc.</span><br><span class="line">我们需要将一些~<span class="regexp">/.bashrc下的客制化移动到~/</span>.zshrc.</span><br><span class="line"></span><br><span class="line">安装完成界面命令提示符已经发生改变，不在是之前的一大长串的当前路径，仅仅提示当前所在的文件名。</span><br><span class="line"></span><br><span class="line">发现两个问题：</span><br><span class="line"><span class="number">1</span>.bash和zsh 按键绑定不一样，fzf 配置文件运行报错。</span><br><span class="line"><span class="number">2</span>.zsh 运行卡顿，不知道是不是我window下ubuntu子系统的缘故。</span><br></pre></td></tr></table></figure>

<p>更新：之前在WSL上简单配置zsh，因zsh运行卡顿且比较忙就停了，今重新修炼zsh.<br>目的是使用zsh插件来加快开发效率</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">新建lynx用户</span><br><span class="line"><span class="section">#useradd -m lynx</span></span><br><span class="line">修改默认shell</span><br><span class="line"><span class="section">#chsh -s /bin/zsh</span></span><br><span class="line"></span><br><span class="line">[<span class="string">github-Zsh</span>](<span class="link">https://github.com/ohmyzsh/ohmyzsh</span>)</span><br><span class="line">安装：</span><br><span class="line">/github/ohmyzsh/tools#./install.sh</span><br><span class="line">安装过程中会提示是否配置zsh为用户默认shell</span><br></pre></td></tr></table></figure>

<h4 id="插件管理vim-plug"><a href="#插件管理vim-plug" class="headerlink" title="插件管理vim-plug"></a>插件管理vim-plug</h4><p><a href="https://github.com/junegunn/vim-plug">vim-plug-github</a></p>
<p><a href="https://github.com/junegunn/vim-plug#usage/">插件安装使用</a></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&#x27;curl -fLo &quot;$&#123;XDG_DATA_HOME:-$HOME/.local/share&#125;&quot;/nvim/site/autoload/plug.vim --create-dirs \</span></span><br><span class="line"><span class="string">       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&#x27;</span></span><br><span class="line"></span><br><span class="line">将库中的plug.vim <span class="keyword">copy</span>到nvim安装路径</span><br><span class="line">➜  tools git:(main) ✗ nvim --version</span><br><span class="line">   system vimrc <span class="keyword">file</span>: <span class="string">&quot;$VIM/sysinit.vim&quot;</span>   </span><br><span class="line">  fall-back <span class="keyword">for</span> $VIM: <span class="string">&quot;/usr/share/nvim&quot;</span> &gt;&gt;系统安装路径</span><br><span class="line">#cp plug.vim  <span class="regexp">/usr/</span>share<span class="regexp">/nvim/</span><span class="keyword">runtime</span><span class="regexp">/autoload/</span>.</span><br><span class="line"><span class="comment">//插件安装:PlugInstall</span></span><br></pre></td></tr></table></figure>

<h4 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h4><p>插件配置：默认放置于$ZSH/plugins中，路径和source的位置相关联</p>
<h5 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a>fzf</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">作用: 文件跳转</span><br><span class="line">[<span class="string">github-fzf</span>](<span class="link">https://github.com/junegunn/fzf</span>)</span><br><span class="line">将fzf库copy到ohmyzsh/plugins/fzf并安装./install.sh</span><br><span class="line">增加fzf到plugin list中</span><br><span class="line">验证：ctrl+t</span><br><span class="line"></span><br><span class="line">export FZF<span class="emphasis">_BASE=$ZSH/plugins/fzf应该放置于source $ZSH/oh-my-zsh.sh前</span></span><br></pre></td></tr></table></figure>
<h5 id="Autosuggestion"><a href="#Autosuggestion" class="headerlink" title="Autosuggestion"></a>Autosuggestion</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">作用: 根据历史命令进行提示</span><br><span class="line">按照插件说明安装</span><br><span class="line"><span class="meta">#</span><span class="bash">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span></span><br><span class="line">增加zsh-autosuggestions到plugin list中</span><br></pre></td></tr></table></figure>

<h5 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h5><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">验证未生效</span><br><span class="line">作用：文件跳转，类似fzf</span><br><span class="line">#git clone git:<span class="comment">//github.com/joelthelion/autojump.git</span></span><br><span class="line">将autojump库<span class="keyword">copy</span>到ohmyzsh<span class="regexp">/plugins/</span>autojump并安装./install.py</span><br><span class="line">在.zshrc中增加[[ -s <span class="regexp">/root/</span>.autojump<span class="regexp">/etc/</span>profile.d<span class="regexp">/autojump.sh ]] &amp;&amp; source /</span>root<span class="regexp">/.autojump/</span>etc<span class="regexp">/profile.d/</span>autojump.sh</span><br></pre></td></tr></table></figure>

<h5 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h5><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">按照INSTALL.md配置</span><br><span class="line">#git clone https:<span class="comment">//github.com/zsh-users/zsh-syntax-highlighting.git</span></span><br><span class="line">将库下载到ohmyzsh<span class="regexp">/plugins/</span></span><br><span class="line">#make install</span><br><span class="line">#增加<span class="keyword">source</span> <span class="regexp">/usr/</span>local<span class="regexp">/share/</span>zsh-syntax-highlighting/zsh-syntax-highlighting.zsh到.zshrc</span><br><span class="line">现象：会发现命令正确是绿色的，而不正确的是红色的</span><br></pre></td></tr></table></figure>

<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><blockquote>
<ol>
<li>目录浏览和跳转：d查看目录历史和通过序号跳转  </li>
<li>直接使用..和…</li>
</ol>
</blockquote>
<h3 id="vim-markdown配置"><a href="#vim-markdown配置" class="headerlink" title="vim-markdown配置"></a>vim-markdown配置</h3><h4 id="Tabular"><a href="#Tabular" class="headerlink" title="Tabular"></a>Tabular</h4><p><a href="https://github.com/godlygeek/tabular">基于正则的文本对齐-github</a></p>
<p>作用:文本对齐，对注释对齐非常有用<br>:help tabular</p>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="type">Vundle</span>管理安装：<span class="type">Plugin</span> <span class="symbol">&#x27;godlygeek</span>/tabular&#x27;</span><br></pre></td></tr></table></figure>
<p>注释对齐eg:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//txt</span></span><br><span class="line">text1     <span class="comment">// comment1</span></span><br><span class="line">text2           <span class="comment">//comment2</span></span><br><span class="line">执行:Tabularize  <span class="regexp">/\/\/</span>   进行<span class="comment">//对其</span></span><br><span class="line">text1 <span class="comment">// comment1</span></span><br><span class="line">text2 <span class="comment">// comment2</span></span><br></pre></td></tr></table></figure>
<h4 id="vim-markdown"><a href="#vim-markdown" class="headerlink" title="vim-markdown"></a>vim-markdown</h4><p><a href="https://github.com/plasticboy/vim-markdown">vim-markdown插件-github</a><br>根据github描述，需要在vim-markdown插件前安装Tabular</p>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="type">Vundle</span>管理安装 <span class="type">Plugin</span> <span class="symbol">&#x27;plasticboy</span>/vim-markdown&#x27;</span><br></pre></td></tr></table></figure>
<p>发现打开markdown文件有折叠，可以在.vimrc中增加如下来取消折叠</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">set</span> <span class="attribute">foldlevel</span>=9999</span><br><span class="line">autocmd BufNewFile,BufRead *.md <span class="builtin-name">set</span> nofoldenable</span><br></pre></td></tr></table></figure>

<h4 id="vim-markdown-toc"><a href="#vim-markdown-toc" class="headerlink" title="vim-markdown-toc"></a>vim-markdown-toc</h4><p>为markdown自动生成目录<br><a href="https://github.com/mzlogin/vim-markdown-toc">vim-markdown-toc-github</a><br><a href="https://mazhuang.org/2015/12/19/vim-markdown-toc/">中文说明</a></p>
<h4 id="instant-markdown-d"><a href="#instant-markdown-d" class="headerlink" title="instant-markdown-d"></a>instant-markdown-d</h4><p><a href="https://github.com/instant-markdown/instant-markdown-d">instant-markdown-d github</a></p>
<p>安装以后打开md文件WSL可以自动打开页面实时预览，但是本地Ubuntu需要打开网页<code>http://localhost:8090/</code>预览</p>
<p>安装如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">//安装依赖包</span><br><span class="line">sudo <span class="built_in">add</span>-apt-repository <span class="keyword">pp</span><span class="variable">a:chris</span>-lea/node.js</span><br><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install nodejs</span><br><span class="line">npm -g install instant-markdown-d</span><br><span class="line"></span><br><span class="line">//配置init.<span class="keyword">vim</span>,通过PlugInstall安装</span><br><span class="line">Plug <span class="string">&#x27;instant-markdown/vim-instant-markdown&#x27;</span>, &#123;<span class="string">&#x27;for&#x27;</span>: <span class="string">&#x27;markdown&#x27;</span>, <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;yarn install&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>打开.md文件预览即可</p>
<h4 id="markdown-preview"><a href="#markdown-preview" class="headerlink" title="markdown-preview"></a>markdown-preview</h4><p>本地vim无法实时预览markdown文件，故迁移使用neovim, 暂时依旧无法预览</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span>-markdown gi<span class="variable">t:</span>(master) <span class="keyword">vim</span> --<span class="keyword">version</span> | <span class="keyword">grep</span> +<span class="keyword">python</span></span><br><span class="line">+conceal           +linebreak         +<span class="keyword">python3</span>           +visualextra</span><br><span class="line"></span><br><span class="line"><span class="keyword">im</span>-markdown gi<span class="variable">t:</span>(master) <span class="keyword">vim</span> --<span class="keyword">version</span>              </span><br><span class="line">VIM - Vi IMproved <span class="number">8.2</span> (<span class="number">2019</span> Dec <span class="number">12</span>, compiled Sep <span class="number">22</span> <span class="number">2020</span> <span class="number">12</span>:<span class="number">05</span>:<span class="number">44</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/iamcco/markdown-preview.nvim#install--usage">插件安装</a></p>
<h3 id="fzf记录"><a href="#fzf记录" class="headerlink" title="fzf记录"></a>fzf记录</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install highlight</span><br><span class="line"><span class="comment">#vim ~/.bashrc</span></span><br><span class="line"><span class="comment"># 搜索时高亮显示文件内容</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">FZF_DEFAULT_OPTS</span>=<span class="string">&quot;--height 40% --layout=reverse --preview &#x27;(highlight -O ansi &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500&#x27;&quot;</span></span><br><span class="line"><span class="comment"># 指定索引目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">FZF_DEFAULT_COMMAND</span>=<span class="string">&#x27;find code_pathXX&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#vim ~/.vimrc</span></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class="string">&#x27;dir&#x27;</span>: <span class="string">&#x27;~/.fzf&#x27;</span>, <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;./install --all&#x27;</span>  &#125;</span><br><span class="line">Plugin <span class="string">&#x27;junegunn/fzf.vim&#x27;</span></span><br><span class="line"><span class="builtin-name">set</span> runtimepath^=~/.vim/bundle/fzf</span><br><span class="line"><span class="builtin-name">set</span> rtp+=/root/.vim/bundle/fzf/bin/fzf</span><br><span class="line">nmap &lt;C-p&gt; :Files&lt;CR&gt;</span><br><span class="line">nmap &lt;C-e&gt; :Buffers&lt;CR&gt;</span><br><span class="line">nmap &lt;C-h&gt; :History&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;let g:fzf_action = &#123; &#x27;ctrl-e&#x27;: &#x27;edit&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="tmux记录"><a href="#tmux记录" class="headerlink" title="tmux记录"></a>tmux记录</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">当前绘画面板panel最大化 bind+z 在当前窗口有多panel时，如果需要当前panel最大化，这个方法是很方便的</span><br><span class="line">新建<span class="keyword">session</span>   tmux <span class="built_in">new</span> -s SESSION_NAME</span><br><span class="line">删除指定的<span class="keyword">session</span>           tmux kill-<span class="keyword">session</span> -t SESSION_NAME</span><br><span class="line">连接上某个已存在的<span class="keyword">session</span>   tmux a -t SESSION_NAME;</span><br><span class="line"><span class="keyword">session</span> 重命名   bind,:   输入 <span class="keyword">rename</span>-<span class="keyword">session</span> <span class="built_in">new</span>-<span class="type">name</span></span><br><span class="line">当安装neovim后，发现tmux的窗口名在<span class="keyword">rename</span>之后也会跟着当前路径改变，需要在配置中增加<span class="keyword">set</span>-<span class="keyword">option</span> -g allow-<span class="keyword">rename</span> <span class="keyword">off</span>，重载配置 tmux source ~/.tmux.conf</span><br></pre></td></tr></table></figure>

<h3 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a>cscope</h3><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alias</span> cdcope-<span class="literal">note</span>=<span class="symbol">&#x27;cscope</span> -Rbkq&#x27;  cscope更新索引</span><br></pre></td></tr></table></figure>

<h3 id="taglist"><a href="#taglist" class="headerlink" title="taglist"></a>taglist</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">map &lt;silent&gt; &lt;leader&gt;w <span class="symbol">:WMToggle&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="winmanager"><a href="#winmanager" class="headerlink" title="winmanager"></a>winmanager</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">//<span class="keyword">vim</span>的操作内部是用<span class="keyword">wincmd</span>去控制的</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span> :WMToggle<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">let</span> WManager_Close_On_Select=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> WManager_GainFocus_On_ToggleOpen = <span class="number">1</span></span><br><span class="line">WManager_Close_On_Select 客制化函数，用来选择文件以后退出</span><br><span class="line">WManager_GainFocus_On_ToggleOpen 客制化函数，用来快捷键显示winmanager菜单</span><br></pre></td></tr></table></figure>

<h3 id="gnome终端配置"><a href="#gnome终端配置" class="headerlink" title="gnome终端配置"></a>gnome终端配置</h3><pre><code>内置方案：深色
文件颜色：#839496
背景颜色：#002B36</code></pre>
<h2 id="HHKB"><a href="#HHKB" class="headerlink" title="HHKB"></a>HHKB</h2><p><a id="4"></a><br><a href="#0">返回主目录</a><br>HHKB使用手册<br><img src="/images/tool/HHKB.png" alt="alt"></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">DIP开关说明：</span><br><span class="line">开关下为off，上为<span class="keyword">on</span></span><br><span class="line"><span class="number">1</span>和<span class="number">2</span> 设置为off, windows键盘设置模式</span><br><span class="line"><span class="number">3</span> <span class="keyword">on</span>为backspace, off为delete, 设置为<span class="keyword">on</span></span><br><span class="line"><span class="number">4</span>和<span class="number">5</span>搭配使用， <span class="number">5</span> <span class="keyword">on</span>， 会互换 al和◇功能</span><br><span class="line"><span class="number">4</span> <span class="keyword">on</span> ,◇功能设置为Fn</span><br><span class="line"><span class="number">6</span> <span class="keyword">on</span>启用唤醒</span><br></pre></td></tr></table></figure>

<p>上下左右跳转：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">将功能4设置为on</span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ [</span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ ;  </span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ &#x27; </span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ /</span></span><br></pre></td></tr></table></figure>

<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p><a id="5"></a><br><a href="#0">返回主目录</a>  </p>
<h3 id="删除敏感信息提交"><a href="#删除敏感信息提交" class="headerlink" title="删除敏感信息提交"></a>删除敏感信息提交</h3><p>当提交敏感信息入库需要包括提交记录删除处理<br>目前git bebase中的drop实操未规，貌似git已经不再支持</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>切换到新的分支</span><br><span class="line">git checkout --orphan latest_branch</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>缓存所有文件（除了.gitignore中声名排除的）</span><br><span class="line">git add -A</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>提交跟踪过的文件（Commit the changes）</span><br><span class="line">git commit -am <span class="string">&quot;commit message&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>删除master分支（Delete the branch）</span><br><span class="line">git branch -D main</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>重命名当前分支为master</span><br><span class="line">git branch -m main</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>提交到远程master分支 （Finally, force update your repository）</span><br><span class="line">git push -f origin main</span><br></pre></td></tr></table></figure>

<h3 id="git-lfs"><a href="#git-lfs" class="headerlink" title="git lfs"></a>git lfs</h3><p>本地需要将vim设置提交到github，但是bundle下又有子git仓，提交失败，因为bundle下不修改，直接打包提交，但是文件太大，无法提交，采用git lfs管理。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. curl -s http<span class="variable">s:</span>//packagecloud.io/install/repositories/github/git-lfs/script.<span class="keyword">deb</span>.<span class="keyword">sh</span> | sudo bash</span><br><span class="line"><span class="number">2</span>. sudo apt-<span class="built_in">get</span> install git-lfs</span><br><span class="line"><span class="number">3</span>. git lfs install</span><br><span class="line"><span class="number">4</span>. git lfs track <span class="keyword">vim</span>/bundle.tar.gz  可以在当前目录下发现.gitattributes文件记录track配置, 该文件需要提交入库</span><br><span class="line"><span class="number">5</span>. # git lfs track  &gt;&gt;查看当前配置</span><br><span class="line">Listing tracked patterns</span><br><span class="line">    <span class="keyword">vim</span>/bundle.tar.gz (.gitattributes)</span><br><span class="line">Listing excluded patterns</span><br><span class="line"><span class="number">6</span>. # git lfs <span class="keyword">ls</span>-<span class="keyword">files</span> &gt;&gt;当前跟踪的文件</span><br><span class="line">aa849f2b24 * <span class="keyword">vim</span>/bundle.tar.gz</span><br></pre></td></tr></table></figure>
<p>提交以后，github上有<code>Stored with Git LFS</code> 来标记此文件，见下图<br><img src="/images/tool/store-with-git-lfs.png" alt="alt"></p>
<p>之后使用<code>git lfs clone</code>，因为git-lfs只提供1G的空间和每月1G的流量，查看path:setting&gt;&gt;Billing<br><img src="/images/tool/git-lfs.png" alt="alt"></p>
<p>超过会报如下错：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">batch response: This repository <span class="keyword">is</span> <span class="keyword">over</span> <span class="keyword">its</span> data quota. Account responsible <span class="keyword">for</span> LFS bandwidth should purchase more data packs <span class="keyword">to</span> restore access</span><br></pre></td></tr></table></figure>
<p>如下方法在流量超过以后依旧无法拉取或者下载</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> fork这个库</span><br><span class="line"><span class="number">2.</span> 在仓库setting&gt;&gt;Archives 打开Include Git LFS objects <span class="keyword">in</span> archives.</span><br><span class="line"><span class="number">3.</span> Danger Zone&gt;&gt;Archive <span class="keyword">this</span> repository,之后在clone或者下载zip包依旧无法成功拉取lfs文件</span><br></pre></td></tr></table></figure>
<h2 id="meld-amp-diffuse"><a href="#meld-amp-diffuse" class="headerlink" title="meld&amp;diffuse"></a>meld&amp;diffuse</h2><p><a id="6"></a><br><a href="#0">返回主目录</a><br>linux环境代码比较集成工具</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install</span> meld diffuse</span><br><span class="line">由于meld需要使用python2环境，当提示<span class="keyword">import</span> meld失败时，需要<span class="keyword">check</span> /usr/<span class="keyword">bin</span>/python的指向是不是python2,如果不是,修改meld，使用python2处理</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/84773275">高效做笔记:vim + markdown</a><br><a href="https://www.jianshu.com/p/24aefcd4ca93">vim安装markdown插件</a></p>
]]></content>
      <categories>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>hexo</tag>
        <tag>draw.io</tag>
        <tag>fzf</tag>
      </tags>
  </entry>
  <entry>
    <title>动态模块加载异常</title>
    <url>/archives/11.html</url>
    <content><![CDATA[<h1 id="动态模块加载异常"><a href="#动态模块加载异常" class="headerlink" title="动态模块加载异常"></a>动态模块加载异常</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>动态模块加载，出现以下异常</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">disagrees <span class="keyword">about</span> <span class="built_in">version</span> <span class="keyword">of</span> symbol module_layout<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<hr>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>kernel编译会生成vmlinux.symvers和Module.symvers两部分记录vmlinuz和模块的接口的symbol，动态模块编译时会生成xxx.mod.c，其中记录了动态模块用到的接口symbol，在加载模块时会去匹配接口的symbol是否和Module.symvers记录的一致，如果不一致，则提示错误。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>动态模块xxx.mod.c中的module_layout symbol</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">modversion_info</span> ____<span class="title">versions</span>[]    </span></span><br><span class="line"><span class="class">__<span class="title">used</span> __<span class="title">section</span>(&quot;__<span class="title">versions</span>&quot;) =</span> &#123;    </span><br><span class="line">        &#123; <span class="number">0x97f53857</span>, <span class="string">&quot;module_layout&quot;</span> &#125;,    </span><br><span class="line">        &#123; <span class="number">0x92997ed8</span>, <span class="string">&quot;_printk&quot;</span> &#125;,    </span><br><span class="line">        &#123; <span class="number">0xbdfb6dbb</span>, <span class="string">&quot;__fentry__&quot;</span> &#125;,    </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>内核vmlinux.symvers中的module_layout symbol</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x4709b79f</span>      module_layout   vmlinux EXPORT_SYMBOL </span><br></pre></td></tr></table></figure>

<p>内核Module.symvers中的module_layout symbol</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x97f53857</span>      module_layout   vmlinux EXPORT_SYMBOL</span><br></pre></td></tr></table></figure>

<p>发现动态模块中的和Module.symvers的一致，但是和vmlinux.symvers的不一致，而每一次make bzImage都会导致vmlinux.symvers更新，不会去生成更新Module.symvers，导致Module.symvers symbol过旧，因此需要重新make modules</p>
<h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>实现逻辑见kernel/module.c ,通过CONFIG_MODVERSIONS来编译控制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> check_version(info, <span class="string">&quot;module_layout&quot;</span>, mod, fsa.crc); </span><br></pre></td></tr></table></figure>

<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul>
<li>第一种：make modules，重新动态模块编译</li>
<li>第二种：更新.config，删除CONFIG_MODVERSIONS</li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="插入模块"><a href="#插入模块" class="headerlink" title="插入模块"></a>插入模块</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">➜  initramfs modinfo /github/busybox/initramfs/x86-busybox-rootfs/hello.ko</span><br><span class="line">filename:       /github/busybox/initramfs/x86-busybox-rootfs/hello.ko</span><br><span class="line">license:        Dual BSD/GPL</span><br><span class="line">srcversion:     <span class="number">89</span>A8475A71641B4AAA82542</span><br><span class="line">depends:        </span><br><span class="line">retpoline:      Y</span><br><span class="line">name:           hello</span><br><span class="line">vermagic:       <span class="number">5.17</span><span class="number">.0</span>+ SMP preempt mod_unload </span><br><span class="line"></span><br><span class="line">➜  initramfs qemu-system-x86_64 -m <span class="number">1024</span>  -smp <span class="number">2</span>  -hda rootfs.img  -kernel /github/busybox/initramfs/x86-busybox-rootfs/vmlinuz<span class="number">-5.17</span><span class="number">.0</span>+    -s -append <span class="string">&quot;root=/dev/sda rdinit=init crashkernel=128M console=ttyS0 rw&quot;</span> -nographic</span><br><span class="line">...</span><br><span class="line">/ # ./init</span><br><span class="line"></span><br><span class="line">Boot took <span class="number">15.51</span> seconds</span><br><span class="line"></span><br><span class="line">/ <span class="meta"># insmod hello.ko</span></span><br><span class="line">[   <span class="number">22.306823</span>] random: fast init done</span><br><span class="line">[   <span class="number">22.322005</span>] hello: loading out-of-tree <span class="keyword">module</span> taints kernel.</span><br><span class="line">[   <span class="number">22.323224</span>] hello: <span class="keyword">module</span> verification failed: signature <span class="keyword">and</span>/<span class="keyword">or</span> required key missing - tainting kernel</span><br><span class="line">[   <span class="number">22.327473</span>] Hello, world</span><br><span class="line"></span><br><span class="line">/ <span class="meta"># lsmod | grep -n <span class="meta-string">&quot;hello&quot;</span></span></span><br><span class="line"><span class="number">1</span>:hello <span class="number">16384</span> <span class="number">0</span> - Live <span class="number">0xffffffffc00bb000</span> (OE)</span><br><span class="line">/ <span class="meta"># cat /proc/modules </span></span><br><span class="line">hello <span class="number">16384</span> <span class="number">0</span> - Live <span class="number">0xffffffffc0369000</span> (OE)</span><br></pre></td></tr></table></figure>

<h3 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h3><p>modprobe -r 会在/lib/module/$(uname -r) 下去寻找卸载的模块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ <span class="meta"># mkdir -p /lib/modules/5.17.0+</span></span><br><span class="line">/ <span class="meta"># cd /lib/modules/5.17.0+</span></span><br><span class="line"># /lib/modules/<span class="number">5.17</span><span class="number">.0</span>+ <span class="meta"># cp /hello.ko .</span></span><br><span class="line"># /lib/modules/<span class="number">5.17</span><span class="number">.0</span>+ <span class="meta"># modprobe -r hello</span></span><br><span class="line">[  <span class="number">487.404929</span>] Goodbey, cruel world</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>linux-module</tag>
        <tag>insmod</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄露分析</title>
    <url>/archives/7.html</url>
    <content><![CDATA[<h1 id="内存泄露分析"><a href="#内存泄露分析" class="headerlink" title="内存泄露分析"></a>内存泄露分析</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>N项目超级夜景模式泄露内存，且泄露内存较大，大概每次19M</p>
<a id="more"></a>
<hr>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ol>
<li><p>对内存有基本的知识了解。</p>
</li>
<li><p>对syscall有基本的了解和对调试工具strace的使用</p>
</li>
</ol>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><h3 id="抓取相关信息"><a href="#抓取相关信息" class="headerlink" title="抓取相关信息"></a>抓取相关信息</h3><ol>
<li>针对内存泄露抓取hal进程内存总体和分配情况，针对较大内存泄露，三次场景复现后对比前后抓取，因为抓取文件偏多，因此需要脚本抓取。在抓取前需要先确定进程pid</li>
</ol>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">setlocal</span> enabledelayedexpansion</span><br><span class="line">adb wait-<span class="keyword">for</span>-device</span><br><span class="line"><span class="built_in">echo</span> &quot;#### test <span class="built_in">start</span> ####&quot;</span><br><span class="line">#timeout <span class="number">120</span></span><br><span class="line">#需要重新开机，并进行一次打开关闭camera操作，等<span class="number">120</span>s</span><br><span class="line">#开始抓取内存分布</span><br><span class="line">adb  shell dumpsys meminfo | <span class="built_in">findstr</span> camera &gt;&gt; before-supernight-leak.txt</span><br><span class="line"><span class="built_in">echo</span> -------------------------- &gt;&gt; before-supernight-leak.txt</span><br><span class="line">adb  shell dumpsys meminfo <span class="number">26639</span> &gt;&gt; before-supernight-leak.txt</span><br><span class="line"><span class="built_in">echo</span> -------------------------- &gt;&gt; before-supernight-leak.txt</span><br><span class="line">adb shell cat /proc/<span class="number">26639</span>/maps  &gt;&gt; before-supernight-leak.txt</span><br><span class="line">adb shell cat /proc/<span class="number">26639</span>/smaps  &gt;&gt; before-supernight-leak-smaps.txt</span><br><span class="line">#开始抓取syscall,打开到夜景模式复现三次</span><br><span class="line"><span class="keyword">for</span> /L <span class="variable">%%i</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">echo</span> 第 <span class="variable">%%i</span> / <span class="number">3</span> 次</span><br><span class="line">	adb shell input tap  <span class="number">347</span> <span class="number">1288</span></span><br><span class="line">    timeout <span class="number">10</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">#等<span class="number">20</span>s再停止抓取syscall</span><br><span class="line">#等<span class="number">60</span>s之后内存稳定再抓取一次内存分布</span><br><span class="line">#timeout <span class="number">60</span></span><br><span class="line">adb  shell dumpsys meminfo | <span class="built_in">findstr</span> camera &gt;&gt; after-supernight-leak.txt</span><br><span class="line"><span class="built_in">echo</span> -------------------------- &gt;&gt; after-supernight-leak.txt</span><br><span class="line">adb  shell dumpsys meminfo <span class="number">26639</span> &gt;&gt; after-supernight-leak.txt</span><br><span class="line"><span class="built_in">echo</span> -------------------------- &gt;&gt; after-supernight-leak.txt</span><br><span class="line">adb shell cat /proc/<span class="number">26639</span>/maps  &gt;&gt; after-supernight-leak.txt</span><br><span class="line"></span><br><span class="line">adb shell cat /proc/<span class="number">26639</span>/smaps  &gt;&gt; after-supernight-leak-smaps.txt</span><br><span class="line"></span><br><span class="line">timeout <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>我们需要通过是哪个系统调用进行的内存申请来确定相关线程和代码范围，因此在整个复现过程需要strace来抓取系统调用，需要抓取整个进程包括子线程并将输出重定向到指定文件<br><code>strace -o output.txt -T -tt -p 28979 -f</code></li>
</ol>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li>进程内存大体对比分析</li>
</ol>
<p><img src="/images/memory/meminfo.png" alt="alt"></p>
<p>  这是三次夜景拍照前后的对比，可以看出PSS,RSS, Native Heap均有50到60M左右的增长。</p>
<ol start="2">
<li>进程内存具体分配变化对比分析</li>
</ol>
<p><img src="/images/memory/smap.png" alt="alt"></p>
<p>  内存分配的变化会有多处，但是针对泄露较大的，只需要对比MB级别的内存区域变化即可，KB的不需要关心。对比发现两处大小有规律性的内存变化，即0x842e9000开始的19M和0xa737d000开始的38M，因此确定三次泄露地址为0x842e9000，0xa737d000，0xa8611000。</p>
<ol start="3">
<li>针对strace抓取的syscall过滤三次地址内存分配的系统调用</li>
</ol>
<p><img src="/images/memory/strace.png" alt="alt"></p>
<p>  可以发现tid 15671申请了19480576字节大小，地址为0xa8611000的匿名内存。通过writev确定泄露内存申请处于arcsoft_YUVNight_process_frame函数，检查该函数内的大内存申请，确定是为了超夜算法处理申请的内存未释放导致。</p>
]]></content>
      <categories>
        <category>memory</category>
      </categories>
      <tags>
        <tag>strace</tag>
        <tag>syscall</tag>
        <tag>smap</tag>
        <tag>内存泄露</tag>
        <tag>稳定性</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内核开发学习手册-内核许可证</title>
    <url>/archives/10.html</url>
    <content><![CDATA[<h1 id="linux内核开发学习手册-内核许可证"><a href="#linux内核开发学习手册-内核许可证" class="headerlink" title="linux内核开发学习手册-内核许可证"></a>linux内核开发学习手册-内核许可证</h1><p>原文见：内核开发文档-Linux kernel licensing rules(Linux内核许可规则)</p>
<h2 id="内核通用许可证"><a href="#内核通用许可证" class="headerlink" title="内核通用许可证"></a>内核通用许可证</h2><ul>
<li>linux内核虽然是开源的，但是为了避免开发者的心血被不良厂商赚取利益等和保护开源环境，因此是有基于GPL-2.0() 的通用公共许可证作为法律保护的，具体的描述见<font color=#2196F3 >COPYING</font>文件。</li>
</ul>
<ul>
<li>所有的内核源文件都需要标志许可证，而且这个许可证是可以与GPL-2.0兼容的，但是UAPI是作为例外的，因为是非内核的软件如果与内核通信，需要包含此头文件，但是我们不能要求该通信软件也受此许可证限制，因此此类特殊的例外许可描述也会被记录。</li>
</ul>
<a id="more"></a>

<ul>
<li>为了便于源文件的统一标识许可证,因此使用可解析的SPDX(Software Package Data Exchange)，当我们使用<code>./scripts/checkpatch.pl</code>来检查文件时，同时也会检查SPDX</li>
</ul>
<h2 id="内核许可规则"><a href="#内核许可规则" class="headerlink" title="内核许可规则"></a>内核许可规则</h2><p><a href="https://spdx.org/licenses/">内核许可列表</a>是官方列表，描述了可用的SPDX条目和已经不再使用的。比如<code>GPL-2.0-only</code>是比<code>GPL-2.0</code>更加规范的，目前广泛使用的的许可证见<code>LICENSES/preferred/</code></p>
<h3 id="描述规则"><a href="#描述规则" class="headerlink" title="描述规则"></a>描述规则</h3><p>不同类型的文件有不同的描述规则。更多见内核开发文档</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">C source: <span class="regexp">//</span> SPDX-License-Identifier: &lt;SPDX License Expression&gt;</span><br><span class="line">C header: <span class="regexp">/* SPDX-License-Identifier: &lt;SPDX License Expression&gt; */</span></span><br><span class="line">scripts:  <span class="comment"># SPDX-License-Identifier: &lt;SPDX License Expression&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="SPDX声明位置"><a href="#SPDX声明位置" class="headerlink" title="SPDX声明位置"></a>SPDX声明位置</h3><p>应该放在第一行，虽然说有<code>#!PATH_TO_INTERPRETER</code>的时候在第二行，但是目前内核没有使用<code>#!PATH_TO_INTERPRETER</code>的脚本</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>通用语法如下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> SPDX-License-Identifier: GPL-<span class="number">2.0</span>-only </span><br></pre></td></tr></table></figure>

<p>当UAPI需要使用例外许可时，使用 <code>WITH</code>，例外许可证见<code>LICENSES/exceptions&lt;/font&gt;</code><br>`</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br></pre></td></tr></table></figure>

<p>目前出了UAPI的例外，内核<font color=#2196F3 >LICENSES/exceptions</font>声明的例外还有GCC-exception-2.0，作为GCC链接例外，允许任意的二进制文件能够和该例外声明的文件编译的版本文件链接，使用基本都是arch/sh/lib/的汇编文件中</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">/* SPDX-License-Identifier: GPL-<span class="number">2.0</span>+ <span class="keyword">WITH</span> GCC-<span class="keyword">exception</span>-<span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<h3 id="双重许可证"><a href="#双重许可证" class="headerlink" title="双重许可证"></a>双重许可证</h3><p>文件有双重许可，但是只有一个会被使用，多见dts文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> SPDX-License-Identifier: (GPL-<span class="number">2.0</span> WITH Linux-syscall-note) OR MIT</span><br></pre></td></tr></table></figure>

<h3 id="多个许可证"><a href="#多个许可证" class="headerlink" title="多个许可证"></a>多个许可证</h3><p>文件使用多个许可证。当一个代码我们已经被授予放入内核的权限，我们也应该保留其原始的许可条款</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> SPDX-License-Identifier: (GPL-<span class="number">2.0</span> WITH Linux-syscall-note) AND MIT</span><br></pre></td></tr></table></figure>

<h2 id="模块许可规则"><a href="#模块许可规则" class="headerlink" title="模块许可规则"></a>模块许可规则</h2><p>模块许可规则应用于可加载模块，其不能替代SPDX也不提供明确的许可，只是提供足够的信息说明。常用如下即可</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><code>MODULE_LICENSE(&quot;GPL v2&quot;);</code> 需要特殊说明，因为使用会污染内核，而且内核会拒绝将模块链接到使用EXPORT_SYMBOL_GPL()导出的符号</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux哲学</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内核开发学习手册-内核驱动接口</title>
    <url>/archives/9.html</url>
    <content><![CDATA[<h1 id="内核开发学习手册-内核驱动接口"><a href="#内核开发学习手册-内核驱动接口" class="headerlink" title="内核开发学习手册-内核驱动接口"></a>内核开发学习手册-内核驱动接口</h1><p>针对内核，无论是开发还是用户，我们所希望的是稳定的驱动功能，而稳定的驱动和有稳定的内核接口之间的联系，需要我们去思考，有助于理解linux的开发哲学。</p>
<p>下文解释了：</p>
<ol>
<li>内核没有二进制内核接口</li>
<li>内核的源代码接口不稳定<a id="more"></a>

</li>
</ol>
<p>这个二进制接口可以理解为固定的驱动二进制驱动模块文件,即md5sum 是相同的。下面探讨的是作为一个驱动开发者，如果你的驱动没有释放到内核，但是想为不同架构，不同内核版本下的内核都提供稳定正确的二进制驱动模块文件是否是值得的。</p>
<h2 id="二进制内核接口"><a href="#二进制内核接口" class="headerlink" title="二进制内核接口"></a>二进制内核接口</h2><p>首先从一个疑问开始：稳定的源代码接口是否意味着稳定的二进制内核接口，实际上并不是这样的，因为包括以下几点</p>
<ol>
<li>编译工具链不同版本会导致数据结构内部的对齐问题</li>
<li>内核配置选项会导致数据结构成员不同，函数实现不同等。</li>
<li>内核使用的内存会以不同的方式对齐</li>
</ol>
<p>这些都会导致一个特定内核下编译的二进制驱动程序大概率无法在另外一个架构下正确运行，因此避免在多环境下的令人头大的编译，最好的方法就是释放到内核</p>
<h2 id="内核的源代码接口不稳定"><a href="#内核的源代码接口不稳定" class="headerlink" title="内核的源代码接口不稳定"></a>内核的源代码接口不稳定</h2><p>内核开发是快速迭代的，发现bug，有更好的实现方式，需要增加功能优化，或者安全性，稳定性，就需要进行接口修改，这就涉及到结构体的修改，函数成员的修改，甚至API的删除或者增加，如果保持维护旧的接口，会导致稳定性问题，设计到安全会更加严重，而且会浪费不必要的时间，毕竟开源人员的时间是宝贵的。</p>
<p>当一个接口被重写时，我们需要对涉及的所有驱动代码进行修改，保证内核的正确运行</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>如果被授予了将源代码放入内核的权限，而且是GPL许可下的，最好释放到内核，不然可能需要自己去为每一个linux内核来维护二进制模块，而且释放到内核有如下优点</p>
<ol>
<li>驱动质量提升，开发者的维护成本降低</li>
<li>代码的稳定性问题/性能问题/bug都会有其他人修复</li>
<li>新功能特性的增加</li>
<li>随时和内核版本是适配的，当驱动接口改变时，第一个提交的会同步修改驱动并保证正确运行</li>
<li>不需要联系开发商去适配二进制驱动</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux哲学</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内核补丁提交</title>
    <url>/archives/8.html</url>
    <content><![CDATA[<h1 id="内核补丁提交"><a href="#内核补丁提交" class="headerlink" title="内核补丁提交"></a>内核补丁提交</h1><p>本文将总结介绍提交内核补丁前的须知规范</p>
<p>linux官方文档下有详细的关于此部分的描述<a href="https://www.kernel.org/doc/html/v5.9/translations/zh_CN/process/index.html">与Linux 内核社区一起工作</a></p>
<a id="more"></a>
<hr>
<h2 id="补丁提交须知"><a href="#补丁提交须知" class="headerlink" title="补丁提交须知"></a>补丁提交须知</h2><h3 id="linux分支迭代维护规则"><a href="#linux分支迭代维护规则" class="headerlink" title="linux分支迭代维护规则"></a>linux分支迭代维护规则</h3><p>开发者提交到子系统，然后由linus拉取进入主分支，详见下面两张图</p>
<p><img src="/images/linux/linux-maintainers.png" alt="linux-maintainers.png"></p>
<p>来自宋宝华的ppt截图</p>
<p><img src="/images/linux/developing-model.png" alt="Developing-model.png"></p>
<p>mainline, stable, longterm 版本和linux-next都在<code>https://www.kernel.org/</code>有明确标注,也可以通过以下网址浏览</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">mainline: http<span class="variable">s:</span>//git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git</span><br><span class="line">stable/longterm: git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</span><br><span class="line">nex<span class="variable">t:</span> http<span class="variable">s:</span>//git.kernel.org/pub/scm/linux/kernel/git/<span class="keyword">next</span>/linux-<span class="keyword">next</span>.git</span><br><span class="line"></span><br><span class="line">单拉仓也是通过git.kernel.org，比如linux-meida</span><br><span class="line">gi<span class="variable">t:</span>//git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media.git, 见http<span class="variable">s:</span>//git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media.git/</span><br></pre></td></tr></table></figure>

<h3 id="linux官网"><a href="#linux官网" class="headerlink" title="linux官网"></a>linux官网</h3><p><a href="https://www.kernel.org/">linux官网</a></p>
<p>有对其他相关网址的补充,之后会进行比较详细的描述</p>
<p><img src="/images/linux/linux-other-resource.png" alt="linux-other-resource.png"></p>
<h3 id="LXR"><a href="#LXR" class="headerlink" title="LXR"></a>LXR</h3><p>我们可以查看从v2.6.12到最新版本的全部代码</p>
<p><a href="http://lxr.linux.no/linux">linux-lxr</a></p>
<h3 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h3><p>如果需要提交我们的补丁到内核，我们需要明确我们更改子系统的维护者。</p>
<p><a href="http://vger.kernel.org/vger-lists.html/">子系统邮件服务器</a></p>
<p>假如当我们需要给V4L打补丁前，我们可以订阅该子系统邮件，点击subscribe，会通过<a href="mailto:&#x4d;&#x61;&#106;&#111;&#x72;&#100;&#x6f;&#x6d;&#x6f;&#64;&#118;&#103;&#x65;&#114;&#46;&#107;&#x65;&#114;&#110;&#101;&#x6c;&#46;&#111;&#x72;&#x67;">&#x4d;&#x61;&#106;&#111;&#x72;&#100;&#x6f;&#x6d;&#x6f;&#64;&#118;&#103;&#x65;&#114;&#46;&#107;&#x65;&#114;&#110;&#101;&#x6c;&#46;&#111;&#x72;&#x67;</a>进行邮件订阅, 之后提交补丁以后可以通过邮件看到</p>
<p>而邮件也是我们提交代码和代码review的方式</p>
<p>建议使用如下规则回复进行订阅，否则可能会出现订阅失败</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">auth authid subscribe linux-subsys \</span><br><span class="line">        your-email</span><br></pre></td></tr></table></figure>

<p>订阅成功会受到如下</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Welcome <span class="keyword">to</span> <span class="keyword">the</span> linux-media mailing <span class="built_in">list</span>!</span><br></pre></td></tr></table></figure>

<p>也可以通过linux/MAINTAINERS来查找，比如V4L框架</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">MEDIA INPUT INFRASTRUCTURE (V4L/DVB)      </span><br><span class="line">M:  Mauro Carvalho Chehab &lt;mchehab@kernel.org&gt;      </span><br><span class="line">L:  linux-media@vger.kernel.org      </span><br><span class="line">S:  Maintained      </span><br><span class="line">W:  http<span class="variable">s:</span>//linuxtv.org      </span><br><span class="line">Q:  http://patchwork.kernel.org/project/linux-media/<span class="keyword">list</span>/      </span><br><span class="line">T:  git gi<span class="variable">t:</span>//linuxtv.org/media_tree.git      </span><br><span class="line">F:  Documentation/admin-guide/media/  </span><br></pre></td></tr></table></figure>

<p>高通camera子系统camss架构，主要是csid-csiphy-ispif部分</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">QUALCOMM CAMERA SUBSYSTEM DRIVER      </span><br><span class="line">M:  Robert Foss &lt;robert.foss@linaro.org&gt;      </span><br><span class="line">M:  Todor Tomov &lt;todor.too@gmail.<span class="keyword">com</span>&gt;      </span><br><span class="line">L:  linux-media@vger.kernel.org                                                                                                                                                                                     </span><br><span class="line">S:  Maintained      </span><br><span class="line">F:  Documentation/admin-guide/media/qcom_camss.rst      </span><br><span class="line">F:  Documentation/devicetree/bindings/media/*camss*      </span><br><span class="line">F:  drivers/media/platform/qcom/camss/ </span><br></pre></td></tr></table></figure>

<h3 id="patchwork"><a href="#patchwork" class="headerlink" title="patchwork"></a>patchwork</h3><p><a href="https://patchwork.kernel.org/">linux-patchwork</a></p>
<p>可以在patchwork中查看各子系统的通过mailing抓取的patch</p>
<h3 id="bugzilla"><a href="#bugzilla" class="headerlink" title="bugzilla"></a>bugzilla</h3><p><a href="https://bugzilla.kernel.org/">linux-bugzilla</a></p>
<p>在这里我们可以查看最近提交的bug.</p>
<p><img src="/images/linux/linux-bugzilla.png" alt="linux-bugzilla.png"></p>
<h3 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h3><p><a href="https://www.wiki.kernel.org/">wiki-linux</a></p>
<h3 id="IRC"><a href="#IRC" class="headerlink" title="IRC"></a>IRC</h3><p>新建一个IRC网络，输入服务器地址irc.oftc.net和用户名，密码，通过以下进行register</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REGISTER</span> password e-mail</span><br></pre></td></tr></table></figure>

<p>注册成功，提示</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Successfully <span class="keyword">set</span> +R <span class="keyword">on</span> your nick.</span><br></pre></td></tr></table></figure>

<p>如何加入一个子系统的irc聊天室，见<a href="https://kernelnewbies.org/IRC">linux-IRC</a></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Start your favorite IRC client</span><br><span class="line"><span class="built_in">/server </span>irc.oftc.net</span><br><span class="line">/join #kernelnewbies</span><br></pre></td></tr></table></figure>

<p>确定子系统聊天室，比如linux-media</p>
<p><img src="/images/linux/irc-linux-media.png" alt="irc-linux-media.png"></p>
<h2 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h2><h3 id="代码编写规范"><a href="#代码编写规范" class="headerlink" title="代码编写规范"></a>代码编写规范</h3><p>编码规范见<code>Documentation/process/coding-style.rst</code></p>
<p>中文翻译：<code>Documentation/output/translations/zh_CN/process/coding-style.html</code></p>
<p>如果通过<font color=#2196F3 >make htmldocs</font>生成过html文档，见<code>Documentation/output/process/coding-style.html</code></p>
<h3 id="代码提交清单"><a href="#代码提交清单" class="headerlink" title="代码提交清单"></a>代码提交清单</h3><p>提交清单见<code>Documentation/process/submit-checklist.rst </code></p>
<p>中文翻译：<code>Documentation/output/translations/zh_CN/process/submit-checklist.html</code></p>
<p>html文档见<code>Documentation/output/process/submit-checklist.html</code></p>
<h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><h4 id="Sparse"><a href="#Sparse" class="headerlink" title="Sparse"></a>Sparse</h4><p>Sparse是linus自己开发的内核静态分析工具.</p>
<p>对于sparse，可以警告程序员 用户空间和内核空间地址之间的混淆、big endian和small endian数量的混合、在需 要一组位标志的地方传递整数值等等</p>
<p>sparse说明见<code>Documentation/dev-tools/sparse.rst</code></p>
<p>html文档见<code>Documentation/output/dev-tools/sparse.html</code></p>
<p>本地安装sparse</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install sparse </span><br></pre></td></tr></table></figure>

<p>或者编译源码（推荐）</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone gi<span class="variable">t:</span>//git.kernel.org/pub/scm/devel/sparse/sparse.git</span><br><span class="line"><span class="keyword">make</span></span><br><span class="line"><span class="keyword">make</span> install</span><br><span class="line"></span><br><span class="line">//如果缺少依赖包，根据Makefile编写code安装相关</span><br><span class="line">apt-<span class="built_in">get</span> install libxml2</span><br><span class="line">apt-<span class="built_in">get</span> install libxml2-dev</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="built_in">get</span> install sqlite3</span><br><span class="line">sudo apt-<span class="built_in">get</span> install libsqlite3-dev</span><br><span class="line">//如果版本太老，需要从http<span class="variable">s:</span>//www.sqlite.org/download.html下载手动安装</span><br><span class="line">wget http<span class="variable">s:</span>//www.sqlite.org/snapshot/sqlite-snapshot-<span class="number">202110132029</span>.tar.gz --<span class="keyword">no</span>-check-certificate</span><br><span class="line">./configure </span><br><span class="line"><span class="keyword">make</span></span><br><span class="line"><span class="keyword">make</span> install</span><br><span class="line"><span class="keyword">cp</span> sparse /bin/.</span><br><span class="line"><span class="keyword">cp</span> sparse /usr/bin/.</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="built_in">get</span> install libgtk-<span class="number">3</span>-dev</span><br><span class="line">sudo apt-<span class="built_in">get</span> install llvm</span><br></pre></td></tr></table></figure>

<p>即使是本地编译的sparse，依旧会出现以下错误</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">➜  v4l2-core gi<span class="variable">t:</span>(master) sparse -<span class="keyword">a</span> tuner-core.<span class="keyword">c</span></span><br><span class="line">tuner-core.<span class="keyword">c</span>:<span class="number">18</span>:<span class="number">11</span>: error: unable <span class="keyword">to</span> <span class="keyword">open</span> <span class="string">&#x27;linux/module.h&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Coccinelle"><a href="#Coccinelle" class="headerlink" title="Coccinelle"></a>Coccinelle</h4><p>Coccinelle能够发现各种潜在的编码问题；它还可以为这些问题提出修复方案.</p>
<p>sparse说明见<code>Documentation/dev-tools/coccinelle.rst</code></p>
<p>内核语义补丁见<code>scripts/coccinelle</code></p>
<p>html文档见<code>Documentation/output/dev-tools/coccinelle.html</code></p>
<p>本地安装</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install coccinelle</span><br></pre></td></tr></table></figure>

<p>源码编译安装Coccinelle</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone git@github.<span class="keyword">com</span>:coccinelle/coccinelle.git</span><br><span class="line">sudo apt-<span class="built_in">get</span> install autoconf</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="built_in">get</span> install ocaml</span><br><span class="line">sudo apt-<span class="built_in">get</span> install ocaml-interp</span><br><span class="line">sudo apt-<span class="built_in">get</span> install ocaml-native-compilers</span><br><span class="line">sudo apt-<span class="built_in">get</span> install ocaml-nox</span><br><span class="line"></span><br><span class="line"><span class="keyword">cp</span> spatch.<span class="keyword">opt</span> /usr/bin/.</span><br><span class="line"></span><br><span class="line">tes<span class="variable">t:</span></span><br><span class="line"> spatch -sp_file demos/simple.cocci demos/simple.<span class="keyword">c</span> -<span class="keyword">o</span> /tmp/new_simple.<span class="keyword">c</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">➜  coccinelle gi<span class="variable">t:</span>(master) ✗ spatch -sp_file demos/simple.cocci demos/simple.<span class="keyword">c</span> -<span class="keyword">o</span> /tmp/new_simple.<span class="keyword">c</span></span><br><span class="line">init_defs_builtin<span class="variable">s:</span> /usr/lib/coccinelle/standard.h</span><br><span class="line">HANDLING: demos/simple.<span class="keyword">c</span></span><br><span class="line">diff = </span><br><span class="line">--- demos/simple.<span class="keyword">c</span></span><br><span class="line">+++ /tmp/cocci-output-<span class="number">859</span>-aeb2ab-simple.<span class="keyword">c</span></span><br><span class="line">@@ -<span class="number">1</span>,<span class="number">4</span> +<span class="number">1</span>,<span class="number">4</span> @@</span><br><span class="line"> <span class="keyword">int</span> main(<span class="keyword">int</span> i) &#123;</span><br><span class="line">-  f(&quot;ca va&quot;);</span><br><span class="line">-  f(g(&quot;ca va pas&quot;));</span><br><span class="line">+  f(&quot;ca va&quot;, 3);</span><br><span class="line">+  f(g(&quot;ca va pas&quot;), 3);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">//测试ocamlrun报错</span><br><span class="line">➜  coccinelle gi<span class="variable">t:</span>(master) ✗ ocamlrun spatch -sp_file demos/simple.cocci demos/simple.<span class="keyword">c</span> -<span class="keyword">o</span> /tmp/new_simple.<span class="keyword">c</span></span><br><span class="line">Fatal error: the <span class="keyword">file</span> <span class="string">&#x27;/usr/bin/spatch&#x27;</span> <span class="keyword">is</span> not <span class="keyword">a</span> bytecode <span class="built_in">executable</span> <span class="keyword">file</span></span><br><span class="line"></span><br><span class="line">版面check</span><br><span class="line">➜  coccinelle gi<span class="variable">t:</span>(master) ✗ ocaml -<span class="keyword">version</span>                                                                 </span><br><span class="line">The OCaml toplevel, <span class="keyword">version</span> <span class="number">4.02</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line">➜  coccinelle gi<span class="variable">t:</span>(master) ✗ camlp4 -<span class="keyword">version</span></span><br><span class="line"><span class="number">4.02</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line">貌似从ocaml <span class="number">4.0</span>.<span class="number">2</span>开始，camlp4已经被遗弃使用</span><br></pre></td></tr></table></figure>

<h2 id="提交补丁"><a href="#提交补丁" class="headerlink" title="提交补丁"></a>提交补丁</h2><h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><p>在.git/config中增加以下部分</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[user]    </span><br><span class="line">    email = xiaer1921@gmail.<span class="keyword">com</span>   </span><br><span class="line">    name = xiaer1921    </span><br><span class="line">[core]    </span><br><span class="line">    editor = <span class="keyword">vim</span>    </span><br><span class="line">[color]    </span><br><span class="line">    ui = auto    </span><br><span class="line">[sendemail]    </span><br><span class="line">    smtpserver = smtp.gmail.<span class="keyword">com</span>    </span><br><span class="line">    smtpserverport = <span class="number">587</span>                                                                              </span><br><span class="line">    smtpencryption = tls    </span><br><span class="line">    smtpuser = xiaer1921@gmail.<span class="keyword">com</span> </span><br></pre></td></tr></table></figure>

<h3 id="制作补丁"><a href="#制作补丁" class="headerlink" title="制作补丁"></a>制作补丁</h3><p>举例：scripts/gdb/linux/tasks.py 没有增加SPDX许可，增加许可</p>
<p>文件规范检查</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">./scripts/checkpatch.pl --<span class="keyword">file</span> scripts/gdb/linux/tasks.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>

<p>常见的错误如下</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">//第一行没有增加SPDX许可，警告如下</span><br><span class="line">WARNING: Missing <span class="built_in">or</span> malformed SPDX-License-Identifier <span class="keyword">tag</span> in <span class="built_in">line</span> <span class="number">1</span></span><br><span class="line">//第一行正确格式</span><br><span class="line"># SPDX-License-Identifier: GPL-<span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<h4 id="提交commit"><a href="#提交commit" class="headerlink" title="提交commit"></a>提交commit</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git add scripts<span class="regexp">/gdb/</span>linux/tasks.py</span><br><span class="line">git commit -s <span class="regexp">//</span>进行签名</span><br></pre></td></tr></table></figure>

<p>提交描述中规范如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">//第一行对修改的简短描述，将成为邮件的标题</span><br><span class="line">//第二行空行</span><br><span class="line">//第三行，对修改的详细描述，将成为邮件内容</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="生成patch"><a href="#生成patch" class="headerlink" title="生成patch"></a>生成patch</h4><p>针对最近的commit生成patch <code>git format-patch -1 -o .</code> -1为最近的commit</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">➜  linux gi<span class="variable">t:</span>(master) git format-patch HEAD~</span><br><span class="line"><span class="number">0001</span>-scripts-gdb-<span class="built_in">add</span>-SPDX-license-<span class="keyword">for</span>-scripts-gdb-linux-t.patch</span><br></pre></td></tr></table></figure>

<p><font color=#2196F3 >patch规范检查</font> </p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">./scripts/checkpatch.pl --file 0001-scripts-gdb-add-SPDX-license-for-scripts-gdb-linux-t.patch</span><br><span class="line"><span class="comment">//如果没有增加第三行详细描述部分，会进行警告</span></span><br><span class="line"><span class="symbol">WARNING: </span>Missing commit description - Add an appropriate one</span><br><span class="line"><span class="comment">//规范检查正确</span></span><br><span class="line">0001-scripts-gdb-add-SPDX-license-for-scripts-gdb-linux-t.patch has no obvious style problems and is ready for submission.</span><br></pre></td></tr></table></figure>

<p>获取patch的维护人员</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">➜  linux git:(master) ./scripts/get_maintainer.pl <span class="number">0001</span>-scripts-gdb-add-SPDX-license-<span class="keyword">for</span>-scripts-gdb-linux-t.patch </span><br><span class="line">Jan Kiszka &lt;jan.<span class="symbol">kiszka@</span>siemens.com&gt; (supporter:GDB KERNEL DEBUGGING HELPER SCRIPTS,commit_signer:<span class="number">1</span>/<span class="number">2</span>=<span class="number">50</span>%)</span><br><span class="line">Kieran Bingham &lt;<span class="symbol">kbingham@</span>kernel.org&gt; (supporter:GDB KERNEL DEBUGGING HELPER SCRIPTS)</span><br><span class="line">Andrew Morton &lt;<span class="symbol">akpm@</span>linux-foundation.org&gt; (commit_signer:<span class="number">1</span>/<span class="number">2</span>=<span class="number">50</span>%)</span><br><span class="line">Ritesh Harjani &lt;<span class="symbol">riteshh@</span>linux.ibm.com&gt; (commit_signer:<span class="number">1</span>/<span class="number">2</span>=<span class="number">50</span>%,authored:<span class="number">1</span>/<span class="number">2</span>=<span class="number">50</span>%,added_lines:<span class="number">5</span>/<span class="number">6</span>=<span class="number">83</span>%,removed_lines:<span class="number">4</span>/<span class="number">5</span>=<span class="number">80</span>%)</span><br><span class="line">xiaer1921 &lt;<span class="symbol">xiaer1921@</span>aliyun.com&gt; (commit_signer:<span class="number">1</span>/<span class="number">2</span>=<span class="number">50</span>%,authored:<span class="number">1</span>/<span class="number">2</span>=<span class="number">50</span>%,added_lines:<span class="number">1</span>/<span class="number">6</span>=<span class="number">17</span>%,removed_lines:<span class="number">1</span>/<span class="number">5</span>=<span class="number">20</span>%)</span><br><span class="line">linux-<span class="symbol">kernel@</span>vger.kernel.org (open list)</span><br></pre></td></tr></table></figure>

<p>发送patch</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git send-email --<span class="keyword">to</span> jan.kiszka@siemens.<span class="keyword">com</span> --<span class="keyword">to</span> kbingham@kernel.org --<span class="keyword">cc</span> linux-kernel@vger.kernel.org <span class="number">0001</span>-scripts-gdb-<span class="built_in">add</span>-SPDX-license-<span class="keyword">for</span>-scripts-gdb-linux-t.patch</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://tinylab.org/upstream-patches-to-linux-mainline/">泰晓科技-Linux upstream: 给 Linus 发个 patch 吧</a></li>
<li><a href="http://tinylab.org/wp-content/uploads/2016/01/linux-community-and-upstream-linux-codes.pdf">宋宝华-Linux community and Upstream Linux Codes</a></li>
<li><a href="http://tinylab.org/wp-content/uploads/2013/06/how-to-contribute-to-linux-mainline.pdf">泰晓科技-how-to-contribute-to-linux-mainline</a></li>
<li><a href="http://tinylab.org/embedded-linux-kernel-mailining/">泰晓科技-如何贡献内核补丁</a></li>
<li><a href="http://tinylab.org/latest-linux-code/">泰晓科技-如何获取某个 Linux 子系统上游的最新代码</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/75366661">hello小崔的linux</a></li>
<li><a href="https://blog.csdn.net/cui841923894/article/details/81545627">hello小崔-LTP提交补丁</a></li>
<li><a href="https://www.cnblogs.com/wang_yb/p/3575039.html">内核工具 – Sparse 简介</a></li>
<li><a href="https://www.cnblogs.com/bhlsheji/p/5386611.html">请善用工具审核您的内核代码</a></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mailing list</tag>
        <tag>IRC</tag>
        <tag>patchwork</tag>
        <tag>bugzilla</tag>
        <tag>sparse</tag>
        <tag>coccinelle</tag>
      </tags>
  </entry>
  <entry>
    <title>程序分析利器gdb</title>
    <url>/archives/3.html</url>
    <content><![CDATA[<h1 id="程序分析利器gdb"><a href="#程序分析利器gdb" class="headerlink" title="程序分析利器gdb"></a>程序分析利器gdb</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过gdb可以分析进程在运行和crash的内部状态，根据man手册描述有以下作用</p>
<ol>
<li> 控制进程的开始和结束</li>
<li> 设置进程暂停的条件</li>
<li> 检查进程暂停时的堆栈等信息</li>
<li> 改变程序变量等因素影响程序</li>
</ol>
<a id="more"></a>
<hr>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在编译时应该增加-g选项</p>
<p><code>g++ -o out -g test.cpp</code></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ol>
<li><p>调试一个程序</p>
<p><code>gdb program</code></p>
</li>
<li><p>调试程序带着core</p>
<p><code>gdb program core</code></p>
</li>
<li><p>指定pid调试</p>
<p><code>gdb -p pid</code></p>
</li>
</ol>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>gdb提供了丰富的命令来，常用的选项如下：</p>
<h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>开始执行程序，如果需要增加参数，需要增加在run后边</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) run -m strace -f blk</span><br><span class="line">Starting program: /work/chejian/test/kernel_tool_test/test-run -m strace -f blk</span><br></pre></td></tr></table></figure>

<h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>简写为b，设置断点，程序运行到此处之前停止，可以指定函数和行数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) break test_module</span><br><span class="line">Breakpoint 1 at 0x401a54: file src/test/test.c, line 100.</span><br><span class="line">(gdb) break 116</span><br><span class="line">Breakpoint 2 at 0x401aff: file src/test/test.c, line 116.</span><br></pre></td></tr></table></figure>

<h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><p>简写为n，开始执行下一条指令，但是不会进入函数内部，测试代码test.c如下（以下默认测试代码均为test.c）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in function test\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;i is %d\n&quot;</span>, i);</span><br><span class="line">       test(i);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置断点，观察next结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) break 13</span><br><span class="line">Breakpoint 1 at 0x400599: file test.c, line 13.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /work/chejian/test/test</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:13</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br><span class="line">(gdb) n</span><br><span class="line">i is 0</span><br><span class="line">14             test(i);</span><br><span class="line">(gdb) n      &gt;&gt;不会进入test函数</span><br><span class="line">in function test</span><br><span class="line">12         for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:13</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br></pre></td></tr></table></figure>

<h4 id="step"><a href="#step" class="headerlink" title="step"></a>step</h4><p>简写为s，要和next进行区分，step会进行函数内部打印，比如printf和test</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b 13</span><br><span class="line">Breakpoint 1 at 0x400599: file test.c, line 13.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /work/chejian/test/test</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:13</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br><span class="line">(gdb) n</span><br><span class="line">i is 0</span><br><span class="line">14             test(i);</span><br><span class="line">(gdb) step    &gt;&gt;进入test函数内部</span><br><span class="line">test (j=0) at test.c:7</span><br><span class="line">7           printf(&quot;in function test\n&quot;);</span><br><span class="line">(gdb) n</span><br><span class="line">in function test</span><br><span class="line">8       &#125;</span><br><span class="line">(gdb) n</span><br><span class="line">main () at test.c:12</span><br><span class="line">12         for(int i = 0; i &lt; 10; i++)&#123;</span><br></pre></td></tr></table></figure>

<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>简写为c，继续执行程序直到遇到断点，和next命令测试共用测试代码test.c，设置断点，观察continue结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) run                                 </span><br><span class="line">Starting program: /work/chejian/test/test </span><br><span class="line">hello world                               </span><br><span class="line">                                          </span><br><span class="line">Breakpoint 1, main () at test.c:13        </span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);    </span><br><span class="line">(gdb) c                                   </span><br><span class="line">Continuing.                               </span><br><span class="line">i is 0                                    </span><br><span class="line">in function test                          </span><br><span class="line">                                          </span><br><span class="line">Breakpoint 1, main () at test.c:13        </span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);    </span><br><span class="line">(gdb) c                                   </span><br><span class="line">Continuing.                               </span><br><span class="line">i is 1                                    </span><br><span class="line">in function test                          </span><br><span class="line">                                          </span><br><span class="line">Breakpoint 1, main () at test.c:13        </span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);    </span><br></pre></td></tr></table></figure>

<h4 id="backtrace"><a href="#backtrace" class="headerlink" title="backtrace"></a>backtrace</h4><p>简写为bt，打印堆栈</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b 7</span><br><span class="line">Breakpoint 1 at 0x400571: file test.c, line 7.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /work/chejian/test/test</span><br><span class="line">hello world</span><br><span class="line">i is 0</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test (j=0) at test.c:7</span><br><span class="line">7           printf(&quot;in function test\n&quot;);</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#</span><span class="bash">0  <span class="built_in">test</span> (j=0) at test.c:7    &gt;&gt;此时stop在<span class="built_in">test</span>函数中，因此是栈顶</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x00000000004005b7 <span class="keyword">in</span> main () at test.c:14</span></span><br></pre></td></tr></table></figure>

<h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>展示有用的一些信息，比如断点设置等</p>
<h5 id="info-break"><a href="#info-break" class="headerlink" title="info break"></a>info break</h5><p>打印设置的堆栈信息已经命中次数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b 7</span><br><span class="line">Breakpoint 1 at 0x400571: file test.c, line 7.</span><br><span class="line">(gdb) b 13</span><br><span class="line">Breakpoint 2 at 0x400599: file test.c, line 13.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /work/chejian/test/test</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at test.c:13</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br><span class="line">(gdb) info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000400571 in test at test.c:7</span><br><span class="line">2       breakpoint     keep y   0x0000000000400599 in main at test.c:13</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">i is 0</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test (j=0) at test.c:7</span><br><span class="line">7           printf(&quot;in function test\n&quot;);</span><br><span class="line">(gdb) info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000400571 in test at test.c:7</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x0000000000400599 in main at test.c:13</span><br><span class="line">        breakpoint already hit 1 time</span><br></pre></td></tr></table></figure>

<h4 id="print"><a href="#print" class="headerlink" title="print"></a>print</h4><p>简写为p，打印一个变量的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b 13</span><br><span class="line">Breakpoint 1 at 0x400599: file test.c, line 13.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /work/chejian/test/test</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:13</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br><span class="line">(gdb) p i</span><br><span class="line"><span class="meta">$</span><span class="bash">1 = 0</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">i is 0</span><br><span class="line">in function test</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:13</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br><span class="line">(gdb) p i</span><br><span class="line"><span class="meta">$</span><span class="bash">2 = 1</span></span><br></pre></td></tr></table></figure>

<h4 id="x"><a href="#x" class="headerlink" title="x"></a>x</h4><p>按照选项要求来显示对应地址的内容，使用方式为x/FMT ADDRESS</p>
<p>FMT有如下几种设置： </p>
<blockquote>
<p>  o(octal), x(hex), d(decimal), u(unsigned decimal),<br>  t(binary), f(float), a(address), i(instruction), c(char), s(string)<br>  z(hex, zero padded on the left).</p>
</blockquote>
<p>测试代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">6</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">int</span> addr = &amp;j;</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">char</span> buf=<span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">char</span> *buf1=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="number">10</span>     <span class="built_in">printf</span>(<span class="string">&quot;in function the addr of j is: %p, test j == %d\n&quot;</span>, addr, j);</span><br><span class="line"><span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure>

<p>测试如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b 10                                                                                    </span><br><span class="line">Breakpoint 1 at 0x400588: file test.c, line 10.                                               </span><br><span class="line">(gdb) run                                                                                     </span><br><span class="line">Starting program: /work/chejian/test/test                                                     </span><br><span class="line">hello world                                                                                   </span><br><span class="line">i is 0                                                                                        </span><br><span class="line">                                                                                              </span><br><span class="line">Breakpoint 1, test (j=0) at test.c:10                                                         </span><br><span class="line">10          printf(&quot;in function the addr of j is: %p, test j == %d\n&quot;, addr, j);              </span><br><span class="line">(gdb) c                                                                                       </span><br><span class="line">Continuing.                                                                                   </span><br><span class="line">in function the addr of j is: 0xffffe51c, test j == 0                                         </span><br><span class="line">i is 1                                                                                        </span><br><span class="line">                                                                                              </span><br><span class="line">Breakpoint 1, test (j=1) at test.c:10                                                         </span><br><span class="line">10          printf(&quot;in function the addr of j is: %p, test j == %d\n&quot;, addr, j);              </span><br><span class="line">(gdb) c                                                                                       </span><br><span class="line">Continuing.                                                                                   </span><br><span class="line">in function the addr of j is: 0xffffe51c, test j == 1                                         </span><br><span class="line">i is 2                                                                                        </span><br><span class="line">                                                                                              </span><br><span class="line">Breakpoint 1, test (j=2) at test.c:10                                                         </span><br><span class="line">10          printf(&quot;in function the addr of j is: %p, test j == %d\n&quot;, addr, j);              </span><br><span class="line">(gdb) c                                                                                       </span><br><span class="line">Continuing.                                                                                   </span><br><span class="line">in function the addr of j is: 0xffffe51c, test j == 2                                         </span><br><span class="line">i is 3                                                                                        </span><br><span class="line">                                                                                              </span><br><span class="line">Breakpoint 1, test (j=3) at test.c:10    &gt;&gt;第三次断点捕捉</span><br><span class="line">10          printf(&quot;in function the addr of j is: %p, test j == %d\n&quot;, addr, j);              </span><br><span class="line">(gdb) display j                                                                               </span><br><span class="line">1: j = 3                             &gt;&gt;此时j为3</span><br><span class="line">(gdb) x/i &amp;j         &gt;&gt;i 对应指令 ，打印j的地址和对应的汇编指令</span><br><span class="line">   0x7fffffffe51c:      add    (%rax),%eax                                                    </span><br><span class="line">(gdb) x/o &amp;j                  &gt;&gt;八进制打印 </span><br><span class="line">0x7fffffffe51c: 03                                                                            </span><br><span class="line">(gdb) x/x &amp;j                     &gt;&gt;十六进制打印 </span><br><span class="line">0x7fffffffe51c: 0x00000003                                                                    </span><br><span class="line">(gdb) x/d &amp;j                           &gt;&gt;十进制打印</span><br><span class="line">0x7fffffffe51c: 3                                                                             </span><br><span class="line">(gdb) x/u &amp;j             &gt;&gt;无符号十进制打印</span><br><span class="line">0x7fffffffe51c: 3                                                                             </span><br><span class="line">(gdb) x/t &amp;j                  &gt;&gt;二进制打印</span><br><span class="line">0x7fffffffe51c: 00000000000000000000000000000011                                              </span><br><span class="line">(gdb) x/a &amp;j                                &gt;&gt;地址打印</span><br><span class="line">0x7fffffffe51c: 0x7800000000000003                                                            </span><br><span class="line">(gdb) x/c &amp;buf                                   &gt;&gt;字符打印</span><br><span class="line">0x7fffffffe523: 67 &#x27;C&#x27;                                                                       </span><br><span class="line">(gdb) print buf                                                                                 </span><br><span class="line"><span class="meta">$</span><span class="bash">1 = 67 <span class="string">&#x27;C&#x27;</span>                                                                                </span></span><br><span class="line">(gdb) display buf                                                                             </span><br><span class="line">2: buf = 67 &#x27;C&#x27;                                                                              </span><br><span class="line">(gdb) x/c &amp;buf1                                                                               </span><br><span class="line">0x7fffffffe528: 122 &#x27;z&#x27;    &gt;&gt;为什么z?因为 0x7fffffffe528存放的是0x40067a， 7a就是z的ASCII码</span><br><span class="line">(gdb) x/s buf1                                                                                </span><br><span class="line">0x40067a:       &quot;hello world&quot;                                                                 </span><br><span class="line">(gdb) x/c buf1                                                                                </span><br><span class="line">0x40067a:       104 &#x27;h&#x27;                                                                       </span><br></pre></td></tr></table></figure>

<p>x/i  $pc也可以打印当前pc指令的地址和汇编信息，见display测试部分。</p>
<h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p>在==每一次==程序运行停止前打印变量，功能和print类似，但是有更多扩展，一般用法为display var</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b 7</span><br><span class="line">Breakpoint 1 at 0x400571: file test.c, line 7.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /work/chejian/test/test</span><br><span class="line">hello world</span><br><span class="line">i is 0</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test (j=0) at test.c:7</span><br><span class="line">7           printf(&quot;in function test j == %d\n&quot;, j);</span><br><span class="line">(gdb) display j</span><br><span class="line">1: j = 0   &gt;&gt;打印变量</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">in function test j == 0</span><br><span class="line">i is 1    &gt;&gt;停止后打印一次</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test (j=1) at test.c:7</span><br><span class="line">7           printf(&quot;in function test j == %d\n&quot;, j);</span><br><span class="line">1: j = 1</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">in function test j == 1</span><br><span class="line">i is 2</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test (j=2) at test.c:7</span><br><span class="line">7           printf(&quot;in function test j == %d\n&quot;, j);</span><br><span class="line">1: j = 2       &gt;&gt;停止后打印一次</span><br><span class="line">(gdb) display &amp;j    &gt;&gt;打印j变量的地址</span><br><span class="line">3: &amp;j = (int *) 0x7fffffffe51c    &gt;&gt;3是指第几次执行display命令</span><br></pre></td></tr></table></figure>

<p>也可以直接display执行，这样会在每一次结束之后打印全部的变量，</p>
<p>display也可以打印当前的pc</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble <span class="keyword">test</span></span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function <span class="keyword">test</span>:</span><br><span class="line">   0x0000000000400566 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x0000000000400567 &lt;+1&gt;:     <span class="keyword">mov</span>    %rsp,%rbp</span><br><span class="line">   0x000000000040056a &lt;+4&gt;:     sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">   0x000000000040056e &lt;+8&gt;:     <span class="keyword">mov</span>    %<span class="keyword">edi</span>,-0x4(%rbp)</span><br><span class="line">=&gt; 0x0000000000400571 &lt;+11&gt;:    <span class="keyword">mov</span>    -0x4(%rbp),%eax  &gt;&gt;当前执行在<span class="keyword">test</span>函数中</span><br><span class="line">   0x0000000000400574 &lt;+14&gt;:    <span class="keyword">mov</span>    %eax,%esi</span><br><span class="line">   0x0000000000400576 &lt;+16&gt;:    <span class="keyword">mov</span>    <span class="variable">$0x400664</span>,%<span class="keyword">edi</span></span><br><span class="line">   0x000000000040057b &lt;+21&gt;:    <span class="keyword">mov</span>    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000400580 &lt;+26&gt;:    callq  0x400440 &lt;printf@plt&gt;</span><br><span class="line">   0x0000000000400585 &lt;+31&gt;:    nop</span><br><span class="line">   0x0000000000400586 &lt;+32&gt;:    leaveq</span><br><span class="line">   0x0000000000400587 &lt;+33&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) <span class="keyword">display</span> <span class="variable">$pc</span>   &gt;&gt;当前的pc指令</span><br><span class="line">10: <span class="variable">$pc</span> = (void (*)()) 0x400571 &lt;<span class="keyword">test</span>+11&gt;</span><br><span class="line">(gdb) <span class="keyword">display</span>/i <span class="variable">$pc</span>  &gt;&gt;相当于x/i <span class="variable">$pc</span></span><br><span class="line">11: x/i <span class="variable">$pc</span>    &gt;&gt;当前的pc汇编指令</span><br><span class="line">=&gt; 0x400571 &lt;<span class="keyword">test</span>+11&gt;:  <span class="keyword">mov</span>    -0x4(%rbp),%eax</span><br><span class="line">(gdb) <span class="keyword">display</span>/3i <span class="variable">$pc</span></span><br><span class="line">12: x/3i <span class="variable">$pc</span>   &gt;&gt;从当前开始的三条汇编指令</span><br><span class="line">=&gt; 0x400571 &lt;<span class="keyword">test</span>+11&gt;:  <span class="keyword">mov</span>    -0x4(%rbp),%eax</span><br><span class="line">   0x400574 &lt;<span class="keyword">test</span>+14&gt;:  <span class="keyword">mov</span>    %eax,%esi</span><br><span class="line">   0x400576 &lt;<span class="keyword">test</span>+16&gt;:  <span class="keyword">mov</span>    <span class="variable">$0x400664</span>,%<span class="keyword">edi</span></span><br></pre></td></tr></table></figure>

<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>可以对 寄存器变量，调试程序中的变量进行赋值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b 13</span><br><span class="line">Breakpoint 1 at 0x400599: file test.c, line 13.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /work/chejian/test/test</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:13</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br><span class="line">(gdb) p i</span><br><span class="line"><span class="meta">$</span><span class="bash">1 = 0</span></span><br><span class="line">(gdb) set variable i=3</span><br><span class="line">(gdb) p i</span><br><span class="line"><span class="meta">$</span><span class="bash">2 = 3</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">i is 3</span><br><span class="line">in function test</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:13</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br><span class="line">(gdb) p i</span><br><span class="line"><span class="meta">$</span><span class="bash">3 = 4</span></span><br></pre></td></tr></table></figure>



<p>####ni/si</p>
<p>ni和si有点类似next和step，只不过是后面多了具体的步数，默认是1步</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(gdb)</span> <span class="string">b</span> <span class="number">7</span></span><br><span class="line"><span class="attr">Breakpoint 1 at 0x400571:</span> <span class="string">file</span> <span class="string">test.c,</span> <span class="string">line</span> <span class="number">7</span><span class="string">.</span></span><br><span class="line"><span class="string">(gdb)</span> <span class="string">run</span></span><br><span class="line"><span class="attr">Starting program:</span> <span class="string">/work/chejian/test/test</span></span><br><span class="line"><span class="string">hello</span> <span class="string">world</span></span><br><span class="line"><span class="string">i</span> <span class="string">is</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="string">Breakpoint</span> <span class="number">1</span><span class="string">,</span> <span class="string">test</span> <span class="string">(j=0)</span> <span class="string">at</span> <span class="string">test.c:7</span></span><br><span class="line"><span class="number">7</span>           <span class="string">printf(&quot;in</span> <span class="string">function</span> <span class="string">test</span> <span class="string">j</span> <span class="string">==</span> <span class="string">%d\n&quot;,</span> <span class="string">j);</span></span><br><span class="line"><span class="string">(gdb)</span> <span class="string">disassemble</span></span><br><span class="line"><span class="attr">Dump of assembler code for function test:</span></span><br><span class="line">   <span class="number">0x0000000000400566</span> <span class="string">&lt;+0&gt;:</span>     <span class="string">push</span>   <span class="string">%rbp</span></span><br><span class="line">   <span class="number">0x0000000000400567</span> <span class="string">&lt;+1&gt;:</span>     <span class="string">mov</span>    <span class="string">%rsp,%rbp</span></span><br><span class="line">   <span class="number">0x000000000040056a</span> <span class="string">&lt;+4&gt;:</span>     <span class="string">sub</span>    <span class="string">$0x10,%rsp</span></span><br><span class="line">   <span class="number">0x000000000040056e</span> <span class="string">&lt;+8&gt;:</span>     <span class="string">mov</span>    <span class="string">%edi,-0x4(%rbp)</span></span><br><span class="line"><span class="string">=&gt;</span> <span class="number">0x0000000000400571</span> <span class="string">&lt;+11&gt;:</span>    <span class="string">mov</span>    <span class="number">-0x4</span><span class="string">(%rbp),%eax</span>    <span class="string">&gt;&gt;目前的pc地址，而且将test函数全部打印</span></span><br><span class="line">   <span class="number">0x0000000000400574</span> <span class="string">&lt;+14&gt;:</span>    <span class="string">mov</span>    <span class="string">%eax,%esi</span></span><br><span class="line">   <span class="number">0x0000000000400576</span> <span class="string">&lt;+16&gt;:</span>    <span class="string">mov</span>    <span class="string">$0x400664,%edi</span></span><br><span class="line">   <span class="number">0x000000000040057b</span> <span class="string">&lt;+21&gt;:</span>    <span class="string">mov</span>    <span class="string">$0x0,%eax</span></span><br><span class="line">   <span class="number">0x0000000000400580</span> <span class="string">&lt;+26&gt;:</span>    <span class="string">callq</span>  <span class="number">0x400440</span> <span class="string">&lt;printf@plt&gt;</span>  <span class="string">&gt;&gt;执行si会进入printf函数内部</span></span><br><span class="line">   <span class="number">0x0000000000400585</span> <span class="string">&lt;+31&gt;:</span>    <span class="string">nop</span></span><br><span class="line">   <span class="number">0x0000000000400586</span> <span class="string">&lt;+32&gt;:</span>    <span class="string">leaveq</span></span><br><span class="line">   <span class="number">0x0000000000400587</span> <span class="string">&lt;+33&gt;:</span>    <span class="string">retq</span></span><br><span class="line"><span class="string">End</span> <span class="string">of</span> <span class="string">assembler</span> <span class="string">dump.</span></span><br><span class="line"><span class="string">(gdb)</span> <span class="string">ni</span></span><br><span class="line"><span class="number">0x0000000000400574</span>      <span class="number">7</span>           <span class="string">printf(&quot;in</span> <span class="string">function</span> <span class="string">test</span> <span class="string">j</span> <span class="string">==</span> <span class="string">%d\n&quot;,</span> <span class="string">j);</span>  <span class="string">&gt;&gt;pc移动到0x400574</span></span><br><span class="line"><span class="string">(gdb)</span> <span class="string">ni</span></span><br><span class="line"><span class="number">0x0000000000400576</span>      <span class="number">7</span>           <span class="string">printf(&quot;in</span> <span class="string">function</span> <span class="string">test</span> <span class="string">j</span> <span class="string">==</span> <span class="string">%d\n&quot;,</span> <span class="string">j);</span></span><br><span class="line"><span class="string">(gdb)</span> <span class="string">ni</span></span><br><span class="line"><span class="number">0x000000000040057b</span>      <span class="number">7</span>           <span class="string">printf(&quot;in</span> <span class="string">function</span> <span class="string">test</span> <span class="string">j</span> <span class="string">==</span> <span class="string">%d\n&quot;,</span> <span class="string">j);</span></span><br><span class="line"><span class="string">(gdb)</span> <span class="string">si</span></span><br><span class="line"><span class="number">0x0000000000400580</span>      <span class="number">7</span>           <span class="string">printf(&quot;in</span> <span class="string">function</span> <span class="string">test</span> <span class="string">j</span> <span class="string">==</span> <span class="string">%d\n&quot;,</span> <span class="string">j);</span>  <span class="string">&gt;&gt;ni会跳转到函数内部</span></span><br><span class="line"><span class="string">(gdb)</span> <span class="string">si</span></span><br><span class="line"><span class="number">0x0000000000400440</span> <span class="string">in</span> <span class="string">printf@plt</span> <span class="string">()</span></span><br></pre></td></tr></table></figure>



<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>简写为l，打印当前程序执行所在行周围的程序文本，如果程序还是没有开始执行，那么从第一行打印，继续回车和l命令执行会继续往下打印程序文本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b 13</span><br><span class="line">Breakpoint 1 at 0x400599: file test.c, line 13.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /work/chejian/test/test</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:13</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br><span class="line">(gdb) l</span><br><span class="line">8       &#125;</span><br><span class="line">9</span><br><span class="line">10      int main() &#123;</span><br><span class="line">11         printf(&quot;hello world\n&quot;);</span><br><span class="line">12         for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br><span class="line">14             test(i);</span><br><span class="line">15         &#125;</span><br><span class="line">16          return 0;</span><br><span class="line">17      &#125;</span><br></pre></td></tr></table></figure>

<p>list也可以执行函数打印</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) list test</span><br><span class="line">1       #include &lt;stdlib.h&gt;</span><br><span class="line">2       #include &lt;string.h&gt;</span><br><span class="line">3       #include &lt;stdio.h&gt;</span><br><span class="line">4       #include &lt;pthread.h&gt;</span><br><span class="line">5</span><br><span class="line">6       void test(int j)&#123;</span><br><span class="line">7           printf(&quot;in function test\n&quot;);</span><br><span class="line">8       &#125;</span><br><span class="line">9</span><br><span class="line">10      int main() &#123;</span><br><span class="line">(gdb) list main</span><br><span class="line">5</span><br><span class="line">6       void test(int j)&#123;</span><br><span class="line">7           printf(&quot;in function test\n&quot;);</span><br><span class="line">8       &#125;</span><br><span class="line">9</span><br><span class="line">10      int main() &#123;</span><br><span class="line">11         printf(&quot;hello world\n&quot;);</span><br><span class="line">12         for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">13             printf(&quot;i is %d\n&quot;, i);</span><br><span class="line">14             test(i);</span><br></pre></td></tr></table></figure>

<h4 id="disasseble"><a href="#disasseble" class="headerlink" title="disasseble"></a>disasseble</h4><p>反汇编内存的指定部分，使用为disasseble ‘file’::func  或者比如disasseble， functest-run是gdb.o和test.o链接完成后的执行程序</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble  test_module  &gt;&gt;test_module是test.c中的函数</span><br><span class="line"><span class="symbol">Dump</span> of assembler <span class="meta">code</span> for <span class="meta">function</span> test_module:</span><br><span class="line">   <span class="number">0x0000000000401a54</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   %<span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000401a56</span> &lt;+<span class="number">2</span>&gt;:     <span class="keyword">push</span>   %**<span class="built_in">r14</span>**</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">(gdb) disassemble test_gdb    &gt;&gt;test_module是gdb.c中的函数</span><br><span class="line"><span class="symbol">Dump</span> of assembler <span class="meta">code</span> for <span class="meta">function</span> test_gdb:</span><br><span class="line">   <span class="number">0x0000000000400f79</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   %<span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400f7b</span> &lt;+<span class="number">2</span>&gt;:     <span class="keyword">push</span>   %<span class="built_in">r14</span></span><br><span class="line">   <span class="number">0x0000000000400f7d</span> &lt;+<span class="number">4</span>&gt;:     <span class="keyword">mov</span>    <span class="number">$0x1</span>,%r14d</span><br></pre></td></tr></table></figure>

<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>disasseble有三个修饰选项可用，</p>
<h6 id="m-按照源程序顺序打印"><a href="#m-按照源程序顺序打印" class="headerlink" title="/m 按照源程序顺序打印"></a>/m 按照源程序顺序打印</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(gdb)</span> <span class="string">disassemble</span> <span class="string">/m</span> <span class="string">main</span>                                             </span><br><span class="line"><span class="attr">Dump of assembler code for function main:</span>                             </span><br><span class="line"><span class="number">10</span>      <span class="string">int</span> <span class="string">main()</span> &#123;                                                  </span><br><span class="line">   <span class="number">0x000000000040057e</span> <span class="string">&lt;+0&gt;:</span>     <span class="string">push</span>   <span class="string">%rbp</span>                           </span><br><span class="line">   <span class="number">0x000000000040057f</span> <span class="string">&lt;+1&gt;:</span>     <span class="string">mov</span>    <span class="string">%rsp</span>,<span class="string">%rbp</span>                      </span><br><span class="line">   <span class="number">0x0000000000400582</span> <span class="string">&lt;+4&gt;:</span>     <span class="string">sub</span>    <span class="string">$0x10</span>,<span class="string">%rsp</span>                     </span><br><span class="line">                                                                      </span><br><span class="line"><span class="number">11</span>         <span class="string">printf(&quot;hello</span> <span class="string">world\n&quot;);</span>                                   </span><br><span class="line">   <span class="number">0x0000000000400586</span> <span class="string">&lt;+8&gt;:</span>     <span class="string">mov</span>    <span class="string">$0x400665</span>,<span class="string">%edi</span>                 </span><br><span class="line">   <span class="number">0x000000000040058b</span> <span class="string">&lt;+13&gt;:</span>    <span class="string">callq</span>  <span class="number">0x400430</span> <span class="string">&lt;puts@plt&gt;</span>            </span><br><span class="line">                                                                      </span><br><span class="line"><span class="number">12</span>         <span class="string">for(int</span> <span class="string">i</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span> <span class="string">i</span> <span class="string">&lt;</span> <span class="number">10</span><span class="string">;</span> <span class="string">i++)</span>&#123;                               </span><br><span class="line">   <span class="number">0x0000000000400590</span> <span class="string">&lt;+18&gt;:</span>    <span class="string">movl</span>   <span class="string">$0x0</span>,<span class="number">-0x4</span><span class="string">(%rbp)</span>                </span><br><span class="line">   <span class="number">0x0000000000400597</span> <span class="string">&lt;+25&gt;:</span>    <span class="string">jmp</span>    <span class="number">0x4005bb</span> <span class="string">&lt;main+61&gt;</span>             </span><br><span class="line">   <span class="number">0x00000000004005b7</span> <span class="string">&lt;+57&gt;:</span>    <span class="string">addl</span>   <span class="string">$0x1</span>,<span class="number">-0x4</span><span class="string">(%rbp)</span>                </span><br><span class="line">   <span class="number">0x00000000004005bb</span> <span class="string">&lt;+61&gt;:</span>    <span class="string">cmpl</span>   <span class="string">$0x9</span>,<span class="number">-0x4</span><span class="string">(%rbp)</span>                </span><br><span class="line">   <span class="number">0x00000000004005bf</span> <span class="string">&lt;+65&gt;:</span>    <span class="string">jle</span>    <span class="number">0x400599</span> <span class="string">&lt;main+27&gt;</span>             </span><br><span class="line">                                                                      </span><br><span class="line"><span class="number">13</span>             <span class="string">printf(&quot;i</span> <span class="string">is</span> <span class="string">%d\n&quot;</span>, <span class="string">i);</span>                                </span><br><span class="line">   <span class="number">0x0000000000400599</span> <span class="string">&lt;+27&gt;:</span>    <span class="string">mov</span>    <span class="number">-0x4</span><span class="string">(%rbp)</span>,<span class="string">%eax</span>                </span><br><span class="line">   <span class="number">0x000000000040059c</span> <span class="string">&lt;+30&gt;:</span>    <span class="string">mov</span>    <span class="string">%eax</span>,<span class="string">%esi</span>                      </span><br><span class="line">   <span class="number">0x000000000040059e</span> <span class="string">&lt;+32&gt;:</span>    <span class="string">mov</span>    <span class="string">$0x400671</span>,<span class="string">%edi</span>                 </span><br><span class="line">   <span class="number">0x00000000004005a3</span> <span class="string">&lt;+37&gt;:</span>    <span class="string">mov</span>    <span class="string">$0x0</span>,<span class="string">%eax</span>                      </span><br><span class="line">   <span class="number">0x00000000004005a8</span> <span class="string">&lt;+42&gt;:</span>    <span class="string">callq</span>  <span class="number">0x400440</span> <span class="string">&lt;printf@plt&gt;</span>          </span><br><span class="line">                                                                      </span><br><span class="line"><span class="number">14</span>             <span class="string">test(i);</span>                                               </span><br><span class="line">   <span class="number">0x00000000004005ad</span> <span class="string">&lt;+47&gt;:</span>    <span class="string">mov</span>    <span class="number">-0x4</span><span class="string">(%rbp)</span>,<span class="string">%eax</span>                </span><br><span class="line">   <span class="number">0x00000000004005b0</span> <span class="string">&lt;+50&gt;:</span>    <span class="string">mov</span>    <span class="string">%eax</span>,<span class="string">%edi</span>                      </span><br><span class="line">   <span class="number">0x00000000004005b2</span> <span class="string">&lt;+52&gt;:</span>    <span class="string">callq</span>  <span class="number">0x400566</span> <span class="string">&lt;test&gt;</span>                </span><br><span class="line">                                                                      </span><br><span class="line"><span class="number">15</span>         &#125;                                                          </span><br><span class="line"><span class="number">16</span>          <span class="string">return</span> <span class="number">0</span><span class="string">;</span>                                                 </span><br><span class="line">   <span class="number">0x00000000004005c1</span> <span class="string">&lt;+67&gt;:</span>    <span class="string">mov</span>    <span class="string">$0x0</span>,<span class="string">%eax</span>                      </span><br><span class="line">                                                                      </span><br><span class="line"><span class="number">17</span>      &#125;                                                             </span><br><span class="line">   <span class="number">0x00000000004005c6</span> <span class="string">&lt;+72&gt;:</span>    <span class="string">leaveq</span>                                </span><br><span class="line">   <span class="number">0x00000000004005c7</span> <span class="string">&lt;+73&gt;:</span>    <span class="string">retq</span>                                  </span><br><span class="line">                                                                      </span><br><span class="line"><span class="string">End</span> <span class="string">of</span> <span class="string">assembler</span> <span class="string">dump.</span>                                                </span><br></pre></td></tr></table></figure>



<h6 id="s-按照pc指令执行顺序打印"><a href="#s-按照pc指令执行顺序打印" class="headerlink" title="/s 按照pc指令执行顺序打印"></a>/s 按照pc指令执行顺序打印</h6><p>会有明显的pc在堆栈中返回的逻辑</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(gdb)</span> <span class="string">disassemble</span> <span class="string">/s</span> <span class="string">main</span></span><br><span class="line"><span class="attr">Dump of assembler code for function main:</span></span><br><span class="line"><span class="attr">test.c:</span></span><br><span class="line"><span class="number">10</span>      <span class="string">int</span> <span class="string">main()</span> &#123;</span><br><span class="line">   <span class="number">0x000000000040057e</span> <span class="string">&lt;+0&gt;:</span>     <span class="string">push</span>   <span class="string">%rbp</span></span><br><span class="line">   <span class="number">0x000000000040057f</span> <span class="string">&lt;+1&gt;:</span>     <span class="string">mov</span>    <span class="string">%rsp</span>,<span class="string">%rbp</span></span><br><span class="line">   <span class="number">0x0000000000400582</span> <span class="string">&lt;+4&gt;:</span>     <span class="string">sub</span>    <span class="string">$0x10</span>,<span class="string">%rsp</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>         <span class="string">printf(&quot;hello</span> <span class="string">world\n&quot;);</span></span><br><span class="line">   <span class="number">0x0000000000400586</span> <span class="string">&lt;+8&gt;:</span>     <span class="string">mov</span>    <span class="string">$0x400665</span>,<span class="string">%edi</span></span><br><span class="line">   <span class="number">0x000000000040058b</span> <span class="string">&lt;+13&gt;:</span>    <span class="string">callq</span>  <span class="number">0x400430</span> <span class="string">&lt;puts@plt&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span>         <span class="string">for(int</span> <span class="string">i</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span> <span class="string">i</span> <span class="string">&lt;</span> <span class="number">10</span><span class="string">;</span> <span class="string">i++)</span>&#123;</span><br><span class="line">   <span class="number">0x0000000000400590</span> <span class="string">&lt;+18&gt;:</span>    <span class="string">movl</span>   <span class="string">$0x0</span>,<span class="number">-0x4</span><span class="string">(%rbp)</span></span><br><span class="line">   <span class="number">0x0000000000400597</span> <span class="string">&lt;+25&gt;:</span>    <span class="string">jmp</span>    <span class="number">0x4005bb</span> <span class="string">&lt;main+61&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>             <span class="string">printf(&quot;i</span> <span class="string">is</span> <span class="string">%d\n&quot;</span>, <span class="string">i);</span></span><br><span class="line">   <span class="number">0x0000000000400599</span> <span class="string">&lt;+27&gt;:</span>    <span class="string">mov</span>    <span class="number">-0x4</span><span class="string">(%rbp)</span>,<span class="string">%eax</span></span><br><span class="line">   <span class="number">0x000000000040059c</span> <span class="string">&lt;+30&gt;:</span>    <span class="string">mov</span>    <span class="string">%eax</span>,<span class="string">%esi</span></span><br><span class="line">   <span class="number">0x000000000040059e</span> <span class="string">&lt;+32&gt;:</span>    <span class="string">mov</span>    <span class="string">$0x400671</span>,<span class="string">%edi</span></span><br><span class="line">   <span class="number">0x00000000004005a3</span> <span class="string">&lt;+37&gt;:</span>    <span class="string">mov</span>    <span class="string">$0x0</span>,<span class="string">%eax</span></span><br><span class="line">   <span class="number">0x00000000004005a8</span> <span class="string">&lt;+42&gt;:</span>    <span class="string">callq</span>  <span class="number">0x400440</span> <span class="string">&lt;printf@plt&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="number">14</span>             <span class="string">test(i);</span></span><br><span class="line">   <span class="number">0x00000000004005ad</span> <span class="string">&lt;+47&gt;:</span>    <span class="string">mov</span>    <span class="number">-0x4</span><span class="string">(%rbp)</span>,<span class="string">%eax</span></span><br><span class="line">   <span class="number">0x00000000004005b0</span> <span class="string">&lt;+50&gt;:</span>    <span class="string">mov</span>    <span class="string">%eax</span>,<span class="string">%edi</span></span><br><span class="line">   <span class="number">0x00000000004005b2</span> <span class="string">&lt;+52&gt;:</span>    <span class="string">callq</span>  <span class="number">0x400566</span> <span class="string">&lt;test&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span>         <span class="string">for(int</span> <span class="string">i</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span> <span class="string">i</span> <span class="string">&lt;</span> <span class="number">10</span><span class="string">;</span> <span class="string">i++)</span>&#123;</span><br><span class="line">   <span class="number">0x00000000004005b7</span> <span class="string">&lt;+57&gt;:</span>    <span class="string">addl</span>   <span class="string">$0x1</span>,<span class="number">-0x4</span><span class="string">(%rbp)</span></span><br><span class="line">   <span class="number">0x00000000004005bb</span> <span class="string">&lt;+61&gt;:</span>    <span class="string">cmpl</span>   <span class="string">$0x9</span>,<span class="number">-0x4</span><span class="string">(%rbp)</span></span><br><span class="line">   <span class="number">0x00000000004005bf</span> <span class="string">&lt;+65&gt;:</span>    <span class="string">jle</span>    <span class="number">0x400599</span> <span class="string">&lt;main+27&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>         &#125;</span><br><span class="line"><span class="number">16</span>          <span class="string">return</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">   <span class="number">0x00000000004005c1</span> <span class="string">&lt;+67&gt;:</span>    <span class="string">mov</span>    <span class="string">$0x0</span>,<span class="string">%eax</span></span><br><span class="line"></span><br><span class="line"><span class="number">17</span>      &#125;</span><br><span class="line">   <span class="number">0x00000000004005c6</span> <span class="string">&lt;+72&gt;:</span>    <span class="string">leaveq</span></span><br><span class="line">   <span class="number">0x00000000004005c7</span> <span class="string">&lt;+73&gt;:</span>    <span class="string">retq</span></span><br><span class="line"><span class="string">End</span> <span class="string">of</span> <span class="string">assembler</span> <span class="string">dump.</span></span><br></pre></td></tr></table></figure>

<h6 id="r-额外打印16进制的原始指令"><a href="#r-额外打印16进制的原始指令" class="headerlink" title="/r 额外打印16进制的原始指令"></a>/r 额外打印16进制的原始指令</h6><h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h5><p>可以使用x指令或者display/i命令打印想要的汇编</p>
<h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><p>展示gdb命令的信息，可以打印class 相关的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) help class&lt;breakpoints|status|stack&gt;</span><br></pre></td></tr></table></figure>

<p>打印全部</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) help</span><br></pre></td></tr></table></figure>

<h4 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h4><p>退出gdb</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
        <tag>linux</tag>
        <tag>gdb</tag>
        <tag>kernel-tool</tag>
        <tag>程序调试</tag>
      </tags>
  </entry>
  <entry>
    <title>程序分析利器perf</title>
    <url>/archives/6.html</url>
    <content><![CDATA[<h1 id="程序分析利器perf"><a href="#程序分析利器perf" class="headerlink" title="程序分析利器perf"></a>程序分析利器perf</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>全称为performance counter，是一个linux内核实现的框架来进行性能分析，覆盖了硬件CPU/PMU和（软件计数器，监测点）之类的特性。</p>
<p>本文重点介绍perf的使用和实践，不对原理性知识进行讲解</p>
<a id="more"></a>
<hr>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><h4 id="cpu流水线"><a href="#cpu流水线" class="headerlink" title="cpu流水线"></a>cpu流水线</h4><h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><h4 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h4><p>时钟周期，假设一台处理器的处理频率为2GHZ，那么时钟周期为2GHZ，一次tick的时间间隔为1/2ns</p>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><h4 id="clock-tick"><a href="#clock-tick" class="headerlink" title="clock tick"></a>clock tick</h4><p>时钟滴答，在经过多个时钟周期后，机器内部会产生一次时钟滴答，即一次时钟中断，用来对任务进行管理。</p>
<h4 id="tracepoints"><a href="#tracepoints" class="headerlink" title="tracepoints"></a>tracepoints</h4><p>追踪点，由ftrace框架实现，一些函数在内核中被特殊标记，在运行到这些函数时进行函数记录并记录在内核环形缓冲区，消耗时间很小，并可以通过文件节点打印出来，详见<code>/sys/kernel/debug/tracing</code></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>perf通过进行事件采样来对性能进行分析，事件根据类型分为几类：</p>
<ol>
<li>Kernel PMU event  </li>
<li>Hardware event   比如 branch-miss</li>
<li>Hardware cache event   dTLB和iTLB相关，即数据转换后备缓存区和指令转换后备缓冲区</li>
<li>software event  比如 cpu-migrations     </li>
<li>tracepoints</li>
</ol>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><ol>
<li>IPC：每个时钟周期内的指令数</li>
<li>PMU：performance monitoring units</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install perf-tools-unstable</span><br></pre></td></tr></table></figure>

<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>常用的参数如下：</p>
<ol>
<li>-e 指定事件</li>
<li>-p 指定pid</li>
</ol>
<h4 id="perf-help"><a href="#perf-help" class="headerlink" title="perf help"></a>perf help</h4><p>通过<code>perf --help</code>打印全部的命令，perf  的全部选项命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bench           General framework for benchmark suites   基准测试</span><br><span class="line">test            Runs sanity tests.  检查系统是否支持perf的全部功能</span><br><span class="line"></span><br><span class="line">list            List all symbolic event types</span><br><span class="line">top             System profiling tool.    实时热点事件分析</span><br><span class="line">stat            Run a command and gather performance counter statistics</span><br><span class="line">record          Run a command and record its profile into perf.data</span><br><span class="line">report          Read perf.data (created by perf record) and display the profile</span><br><span class="line">probe           Define new dynamic tracepoints   动态追踪点</span><br><span class="line"></span><br><span class="line">trace           strace inspired tool            同strace功能</span><br><span class="line">kmem            Tool to trace/measure kernel memory properties  kernel内存       </span><br><span class="line">lock            Analyze lock events          </span><br><span class="line">mem             Profile memory accesses</span><br><span class="line">sched           Tool to trace/measure scheduler properties (latencies)     调度子系统</span><br><span class="line">kvm             Tool to trace/measure kvm guest os</span><br><span class="line"></span><br><span class="line">timechart       Tool to visualize total system behavior during a workload</span><br><span class="line">evlist          List the event names in a perf.data file  列出record文件的所有事件</span><br></pre></td></tr></table></figure>

<h4 id="perf-bench"><a href="#perf-bench" class="headerlink" title="perf bench"></a>perf bench</h4><p>系统基准测试，通过对4个子系统的运行来评估系统性能</p>
<h5 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h5><p>包括进程调度和IPC进程通信（socket和pipe）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ perf bench sched all                                                 # Running sched/messaging benchmark...      &gt;&gt;20个进程对通信</span><br><span class="line"><span class="meta">#</span><span class="bash"> 20 sender and receiver processes per group</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10 groups == 400 processes run</span></span><br><span class="line"></span><br><span class="line">     Total time: 0.031 [sec]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Running <span class="built_in">sched</span>/pipe benchmark...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Executed 1000000 pipe operations between two processes  </span></span><br><span class="line"></span><br><span class="line">     Total time: 6.182 [sec]</span><br><span class="line"></span><br><span class="line">       6.182868 usecs/op</span><br><span class="line">         161737 ops/sec</span><br></pre></td></tr></table></figure>

<h5 id="mem"><a href="#mem" class="headerlink" title="mem"></a>mem</h5><p>内存copy性能评估，包括两种方式memcpy和memset，结果显示为吞吐率</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ perf bench mem all                                                             # Running mem/memcpy benchmark...</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">function</span> <span class="string">&#x27;default&#x27;</span> (Default memcpy() provided by glibc)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copying 1MB bytes ...</span></span><br><span class="line"></span><br><span class="line">      25.699013 GB/sec</span><br></pre></td></tr></table></figure>

<h5 id="futex"><a href="#futex" class="headerlink" title="futex"></a>futex</h5><p>锁压力评估</p>
<h4 id="perf-list"><a href="#perf-list" class="headerlink" title="perf  list"></a>perf  list</h4><p>打印系统支持的事件 <code>sudo perf list</code>, 之后在 perf 的其他命令中可以-e 指定事件</p>
<p>这些事件中hw，PMU， cache属于硬件， sw属于内核计数器，Tracepoints event属于ftrace捕捉的内核追踪点</p>
<h5 id="软件evnet"><a href="#软件evnet" class="headerlink" title="软件evnet"></a>软件evnet</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alignment-faults                                   [Software event]</span><br><span class="line">bpf-output                                         [Software event]</span><br><span class="line">context-switches OR cs                             [Software event]</span><br><span class="line">cpu-clock                                          [Software event]</span><br><span class="line">cpu-migrations OR migrations                       [Software event]</span><br><span class="line">dummy                                              [Software event]</span><br><span class="line">emulation-faults                                   [Software event]</span><br><span class="line">major-faults                                       [Software event]</span><br><span class="line">minor-faults                                       [Software event]</span><br><span class="line">page-faults OR faults                              [Software event]</span><br><span class="line">task-clock                                         [Software event]</span><br></pre></td></tr></table></figure>

<h5 id="硬件event"><a href="#硬件event" class="headerlink" title="硬件event"></a>硬件event</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">branch-instructions OR branches                    [Hardware event]</span><br><span class="line">branch-misses                                      [Hardware event]</span><br><span class="line">bus-cycles                                         [Hardware event]</span><br><span class="line">cache-misses                                       [Hardware event]</span><br><span class="line">cache-references                                   [Hardware event]</span><br><span class="line">cpu-cycles OR cycles                               [Hardware event]</span><br><span class="line">instructions                                       [Hardware event]</span><br><span class="line">ref-cycles                                         [Hardware event]</span><br></pre></td></tr></table></figure>

<h5 id="cache-evnet"><a href="#cache-evnet" class="headerlink" title="cache evnet"></a>cache evnet</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">L1-dcache-load-misses                              [Hardware cache event]</span><br><span class="line">L1-dcache-loads                                    [Hardware cache event]</span><br><span class="line">L1-dcache-stores                                   [Hardware cache event]</span><br><span class="line">L1-icache-load-misses                              [Hardware cache event]</span><br><span class="line">LLC-load-misses                                    [Hardware cache event]</span><br><span class="line">LLC-loads                                          [Hardware cache event]</span><br><span class="line">LLC-store-misses                                   [Hardware cache event]</span><br><span class="line">LLC-stores                                         [Hardware cache event]</span><br><span class="line">branch-load-misses                                 [Hardware cache event]</span><br><span class="line">branch-loads                                       [Hardware cache event]</span><br><span class="line">dTLB-load-misses                                   [Hardware cache event]</span><br><span class="line">dTLB-loads                                         [Hardware cache event]</span><br><span class="line">dTLB-store-misses                                  [Hardware cache event]</span><br><span class="line">dTLB-stores                                        [Hardware cache event]</span><br><span class="line">iTLB-load-misses                                   [Hardware cache event]</span><br><span class="line">iTLB-loads                                         [Hardware cache event]</span><br><span class="line">node-load-misses                                   [Hardware cache event]</span><br><span class="line">node-loads                                         [Hardware cache event]</span><br><span class="line">node-store-misses                                  [Hardware cache event]</span><br><span class="line">node-stores                                        [Hardware cache event]</span><br></pre></td></tr></table></figure>

<h5 id="PMU-event"><a href="#PMU-event" class="headerlink" title="PMU event"></a>PMU event</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">branch-instructions OR cpu/branch-instructions/    [Kernel PMU event]</span><br><span class="line">branch-misses OR cpu/branch-misses/                [Kernel PMU event]</span><br><span class="line">bus-cycles OR cpu/bus-cycles/                      [Kernel PMU event]</span><br><span class="line">cache-misses OR cpu/cache-misses/                  [Kernel PMU event]</span><br><span class="line">cache-references OR cpu/cache-references/          [Kernel PMU event]</span><br><span class="line">cpu-cycles OR cpu/cpu-cycles/                      [Kernel PMU event]</span><br><span class="line">cycles-ct OR cpu/cycles-ct/                        [Kernel PMU event]</span><br><span class="line">cycles-t OR cpu/cycles-t/                          [Kernel PMU event]</span><br><span class="line">el-abort OR cpu/el-abort/                          [Kernel PMU event]</span><br><span class="line">el-capacity OR cpu/el-capacity/                    [Kernel PMU event]</span><br><span class="line">el-commit OR cpu/el-commit/                        [Kernel PMU event]</span><br><span class="line">el-conflict OR cpu/el-conflict/                    [Kernel PMU event]</span><br><span class="line">el-start OR cpu/el-start/                          [Kernel PMU event]</span><br><span class="line">instructions OR cpu/instructions/                  [Kernel PMU event]</span><br><span class="line">intel_bts//                                        [Kernel PMU event]</span><br><span class="line">intel_cqm/llc_occupancy/                           [Kernel PMU event]</span><br><span class="line">intel_cqm/local_bytes/                             [Kernel PMU event]</span><br><span class="line">intel_cqm/total_bytes/                             [Kernel PMU event]</span><br><span class="line">intel_pt//                                         [Kernel PMU event]</span><br><span class="line">mem-loads OR cpu/mem-loads/                        [Kernel PMU event]</span><br><span class="line">mem-stores OR cpu/mem-stores/                      [Kernel PMU event]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="tracepoint-evnet"><a href="#tracepoint-evnet" class="headerlink" title="tracepoint evnet"></a>tracepoint evnet</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alarmtimer:alarmtimer_cancel                       [Tracepoint event]</span><br><span class="line">alarmtimer:alarmtimer_fired                        [Tracepoint event]</span><br><span class="line">alarmtimer:alarmtimer_start                        [Tracepoint event]</span><br><span class="line">alarmtimer:alarmtimer_suspend                      [Tracepoint event]</span><br><span class="line">block:block_bio_backmerge                          [Tracepoint event]</span><br></pre></td></tr></table></figure>

<h4 id="perf-top"><a href="#perf-top" class="headerlink" title="perf top"></a>perf top</h4><h5 id="打印说明"><a href="#打印说明" class="headerlink" title="打印说明"></a>打印说明</h5><p>可以实时生成和显示系统中事件计数的函数排名，新版内核可以查看函数对应的汇编指令</p>
<ol>
<li><p>第一列 Overhead指事件比例</p>
</li>
<li><p>第二列 DOS (Dynamic Shared Object) 可以为kernel，应用程序perf，动态链接库libc-2.23.so，模块</p>
</li>
<li><p>第三列 DOS类型  [k]表示对象属于内核或者模块， [.]表示对象为二进制程序，为应用程序或者动态链接库</p>
</li>
<li><p>第四列 符号名，没有symbols的显示为地址</p>
</li>
</ol>
<p>ubuntu服务器上执行如下，默认为cycles，即cpu周期占用比例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Samples: 2K of event &#x27;cycles&#x27;, Event count (approx.): 507514780</span><br><span class="line">Overhead  Shared Object            Symbol</span><br><span class="line">   4.11%  [kernel]                 [k] delay_tsc</span><br><span class="line">   2.78%  [kernel]                 [k] kstat_irqs</span><br><span class="line">   2.51%  perf                     [.] 0x00000000000a4784</span><br><span class="line">   2.32%  libc-2.23.so             [.] _int_malloc</span><br><span class="line">   2.03%  [kernel]                 [k] _find_next_bit.part.0</span><br><span class="line">   1.84%  [kernel]                 [k] ixgbe_read_reg</span><br><span class="line">   1.52%  [kernel]                 [k] vsnprintf</span><br><span class="line">   1.31%  [kernel]                 [k] kallsyms_expand_symbol.constprop.1</span><br><span class="line">   1.31%  [kernel]                 [k] update_blocked_averages</span><br><span class="line">   1.28%  [kernel]                 [k] format_decode</span><br><span class="line">   1.25%  perf                     [.] 0x0000000000099837</span><br></pre></td></tr></table></figure>

<p>手机上执行如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> PerfTop:     418 irqs/sec  kernel:72.2%  exact:  0.0% [4000Hz cycles:ppp],  (all, 8 CPUs)   </span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  14.42%  [kernel]          [k] 0xffffff8008bcb854         &gt;&gt;地址                                  </span><br><span class="line">   9.80%  [kernel]          [k] 0xffffff8008fc6acc                                           </span><br><span class="line">   9.08%  [kernel]          [k] 0xffffff8008fc6a68                                           </span><br><span class="line">   1.90%  [kernel]          [k] 0xffffff80080820a8                                           </span><br><span class="line">   0.94%  [kernel]          [k] 0xffffff8008301c00                                           </span><br><span class="line">   0.84%  perf              [.] 0x0000000000088250                                           </span><br><span class="line">   0.75%  [kernel]          [k] 0xffffff8008bf9928                                           </span><br><span class="line">   0.63%  [kernel]          [k] 0xffffff8008fa5550                                           </span><br><span class="line">   0.55%  perf              [.] 0x00000000000d87b8                                           </span><br></pre></td></tr></table></figure>

<p>因为权限设置，无法获取symbols，因为无法将地址转化为函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Failed to open [kernel.kallsyms], continuing without symbols</span><br><span class="line">Warning:</span><br><span class="line">Kernel address maps (/proc/&#123;kallsyms,modules&#125;) are restricted.</span><br><span class="line"></span><br><span class="line">Check /proc/sys/kernel/kptr_restrict.</span><br><span class="line"></span><br><span class="line">Kernel samples will not be resolved.</span><br></pre></td></tr></table></figure>

<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-e</td>
<td align="left">指定事件</td>
</tr>
<tr>
<td align="center">-d</td>
<td align="left">指定屏幕刷新间隔</td>
</tr>
<tr>
<td align="center">-K</td>
<td align="left">不显示内核或者模块对象</td>
</tr>
<tr>
<td align="center">-U</td>
<td align="left">不显示上层应用或者动态链接库</td>
</tr>
<tr>
<td align="center">-p</td>
<td align="left">对指定的进程和其创建的线程采样</td>
</tr>
</tbody></table>
<h4 id="perf-stat"><a href="#perf-stat" class="headerlink" title="perf stat"></a>perf stat</h4><p>对一个命令或者程序进行事件统计</p>
<h5 id="打印说明-1"><a href="#打印说明-1" class="headerlink" title="打印说明"></a>打印说明</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf stat ./test-run</span><br><span class="line">.....</span><br><span class="line"> Performance counter stats for &#x27;./test-run&#x27;:</span><br><span class="line"></span><br><span class="line">          1.206903      task-clock (msec)         #    0.000 CPUs utilized   &gt;&gt;CPU利用率</span><br><span class="line">                 4      context-switches          #    0.003 M/sec           &gt;&gt;上下文切换</span><br><span class="line">                 1      cpu-migrations            #    0.829 K/sec           &gt;&gt;CPU调度迁移</span><br><span class="line">               119      page-faults               #    0.099 M/sec           &gt;&gt;缺页异常</span><br><span class="line">         2,804,835      cycles                    #    2.324 GHz             &gt;&gt;处理器周期数</span><br><span class="line">         1,627,455      instructions              #    0.58  insn per cycle   &gt;&gt;指令数</span><br><span class="line">           338,915      branches                  #  280.814 M/sec            &gt;&gt;分支指令数</span><br><span class="line">            14,436      branch-misses             #    4.26% of all branches   &gt;&gt;预测错误的分支指令数</span><br><span class="line"></span><br><span class="line">      12.012281176 seconds time elapsed</span><br></pre></td></tr></table></figure>
<h5 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h5><p>-e和-p为通用选项</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>重复指定命令n次，结果显示标准偏差和期望的比值</td>
</tr>
<tr>
<td>-d</td>
<td>打印更多信息，包括L1和LLC（L3，三级缓存，数据共享）数据缓存</td>
</tr>
<tr>
<td>-d -d</td>
<td>打印更多信息， 包括dTLB和iTLB</td>
</tr>
</tbody></table>
<h4 id="perf-record"><a href="#perf-record" class="headerlink" title="perf record"></a>perf record</h4><p>运行命令并将其事件记录在per.data中，之后通过perf report来展示。一般需要加上-g参数来进行函数调用显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:kernel_tool_test_C/ $ sudo perf record -g ls </span><br><span class="line"></span><br><span class="line">[11:39:23] Makefile  perf.data  perf.data.old  README.md  src  test-run</span><br><span class="line">[ perf record: Woken up 1 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.013 MB perf.data (1 samples) ]</span><br></pre></td></tr></table></figure>

<h4 id="perf-report"><a href="#perf-report" class="headerlink" title="perf report"></a>perf report</h4><p>读取per.data文件并给出分析显示，可以看出函数的调用逻辑顺序</p>
<h4 id="perf-probe"><a href="#perf-probe" class="headerlink" title="perf probe"></a>perf probe</h4><p>perf probe可针对内核和ELF进行动态 tracepoint的追踪，更加详细见 <code>man perf-probe</code></p>
<h5 id="增加动态追踪点"><a href="#增加动态追踪点" class="headerlink" title="增加动态追踪点"></a>增加动态追踪点</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf probe -x test-run test_blk                                           Added new event:</span><br><span class="line">  probe_test:test_blk  (on test_blk in /work/chejian/test/kernel_tool_test_C/test-run)</span><br></pre></td></tr></table></figure>

<h5 id="抓取动态追踪点"><a href="#抓取动态追踪点" class="headerlink" title="抓取动态追踪点"></a>抓取动态追踪点</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo perf record -e probe_test:test_blk -gaR ./test-run</span><br></pre></td></tr></table></figure>

<h5 id="删除动态追踪点"><a href="#删除动态追踪点" class="headerlink" title="删除动态追踪点"></a>删除动态追踪点</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf probe -d test_blk                                                     Removed event: probe_test:test_blk</span><br></pre></td></tr></table></figure>

<h5 id="列出动态追踪点"><a href="#列出动态追踪点" class="headerlink" title="列出动态追踪点"></a>列出动态追踪点</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf probe -l                                                             </span><br><span class="line">  probe:schedule       (on schedule)    &gt;&gt;内核</span><br><span class="line">  probe_test:test_blk  (on test_blk@src/modules/strace/strace.c in /work/chejian/test/kernel_tool_test_C/test-run)   &gt;&gt;ELF程序</span><br></pre></td></tr></table></figure>

<h4 id="perf-trace"><a href="#perf-trace" class="headerlink" title="perf trace"></a>perf trace</h4><p>同strace，包含抓取syscall的功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo perf trace -o output.txt  ./test-run</span><br><span class="line"></span><br><span class="line"> 11993.175 ( 0.003 ms): test-run/267526 rt_sigaction(sig: CHLD, act: 0x7ffc7d5ad570, oact: 0x7ffc7d5ad610, sigsetsize: 8) = 0</span><br><span class="line"> 11993.180 ( 0.012 ms): test-run/267526 open(filename: 0x6031c0, flags: RDWR                                  ) = 4</span><br><span class="line"> 11993.195 ( 0.005 ms): test-run/267526 stat(filename: 0x6031c0, statbuf: 0x7ffc7d5ad828                      ) = 0</span><br><span class="line"> </span><br><span class="line"> 11993.203 ( 0.023 ms): test-run/267526 mmap(len: 32, prot: READ|WRITE, flags: SHARED, fd: 4                  ) = 0x7fdbf0da0000   &gt;&gt;共享内存映射地址， fd为 4</span><br><span class="line"></span><br><span class="line"> 11995.233 ( 0.002 ms): test-run/267526 close(fd: 4                                                           ) = 0</span><br><span class="line"> 11995.239 ( 0.009 ms): test-run/267526 munmap(addr: 0x7fdbf0da0000, len: 32                                  ) = 0</span><br></pre></td></tr></table></figure>

<p><code>-s</code>和<code>-S</code>选项和strace 下的 <code>-c -w</code>功能类似，都是对调用次数和消耗时间的统计</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> Summary of events:</span><br><span class="line"></span><br><span class="line"> test-run (269586), 8 events, 3.0%</span><br><span class="line"></span><br><span class="line">   syscall            calls    total       min       avg       max      stddev</span><br><span class="line">                               (msec)    (msec)    (msec)    (msec)        (%)</span><br><span class="line"></span><br><span class="line">--------------- -------- --------- --------- --------- ---------     ------</span><br><span class="line"></span><br><span class="line">   nanosleep              1  4995.994  4995.994  4995.994  4995.994      0.00%</span><br><span class="line">   write                  2     0.020     0.008     0.010     0.012     18.33%</span><br><span class="line">   clone                  1     0.000     0.000     0.000     0.000      0.00%</span><br></pre></td></tr></table></figure>

<p>但是发现write时的字符串参数没有具体打印是啥，只是显示了一个地址，因此strace的write参数可以更好的确定源代码位置</p>
<h4 id="perf-kmem"><a href="#perf-kmem" class="headerlink" title="perf kmem"></a>perf kmem</h4><p>内核内存的分配统计，一般为slab和page存取两类，操作为record和stat搭配使用</p>
<h5 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h5><p>slab的解析分为两部分，一部分为<code>--caller</code>导致的Callsite部分，一部分为–alloc导致的Alloc Ptr地址打印部分，具体的打印解释如下：</p>
<ol>
<li>Callsite，表示谁调用了kmalloc来进行slab申请</li>
<li>Total_alloc/Per 表示调用者一共分配的内存和每次平均分配的内存</li>
<li>Total_req/Per 表示调用者一共申请的内存和每次平均申请的内存</li>
<li>Hit 表示调用者调用kmalloc的次数</li>
<li>Ping-pong 多cpu架构kfree和kmalloc的共享内存对应的cpu不同，这看做是一次ping-pong，理想是越小越好。</li>
<li>Frag 碎片率，为（实际分配-申请）/实际分配</li>
<li>Alloc Ptr 为申请的地址</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf kmem record --slab ls                                                 </span><br><span class="line"></span><br><span class="line">Makefile  output.svg  output.txt  output.txt.old  perf.data  perf.data.old  README.md  src  test-run</span><br><span class="line">[ perf record: Woken up 0 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 2.225 MB perf.data (12859 samples) ]</span><br><span class="line"></span><br><span class="line">kernel_tool_test_C/ $ sudo perf kmem --alloc --caller --slab stat</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"> Callsite                           | Total_alloc/Per | Total_req/Per   | Hit      | Ping-pong | Frag</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"> proc_reg_open+32                   |        64/64    |        40/40    |        1 |         0 | 37.500%</span><br><span class="line"> apparmor_file_alloc_security+5c    |       608/32    |       456/24    |       19 |         0 | 25.000%</span><br><span class="line"> ext4_readdir+91e                   |        64/64    |        48/48    |        1 |         0 | 25.000%</span><br><span class="line"> ext4_htree_store_dirent+3e         |       800/66    |       698/58    |       12 |         0 | 12.750%</span><br><span class="line"> ....</span><br><span class="line"> </span><br><span class="line"> ---------------------------------------------------------------------------------------------------------</span><br><span class="line"> Alloc Ptr                          | Total_alloc/Per | Total_req/Per   | Hit      | Ping-pong | Frag</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"> 0xffff995a4bb4c000                 |      1024/1024  |       640/640   |        1 |         0 | 37.500%</span><br><span class="line"> 0xffff995b83910f80                 |       128/64    |        88/44    |        2 |         0 | 31.250%</span><br><span class="line"> 0xffff995c561c3ec0                 |        96/32    |        72/24    |        3 |         0 | 25.000%</span><br></pre></td></tr></table></figure>

<h5 id="page-to-do"><a href="#page-to-do" class="headerlink" title="page(to do)"></a>page(to do)</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf kmem record --page --live ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> GFP flags</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ---------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 002152c0: I|F|NWR|NR|C|NMA|NT: __GFP_IO|__GFP_FS|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC|__GFP_NOTRACK</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 01000200:              NW|NWR: GFP_NOWAIT|__GFP_NOWARN</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 014000c0:                   K: GFP_KERNEL</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 014200ca:                 HUM: GFP_HIGHUSER_MOVABLE</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 014280ca:               HUM|Z: GFP_HIGHUSER_MOVABLE|__GFP_ZERO</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 015080c0:               KAC|Z: GFP_KERNEL_ACCOUNT|__GFP_ZERO</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 015200c2:               HU|AC: GFP_HIGHUSER|__GFP_ACCOUNT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 017080c0:            KAC|Z|NT: GFP_KERNEL_ACCOUNT|__GFP_ZERO|__GFP_NOTRACK</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 01c200ca:              HUM|WR: GFP_HIGHUSER_MOVABLE|__GFP_WRITE</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"> Total alloc (KB) | Hits      | Order | Mig.type | GFP flags           | Callsite</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">              120 |        30 |     0 | UNMOVABL | KAC|Z|NT            | pte_alloc_one</span><br><span class="line">               84 |        21 |     0 |  RECLAIM | HUM|Z               | handle_mm_fault</span><br><span class="line">               40 |        10 |     0 |  RECLAIM | HUM                 | wp_page_copy</span><br><span class="line">               32 |         8 |     0 |  RECLAIM | HUM                 | handle_mm_fault</span><br><span class="line">               20 |         5 |     0 | UNMOVABL | NW|NWR              | tlb_next_batch.isra.42</span><br><span class="line">               20 |         5 |     0 | UNMOVABL | KAC|Z               | __pmd_alloc</span><br><span class="line">               12 |         3 |     0 | UNMOVABL | K                   | __pollwait</span><br><span class="line">                8 |         2 |     0 | UNMOVABL | KAC|Z               | __pud_alloc</span><br><span class="line">                8 |         1 |     1 | UNMOVABL | I|F|NWR|NR|C|NMA|NT | new_slab</span><br><span class="line">                4 |         1 |     0 | UNMOVABL | KAC|Z|NT            | pgd_alloc</span><br><span class="line">                4 |         1 |     0 |  RECLAIM | HUM|WR              | __page_cache_alloc</span><br><span class="line">                4 |         1 |     0 |  RECLAIM | HUM|Z               | wp_page_copy</span><br><span class="line">                4 |         1 |     0 | UNMOVABL | HU|AC               | pipe_write</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"> PFN              | Total alloc (KB) | Hits      | Order | Mig.type | GFP flags           | Callsite</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">         23073150 |                8 |         2 |     0 | UNMOVABL | KAC|Z               | __pmd_alloc</span><br><span class="line">         28346272 |                8 |         1 |     1 | UNMOVABL | I|F|NWR|NR|C|NMA|NT | new_slab</span><br><span class="line">         17327464 |                4 |         1 |     0 | UNMOVABL | KAC|Z|NT            | pte_alloc_one</span><br></pre></td></tr></table></figure>

<h4 id="perf-lock（todo）"><a href="#perf-lock（todo）" class="headerlink" title="perf lock（todo）"></a>perf lock（todo）</h4><p>内核锁事件分析</p>
<p>使用：<code>perf lock &#123;record|report|script|info&#125;</code></p>
<p>条件： 内核需要使能CONFIG_LOCKDEP和CONFIG_LOCK_STAT</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo perf lock record ls                                                                             tracepoint lock:lock_acquire is not enabled. Are CONFIG_LOCKDEP and CONFIG_LOCK_STAT enabled?</span><br></pre></td></tr></table></figure>

<h4 id="perf-mem"><a href="#perf-mem" class="headerlink" title="perf mem"></a>perf mem</h4><p>内存访问分析，内存操作分为两类，为load和store，对应取和存，对应的事件为<code>cpu/mem-loads,ldlat=30/P</code>和<code>cpu/mem-stores/P</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf mem record ./test-run</span><br><span class="line"></span><br><span class="line">Samples: 22  of event &#x27;cpu/mem-loads,ldlat=30/P&#x27;, Event count (approx.): 4449</span><br><span class="line">Overhead       Samples  Local Weight  Memory access             Symbol                          Shared Object      Data Symbol                      Data Object        Snoop         TLB access              Locked</span><br><span class="line">  12.00%             1  534           LFB hit                   [k] filemap_map_pages           [kernel.kallsyms]  [k] 0xffffd75181feaaa0           [kernel.kallsyms]  None          L1 or L2 hit            No</span><br><span class="line">  11.80%             1  525           LFB hit                   [k] filemap_map_pages           [kernel.kallsyms]  [k] 0xffffd751809b0888           [kernel.kallsyms]  None          L1 or L2 hit            No</span><br><span class="line">   9.78%             1  435           L3 miss                   [k] tty_write                   [kernel.kallsyms]  [k] 0xffff995caac199c0           [kernel.kallsyms]  N/A           L1 or L2 hit            No</span><br><span class="line">   9.44%             1  420           LFB hit                   [k] unmap_page_range            [kernel.kallsyms]  [k] 0xffffd7518094fca0           [kernel.kallsyms]  None          L1 or L2 hit            No</span><br><span class="line">   9.42%             1  419           L1 hit                    [k] page_add_file_rmap          [kernel.kallsyms]  [k] 0xffffd75181fe0d58           [kernel.kallsyms]  None          L1 or L2 hit            Yes</span><br></pre></td></tr></table></figure>

<h4 id="perf-sched"><a href="#perf-sched" class="headerlink" title="perf sched"></a>perf sched</h4><p>调度器分析</p>
<p>使用：<code>perf sched &#123;record|latency|map|replay|script&#125;</code></p>
<h5 id="抓取调度相关事件"><a href="#抓取调度相关事件" class="headerlink" title="抓取调度相关事件"></a>抓取调度相关事件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf sched record ./test-run</span><br></pre></td></tr></table></figure>

<h5 id="查看调度延迟"><a href="#查看调度延迟" class="headerlink" title="查看调度延迟"></a>查看调度延迟</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $sudo perf sched latency -s runtime</span><br><span class="line"> ----------------------------------------------------------------------------------------------------</span><br><span class="line">  Task  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at       |</span><br><span class="line"> ----------------------------------------------------------------------------------------------------</span><br><span class="line"> test-run:(3)          |      1.436 ms |        7 | avg:    0.020 ms | max:    0.068 ms | max at: 9477856.501406 s</span><br></pre></td></tr></table></figure>

<p>各列的含义如下：</p>
<ol>
<li>Task 进程名</li>
<li>Runtime ms 运行时间</li>
<li>Switches 进程切换次数</li>
<li>Average delay 调度平均延迟</li>
<li>Maximum delay ms 调度最大延迟，是影响较大的因素</li>
<li>Maximum delay at  调度延迟发生时间点</li>
</ol>
<h5 id="打印抓取的调度事件"><a href="#打印抓取的调度事件" class="headerlink" title="打印抓取的调度事件"></a>打印抓取的调度事件</h5><p>各列的含义为：进程名， 进程号， 所在的cpu，时间戳， 调度事件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf sched script</span><br><span class="line">  swapper     0 [005] 9477854.475353:       sched:sched_switch: prev_comm=swapper/5 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=rcu_sched next_pid=8 next_prio=120</span><br><span class="line">  rcu_sched     8 [005] 9477854.475357:       sched:sched_switch: prev_comm=rcu_sched prev_pid=8 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/5 next_pid=0 next_prio=120</span><br></pre></td></tr></table></figure>
<h5 id="复现调度场景"><a href="#复现调度场景" class="headerlink" title="复现调度场景"></a>复现调度场景</h5><p>重放record文件中的调度场景，但是当进程有sleep函数时重现就会卡主</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf sched replay    &gt;&gt;复现调度打印卡住，暂无发现实践意义</span><br></pre></td></tr></table></figure>

<h5 id="调度迁移（上下文切换）"><a href="#调度迁移（上下文切换）" class="headerlink" title="调度迁移（上下文切换）"></a>调度迁移（上下文切换）</h5><p><code>perf sched map</code>可以打印任务在cpu之间直观的调度状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf sched map -f</span><br><span class="line">   D0  A0  H0  G0 *R0  L0  .</span><br><span class="line">   D0  A0  H0  G0  R0  L0  .  *S0</span><br><span class="line">   D0  A0  H0  G0  R0  L0 *T0  S0</span><br><span class="line">   D0  A0  H0  G0  R0  L0  T0 *.4</span><br><span class="line">   D0  A0  H0 *P0  R0  L0  T0  .</span><br><span class="line">   D0  A0  H0  P0  R0  L0  T0 *S0</span><br><span class="line">   D0  A0  H0  P0  R0  L0 *.   S0</span><br><span class="line">   D0 *U0  H0  P0  R0  L0  .   S0</span><br><span class="line">  *Q0  U0  H0  P0  R0  L0  .   S0</span><br><span class="line">   Q0  U0  H0 *G0  R0  L0  .   S0</span><br><span class="line">   Q0  U0 *.   G0  R0  L0  .   S0</span><br><span class="line">   Q0  U0  .   G0  R0 *V0  .   S0</span><br><span class="line">   Q0 *A0  .   G0  R0  V0  .   S0</span><br><span class="line">   Q0  A0  .   G0  R0  V0 *W0  S0</span><br></pre></td></tr></table></figure>

<p>*标示调度事件发生所在的cpu，.表示CPU处于IDEL状态    ，一个正常的map可以显示一个任务的调度会尽力给到闲置的cpu，而不是忙碌的cpu</p>
<h4 id="perf-evlist"><a href="#perf-evlist" class="headerlink" title="perf evlist"></a>perf evlist</h4><p>显示record文件中的events</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf evlist                                                               sched:sched_switch</span><br><span class="line">sched:sched_stat_wait</span><br><span class="line">sched:sched_stat_sleep</span><br><span class="line">sched:sched_stat_iowait</span><br><span class="line">sched:sched_stat_runtime</span><br><span class="line">sched:sched_process_fork</span><br><span class="line">sched:sched_wakeup</span><br><span class="line">sched:sched_wakeup_new</span><br><span class="line">sched:sched_migrate_task</span><br></pre></td></tr></table></figure>

<h4 id="perf-timechart"><a href="#perf-timechart" class="headerlink" title="perf timechart"></a>perf timechart</h4><p>一个通过抓取事件转化为直观的视图svg文件来显示调度器，CPU， IO等事件的工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel_tool_test_C/ $ sudo perf timechart record -I -T ./test-run   </span><br><span class="line">kernel_tool_test_C/ $ sudo perf timechart -p test-run                                                 Written 12.0 seconds of trace to output.svg.   &gt;&gt;需要将文件拖入到浏览器</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
        <tag>linux</tag>
        <tag>kernel-tool</tag>
        <tag>程序调试</tag>
        <tag>perf</tag>
      </tags>
  </entry>
  <entry>
    <title>程序分析利器strace</title>
    <url>/archives/5.html</url>
    <content><![CDATA[<h1 id="程序分析利器strace"><a href="#程序分析利器strace" class="headerlink" title="程序分析利器strace"></a>程序分析利器strace</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>strace可以通过捕捉记录正在运行进程的系统调用和信号来进行程序分析，既然是系统调用，因此shell脚本和应用程序都可以通过strace来调试分析。</p>
<a id="more"></a>
<hr>
<p>strace是一个非常方便有用的诊断，调试工具，我们不需要重新编译程序，通过strace追踪便可获得系统底层发生的文件管理，进程管理，内存分配，信号捕捉等事件。比如有的时候内存泄露我们无法从日志中发现异常，因此需要更加底层的内存分配管理调用来分析。</p>
<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p>在strace捕捉到每行记录中都包含系统调用名字，参数和返回值，也可以通过参数打印很多的调用细节，比如所属进程，调用开始和消耗时间。捕捉到的所有信息我们可以输出到标准输出，也可以输出到指定文件。</p>
<h3 id="系统调用生命周期标记"><a href="#系统调用生命周期标记" class="headerlink" title="系统调用生命周期标记"></a>系统调用生命周期标记</h3><p>在追踪多个进程和线程的系统调用过程中，当A系统调用执行一段时候后，此时B系统调用开始执行，我们通过<code>unfinished</code>标记调用的开始，<code>resumed</code>来标记调用的结束</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">16308</span> <span class="number">14</span>:<span class="number">47</span>:<span class="number">31.092116</span> mmap2(<span class="literal">NULL</span>, <span class="number">19480576</span>, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, <span class="number">-1</span>, <span class="number">0</span> &lt;unfinished ...&gt;</span><br><span class="line"><span class="number">15606</span> <span class="number">14</span>:<span class="number">47</span>:<span class="number">31.092137</span> clock_gettime(CLOCK_REALTIME,  &lt;unfinished ...&gt;</span><br><span class="line"><span class="number">16308</span> <span class="number">14</span>:<span class="number">47</span>:<span class="number">31.092153</span> &lt;... mmap2 resumed&gt; ) = <span class="number">0x842e9000</span> &lt;<span class="number">0.000022</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="结构体参数-返回值打印"><a href="#结构体参数-返回值打印" class="headerlink" title="结构体参数/返回值打印"></a>结构体参数/返回值打印</h3><p>结构体使用花括号括起来，并使用空格分离</p>
<p>比如<code>clock_gettime</code>，函数原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(<span class="keyword">clockid_t</span> clk_id, struct timespec *tp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>系统调用显示为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">15606</span> <span class="number">14</span>:<span class="number">47</span>:<span class="number">31.093987</span> clock_gettime(CLOCK_REALTIME,  &lt;unfinished ...&gt;</span><br><span class="line"><span class="number">16308</span> <span class="number">14</span>:<span class="number">47</span>:<span class="number">31.094002</span> &lt;... futex resumed&gt; ) = <span class="number">1</span> &lt;<span class="number">0.000023</span>&gt;</span><br><span class="line"><span class="number">15606</span> <span class="number">14</span>:<span class="number">47</span>:<span class="number">31.094019</span> &lt;... clock_gettime resumed&gt; &#123;tv_sec=<span class="number">403766673093154435</span>, tv_nsec=<span class="number">7593356726744084332</span>&#125;) = <span class="number">0</span> &lt;<span class="number">0.000023</span>&gt;  &gt;&gt;返回结果</span><br></pre></td></tr></table></figure>

<p>最终timespec结构体结果打印为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;tv_sec=<span class="number">403766673093154435</span>, tv_nsec=<span class="number">7593356726744084332</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组成员打印"><a href="#数组成员打印" class="headerlink" title="数组成员打印"></a>数组成员打印</h3><p>数组使用方括号括起来，并使用空格分离</p>
<p>比如<code>execve</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;sleep 2&quot;], [/* 30 vars */]) = 0 &lt;0.000135&gt;</span><br></pre></td></tr></table></figure>



<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h3><p>strace有两种执行方式</p>
<p>第一种<code>strace + 程序</code>，比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace sleep 5  &gt;&gt;strace +shell命令</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> strace test-run  &gt;&gt;strace +可执行二进制程序</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace ./test.sh &gt;&gt;strace +shell脚本</span><br></pre></td></tr></table></figure>

<p>第二种为 <code>strace -p PID</code>，比如</p>
<p>有一个正在运行的程序<code>./test-run</code>， 获取该程序的进程号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test/ $ pidof test-run</span><br><span class="line">66725 66723</span><br></pre></td></tr></table></figure>

<p>之后追踪此进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"> $</span><span class="bash"> sudo strace -p 66723                                                                               [10:26:57] strace: Process 66723 attached</span></span><br><span class="line">restart_syscall(&lt;... resuming interrupted nanosleep ...&gt;) = 0</span><br><span class="line">write(1, &quot;in father pid: 66723  to sleep\n&quot;, 31) = 31</span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>下面是最常用的使用搭配</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace -o output.txt -T -tt -p 28979 -f</span><br></pre></td></tr></table></figure>

<p>按照使用频率来进行记录</p>
<h4 id="o-文件"><a href="#o-文件" class="headerlink" title="-o  文件"></a>-o  文件</h4><p>指定日志输出文件，实际项目追踪过程中几分钟内会产生上百万行日志，如果输出到屏幕，可能会导致键盘控制无效或者控制终端崩溃等，也不利于浏览和过滤关键信息，因此最好将系统调用记录输出重定向到文件，但是进程执行的输出依旧显示在屏幕。</p>
<h4 id="T"><a href="#T" class="headerlink" title="-T"></a>-T</h4><p>在最右端打印系统调用时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test/ $ strace -T sleep 2</span><br><span class="line">...</span><br><span class="line">nanosleep(&#123;2, 0&#125;, NULL)                 = 0 &lt;2.000731&gt;  &gt;&gt;系统调用时间为2.000731s</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="tt"><a href="#tt" class="headerlink" title="-tt"></a>-tt</h4><p>在最左端打印调用时的时间戳，微妙级</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test/ $ strace -T -tt sleep 2</span><br><span class="line">10:54:49.461790 nanosleep(&#123;2, 0&#125;, NULL) = 0 &lt;2.000594&gt;</span><br><span class="line">10:54:51.462440 close(1)                = 0 &lt;0.000016&gt;</span><br><span class="line">10:54:51.462500 close(2)                = 0 &lt;0.000014&gt;</span><br></pre></td></tr></table></figure>

<h4 id="f-F"><a href="#f-F" class="headerlink" title="-f/-F"></a>-f/-F</h4><p>-F同-f功能一致，都是打印进程号，包括fork的子进程和线程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test/ $ strace -T -tt -f test-run</span><br><span class="line"></span><br><span class="line">11:10:23.994700 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f3fa30db9d0) = 70544 &lt;0.000051&gt;    &gt;&gt;通过fork创建子进程，并返回子进程号</span><br><span class="line">11:10:23.994772 getpid()                = 70543 &lt;0.000006&gt;   &gt;&gt;父进程获取自己的进程号</span><br><span class="line">11:10:23.994794 write(1, &quot;in father pid: 70543 start to sl&quot;..., 36in father pid: 70543 start to sleep                      </span><br><span class="line">) = 36 &lt;0.000076&gt;</span><br><span class="line">strace: Process 70544 attached                &gt;&gt;strace开始追踪子进程70544</span><br><span class="line">[pid 70543] 11:10:23.994981 nanosleep(&#123;10, 0&#125;,  &lt;unfinished ...&gt;  &gt;&gt;父进程开始睡眠</span><br><span class="line">[pid 70544] 11:10:23.995047 write(1, &quot;in child pid: 70544 start to sle&quot;..., 35in child pid: 70544 start to slepp    &gt;&gt;子进程系统调用</span><br><span class="line">) = 35 &lt;0.000024&gt;</span><br></pre></td></tr></table></figure>

<h4 id="ff"><a href="#ff" class="headerlink" title="-ff"></a>-ff</h4><p>将追踪的多进程的系统调用记录重定向到不同的文件，需要搭配-o 使用，比如指定 -o output.txt, 会生成output.txt.PID，但是进程执行的输出依旧显示在屏幕</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test/ $ strace -T -tt -f  -o output.txt test-run</span><br><span class="line">                       &gt;&gt;进程打印</span><br><span class="line">START TO RUN SUB_MODULE: fork  &gt;&gt;开始fork子进程</span><br><span class="line">in father pid: 71278 start to sleep   &gt;&gt;父进程pid为71278</span><br><span class="line">in child pid: 71279 start to sleep    &gt;&gt;子进程pid为71279</span><br><span class="line">in child pid: 71279 end to sleep</span><br><span class="line">in father pid: 71278  to sleep</span><br></pre></td></tr></table></figure>

<p>最终生成文件为<code>output.txt.71278</code>和<code>output.txt.71279</code></p>
<h4 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h4><p>打印系统调用时的指令地址</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">test/ $ strace -i sleep <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="string">[00007f067d4d4370]</span> nanosleep(&#123;<span class="number">2</span>, <span class="number">0</span>&#125;, NULL) = <span class="number">0</span></span><br><span class="line"><span class="string">[00007f067d48035b]</span> close(<span class="number">1</span>)             = <span class="number">0</span></span><br><span class="line"><span class="string">[00007f067d48035b]</span> close(<span class="number">2</span>)             = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="b"><a href="#b" class="headerlink" title="-b"></a>-b</h4><p><code>-b syscall</code>，当指定的系统调用被捕捉时，将该进程从strace中脱离，目前只支持execve， 对带有-f 的选项的有用，这样可以不看子进程的调用，  但是可以是看多线程的系统调用。比如system函数的调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world start \n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;sleep 2&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world start \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如以上代码system函数在fork子进程之后通过execve来执行 <code>sleep 2</code>这条shell命令</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">35</span>:<span class="number">16.278634</span> clone(child_stack=<span class="number">0</span>, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=<span class="number">0x7fff0f8f096c</span>) = <span class="number">156737</span> &lt;<span class="number">0.000051</span>&gt;   &gt;&gt;fork通过clone创建子进程</span><br><span class="line"><span class="number">14</span>:<span class="number">35</span>:<span class="number">16.278699</span> wait4(<span class="number">156737</span>, strace: Process <span class="number">156737</span> attached</span><br><span class="line"> &lt;unfinished ...&gt;    &gt;&gt;strace捕捉子进程syscall</span><br><span class="line"><span class="string">[pid 156737]</span> <span class="number">14</span>:<span class="number">35</span>:<span class="number">16.278755</span> rt_sigaction(SIGINT, &#123;SIG_DFL, [], SA_RESTORER, <span class="number">0x7fbedb1de4c0</span>&#125;, NULL, <span class="number">8</span>) = <span class="number">0</span> &lt;<span class="number">0.000007</span>&gt;</span><br><span class="line"><span class="string">[pid 156737]</span> <span class="number">14</span>:<span class="number">35</span>:<span class="number">16.278776</span> rt_sigaction(SIGQUIT, &#123;SIG_DFL, [], SA_RESTORER, <span class="number">0x7fbedb1de4c0</span>&#125;, NULL, <span class="number">8</span>) = <span class="number">0</span> &lt;<span class="number">0.000006</span>&gt;</span><br><span class="line"><span class="string">[pid 156737]</span> <span class="number">14</span>:<span class="number">35</span>:<span class="number">16.278795</span> rt_sigprocmask(SIG_SETMASK, [], NULL, <span class="number">8</span>) = <span class="number">0</span> &lt;<span class="number">0.000007</span>&gt;</span><br><span class="line"><span class="string">[pid 156737]</span> <span class="number">14</span>:<span class="number">35</span>:<span class="number">16.278820</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 2&quot;</span>], [<span class="comment">/* 30 vars */</span>]strace: Process <span class="number">156737</span> detached      &gt;&gt;捕捉到子进程的execve信号，然后脱离进程</span><br><span class="line"> &lt;detached ...&gt;</span><br><span class="line"><span class="number">14</span>:<span class="number">35</span>:<span class="number">18.281459</span> &lt;... wait4 resumed&gt; [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == <span class="number">0</span>&#125;], <span class="number">0</span>, NULL) = <span class="number">156737</span> &lt;<span class="number">2.002757</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="e"><a href="#e" class="headerlink" title="-e"></a>-e</h4><p>-e expr 指定捕捉指定类型的系统调用</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-e trace=set</td>
<td>跟踪指定的系统调用</td>
</tr>
<tr>
<td>-e trace=file</td>
<td>跟踪文件相关的系统调用（文件名作参数）</td>
</tr>
<tr>
<td>-e trace=process</td>
<td>跟踪进程相关的系统调用</td>
</tr>
<tr>
<td>-e trace=network</td>
<td>跟踪网络相关的系统调用</td>
</tr>
<tr>
<td>-e trace=ipc</td>
<td>跟踪进程通讯相关的系统调用</td>
</tr>
<tr>
<td>-e trace=desc</td>
<td>根据文件描述符的系统调用</td>
</tr>
<tr>
<td>-e trace=memory</td>
<td>跟踪内存相关的系统调用</td>
</tr>
<tr>
<td>-e raw=set</td>
<td>将制定的系统调用参数16进制打印出来             实践ok</td>
</tr>
<tr>
<td>-e signal=set</td>
<td>追踪指定的信号  未实验成功 -e signal=SIGCHLD</td>
</tr>
<tr>
<td>-e read=3,5</td>
<td>输出从指定文件句柄read出的内容             实践ok</td>
</tr>
<tr>
<td>-e write=set</td>
<td>输出写入到指定文件句柄的内容               实践ok</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test/ $ strace   -e write=1,2 -T  -tt -f ./hello-world</span><br><span class="line">...</span><br><span class="line">15:16:44.543954 write(1, &quot;hello world start \n&quot;, 19hello world start</span><br><span class="line">) = 19 &lt;0.000009&gt;</span><br><span class="line"> | 00000  68 65 6c 6c 6f 20 77 6f  72 6c 64 20 73 74 61 72  hello world star |</span><br><span class="line"> | 00010  74 20 0a</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="c-C"><a href="#c-C" class="headerlink" title="-c/-C"></a>-c/-C</h4><p>统计系统调用时间，但是不会打印普通的输出， -C既有普通的输出，也会在最后进行系统调用个数统计</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test/ $ sudo strace   -c   sleep 2                                                                   [15:23:57] % time     seconds  usecs/call     calls    errors syscall</span><br><span class="line"></span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"></span><br><span class="line">  0.00    0.000000           0         1           read</span><br><span class="line">  0.00    0.000000           0         3           open</span><br><span class="line">  0.00    0.000000           0         5           close</span><br><span class="line">  0.00    0.000000           0         3           fstat</span><br><span class="line">  0.00    0.000000           0         8           mmap</span><br><span class="line">  0.00    0.000000           0         4           mprotect</span><br><span class="line">  0.00    0.000000           0         1           munmap</span><br><span class="line">  0.00    0.000000           0         3           brk</span><br><span class="line">  0.00    0.000000           0         3         3 access</span><br><span class="line">  0.00    0.000000           0         1           nanosleep</span><br><span class="line">  0.00    0.000000           0         1           execve</span><br><span class="line">  0.00    0.000000           0         1           arch_prctl</span><br><span class="line"></span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"></span><br><span class="line">100.00    0.000000                    34         3 total</span><br></pre></td></tr></table></figure>

<p>access系统调用失败是我本地电脑没有一些系统库</p>
<h4 id="w"><a href="#w" class="headerlink" title="-w"></a>-w</h4><p>统计系统调用开始和结束的时间差，和-c搭配使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test/ $ sudo strace   -c -w  sleep 2                                                                 [15:28:41] % time     seconds  usecs/call     calls    errors syscall</span><br><span class="line"></span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"></span><br><span class="line"> 99.98    2.000670     2000670         1           nanosleep</span><br><span class="line">  0.00    0.000096          96         1           execve</span><br><span class="line">  0.00    0.000058           7         8           mmap</span><br><span class="line">  0.00    0.000032           6         5           close</span><br><span class="line">  0.00    0.000031           8         4           mprotect</span><br><span class="line">  0.00    0.000025           8         3           open</span><br><span class="line">  0.00    0.000021           7         3         3 access</span><br><span class="line">  0.00    0.000020           7         3           brk</span><br><span class="line">  0.00    0.000018           6         3           fstat</span><br><span class="line">  0.00    0.000010          10         1           munmap</span><br><span class="line">  0.00    0.000006           6         1           read</span><br><span class="line">  0.00    0.000006           6         1           arch_prctl</span><br><span class="line"></span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"></span><br><span class="line">100.00    2.000993                    34         3 total</span><br></pre></td></tr></table></figure>

<p>能发现进程大部分时间都用在nanosleep上，可以用来检查性能瓶颈并针对优化</p>
<h4 id="S"><a href="#S" class="headerlink" title="-S"></a>-S</h4><p>对-c统计的数据进行排序，比如默认是时间，也可以是名字和系统调用次数,时间</p>
<p>比如对调用次数进行排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> strace -c -w -S calls sleep 2                                                                       [15:28:50] % time     seconds  usecs/call     calls    errors syscall</span><br><span class="line"></span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"></span><br><span class="line">  0.00    0.000057           7         8           mmap</span><br><span class="line">  0.00    0.000042           8         5           close</span><br><span class="line">  0.00    0.000033           8         4           mprotect</span><br><span class="line">  0.00    0.000026           9         3           open</span><br><span class="line">  0.00    0.000020           7         3           fstat</span><br><span class="line">  0.00    0.000019           6         3           brk</span><br><span class="line">  0.00    0.000021           7         3         3 access</span><br><span class="line">  0.00    0.000007           7         1           read</span><br><span class="line">  0.00    0.000010          10         1           munmap</span><br><span class="line"> 99.98    2.000387     2000387         1           nanosleep</span><br><span class="line">  0.00    0.000090          90         1           execve</span><br><span class="line">  0.00    0.000006           6         1           arch_prctl</span><br><span class="line"></span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"></span><br><span class="line">100.00    2.000718                    34         3 total</span><br></pre></td></tr></table></figure>

<p>对syscall所用时间排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test/ $ strace -C -w -S time sleep 2</span><br><span class="line"><span class="meta">%</span><span class="bash"> time     seconds  usecs/call     calls    errors syscall</span></span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"> 99.98    2.001845     2001845         1           nanosleep</span><br><span class="line">  0.01    0.000108         108         1           execve</span><br><span class="line">  0.00    0.000057           7         8           mmap</span><br><span class="line">  0.00    0.000049          10         5           close</span><br><span class="line">  0.00    0.000030           8         4           mprotect</span><br><span class="line">  0.00    0.000030          10         3         3 access</span><br><span class="line">  0.00    0.000024           8         3           open</span><br><span class="line">  0.00    0.000019           6         3           fstat</span><br><span class="line">  0.00    0.000019           6         3           brk</span><br><span class="line">  0.00    0.000010          10         1           munmap</span><br><span class="line">  0.00    0.000006           6         1           read</span><br><span class="line">  0.00    0.000006           6         1           arch_prctl</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">100.00    2.002203                    34         3 total</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li>N项目遇到超夜拍照内存泄露，对比检查进程smap发现泄露地址，通过地址对比strace抓取mmap系统调用记录，获取该地址内存申请线程和上下文执行状态，确定内存泄露程序范围。</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>strace</tag>
        <tag>稳定性</tag>
        <tag>linux</tag>
        <tag>kernel-tool</tag>
        <tag>程序调试</tag>
      </tags>
  </entry>
  <entry>
    <title>sysdump学习</title>
    <url>/archives/4.html</url>
    <content><![CDATA[<h1 id="sysdump学习"><a href="#sysdump学习" class="headerlink" title="sysdump学习"></a>sysdump学习</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>sysdump为dump system memory，也称内核转储。在内核发生异常时，通过kexec和kdump，将内存和寄存器信息保存，在重启以后的uboot阶段将信息转储到文件中。我们能够通过转储文件发现异常发生的根本原因。</p>
<a id="more"></a>
<hr>
<h2 id="内核异常发生情况"><a href="#内核异常发生情况" class="headerlink" title="内核异常发生情况"></a>内核异常发生情况</h2><p>内核调用panic来进行内核转储，大部分情况分为以下几种：</p>
<ol>
<li>代码简单逻辑异常直接或节间造成的panic调用， 比如空指针</li>
<li>代码逻辑异常造成的任务调度异常，其他任务无法抢占CPU</li>
<li>代码逻辑异常造成的中断关闭，比如中断处理中死锁</li>
<li>中断频率远超时钟中断</li>
<li>内存踩踏导致的非法地址访问</li>
<li>…</li>
</ol>
<p>下面是一些常见的触发场景：</p>
<h3 id="驱动调用"><a href="#驱动调用" class="headerlink" title="驱动调用"></a>驱动调用</h3><p>驱动调用panic，比如sysrq触发</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt;/proc/sys/kernel/sysrq</span><br><span class="line">echo c &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure>



<h3 id="die函数"><a href="#die函数" class="headerlink" title="die函数"></a>die函数</h3><h3 id="BUG-BUG-ON"><a href="#BUG-BUG-ON" class="headerlink" title="BUG/BUG_ON"></a>BUG/BUG_ON</h3><p>通过调用非法指令（未定义指令），空指针等进入die调用，或者直接调用panic</p>
<h3 id="page-fault"><a href="#page-fault" class="headerlink" title="page_fault"></a>page_fault</h3><p>访问非法地址，可能发生内存踩踏，通过RIP异常抛出入手分析</p>
<h3 id="soft-lockup"><a href="#soft-lockup" class="headerlink" title="soft lockup"></a>soft lockup</h3><p>每一个cpu上都有一个hrtime中断监控的watchdog线程，即hrimte触发的中断上下文会去检测watchdog线程，如果检测到该线程在设定时间内没有调度过，说明该cpu被长时间被占用，调度已经发生异常。原因：==进程上下文关闭抢占==。依赖中断，==如果中断被关闭，则此功能无法正常工作==</p>
<h3 id="hard-lockup"><a href="#hard-lockup" class="headerlink" title="hard lockup"></a>hard lockup</h3><p>一个cpu如果检测相邻的==cpu中断被关闭==就主动panic，见function watchdog_check_hardlockup_other_cpu，因此在panic中异常中断关闭的cpu也无法处理处理器中断，因此无法刷新缓冲，==sysdump信息因此不可靠==</p>
<h3 id="硬件喂狗"><a href="#硬件喂狗" class="headerlink" title="硬件喂狗"></a>硬件喂狗</h3><h4 id="单线程喂狗"><a href="#单线程喂狗" class="headerlink" title="单线程喂狗"></a>单线程喂狗</h4><p>需要一个喂狗线程定期对硬件狗操作，如果对硬件狗的操作延误，会导致触发硬狗中断，cpu收到中断在中断上下文进行panic调用</p>
<ol>
<li><p>如果硬狗中断被关闭，则功能失效。（==因此硬狗中断需要为不可屏蔽中断==）</p>
</li>
<li><p>如果硬狗中断被CPU响应，但是由于异常的cpu中断被关闭，因为异常的cpu缓存无法刷新，sysdump信息因此也不可靠</p>
</li>
<li><p>如果一个cpu异常，其他cpu依旧正常喂狗，则监测功能失效</p>
</li>
</ol>
<p>这种设计存在以下缺陷：</p>
<ol>
<li>假设CPU0异常，但是其他cpu一直在喂狗，因此无法监控到全部的cpu</li>
<li>异常cpu因为关闭中断导致无法处理panic发出的处理器中断，因此导致cpu缓存无法刷新</li>
</ol>
<h4 id="多线程绑定cpu喂狗"><a href="#多线程绑定cpu喂狗" class="headerlink" title="多线程绑定cpu喂狗"></a>多线程绑定cpu喂狗</h4><p>将cpu和线程绑定，cpu去操作一个全局变量，每一个cpu对应其中的一位，当线程醒来就置1，当全局置1的个数和cpu 正在使用的个数相等时，代表全部cpu都喂狗对应的狗，此时才会去喂硬狗，可以bitmap控制。</p>
<h2 id="转储内核分析"><a href="#转储内核分析" class="headerlink" title="转储内核分析"></a>转储内核分析</h2><p>在uboot将转储文件导出以后，我们需要通过这些文件配合内核符号映射表vmlinux进行异常现场分析</p>
<p>需要确定vmlinux和转储文件的kernel版本保持一致，编译环境可能是gcc，也有可能是clang</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> strings vmlinux | grep <span class="string">&quot;Linux version&quot;</span>                </span></span><br><span class="line">Linux version 4.14.199+-ab131  clang version 11.0.1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> strings sysdump.core | grep <span class="string">&quot;Linux version&quot;</span>    &gt;&gt;sysdump.core为内核转储后合并的文件</span></span><br><span class="line">Linux version 4.14.199+-ab131  clang version 11.0.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">或者gcc编译</span><br><span class="line">➜  5.17.0+  strings vmlinux | grep &quot;Linux version&quot;  </span><br><span class="line">Linux version 5.17.0+ (root@sholck) (gcc (Ubuntu 6.5.0-2ubuntu1~16.04) 6.5.0 20181026, GNU ld (GNU Binutils for Ubuntu) 2.26.1) #7 SMP PREEMPT_DYNAMIC Thu Mar 24 14:58:15 CST 2022</span><br><span class="line"></span><br><span class="line">➜  5.17.0+ strings vmcore | grep &quot;Linux version&quot; </span><br><span class="line">Linux version 5.17.0+ (root@sholck) (gcc (Ubuntu 6.5.0-2ubuntu1~16.04) 6.5.0 20181026, GNU ld (GNU Binutils for Ubuntu) 2.26.1) #7 SMP PREEMPT_DYNAMIC Thu Mar 24 14:58:15 CST 2022</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后通过crash工具进行现场分析</p>
<h3 id="crash"><a href="#crash" class="headerlink" title="crash"></a>crash</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol>
<li><p>官网：<a href="https://crash-utility.github.io/">https://crash-utility.github.io</a></p>
</li>
<li><p>android 项目自带，需要在vendor/xxx/tools目录下检查平台基线是否自带</p>
</li>
<li><p>ubuntu本地：sudo apt-get install linux-crashdump    (推荐)</p>
</li>
</ol>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>参数需要设置物理内存起始地址，内核符号映射表，转储内核</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> crash_arm64 -m phys_offset=0x80000000 vmlinux sysdump.core --cpus 8</span></span><br><span class="line"></span><br><span class="line">      KERNEL: vmlinux</span><br><span class="line">    DUMPFILE: all</span><br><span class="line">        CPUS: 8 [OFFLINE: 7]</span><br><span class="line">        DATE: Tue Dec 14 05:44:33 2021</span><br><span class="line">      UPTIME: 00:02:41</span><br><span class="line">LOAD AVERAGE: 5.99, 2.96, 1.16</span><br><span class="line">       TASKS: 1930</span><br><span class="line">    NODENAME: localhost</span><br><span class="line">     RELEASE: 4.14.199+-ab131</span><br><span class="line">     VERSION: #1 SMP PREEMPT Tue Dec 14 03:15:03 CST 2021</span><br><span class="line">     MACHINE: aarch64  (unknown Mhz)</span><br><span class="line">      MEMORY: 4 GB</span><br><span class="line">       PANIC: &quot;Kernel panic - not syncing: sysrq triggered crash&quot;  &gt;&gt;sysrq触发</span><br><span class="line">         PID: 7058</span><br><span class="line">     COMMAND: &quot;sh&quot;</span><br><span class="line">        TASK: ffffffc06a47da00  [THREAD_INFO: ffffffc06a47da00]</span><br><span class="line">         CPU: 3</span><br><span class="line">       STATE: TASK_RUNNING (PANIC）</span><br></pre></td></tr></table></figure>

<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>在启动的TUI窗口中，shell命令是可以执行的</p>
<h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p>打印内核中进程的状态，包括tasklet等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> ps &gt;ps.txt</span></span><br><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> ps | grep -n <span class="string">&quot;ffffffc06a47da00&quot;</span></span></span><br><span class="line">1930:&gt;  7058   6808   3  ffffffc06a47da00  RU   0.0 10771096   2696  sh</span><br></pre></td></tr></table></figure>

<h5 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h5><p>打印堆栈，默认打印crash cpu的堆栈</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> bt</span></span><br><span class="line">PID: 7058   TASK: ffffffc06a47da00  CPU: 3   COMMAND: &quot;sh&quot;</span><br><span class="line"><span class="meta"> #</span><span class="bash">0 [ffffff801582b950] sysdump_panic_event<span class="variable">$8bfd56c0834fe7d208b7e7c52872c4e4</span> at ffffff80087a218c</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">1 [ffffff801582b9b0] <span class="variable">$x</span>.25 at ffffff800826e600</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">2 [ffffff801582bc50] panic at ffffff800823a00c</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">3 [ffffff801582bcb0] sysrq_handle_crash<span class="variable">$330e89e9e6de65c311d08fb99226844d</span> at ffffff80087d3d14</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">4 [ffffff801582bcc0] __handle_sysrq at ffffff80087d3768</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">5 [ffffff801582bd10] <span class="variable">$x</span>.53 at ffffff80087d4dc0</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">6 [ffffff801582bd60] proc_reg_write<span class="variable">$5fc6da0b4e1b06391acfa8bd9d90410e</span> at ffffff80084fa0a4</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">7 [ffffff801582be10] __vfs_write at ffffff8008454d78</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">8 [ffffff801582be40] vfs_write at ffffff80084551b0</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">9 [ffffff801582be90] sys_write at ffffff800845540c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">10 [ffffff801582bff0] el0_svc_naked at ffffff80080844bc</span></span><br><span class="line">     PC: 00000075815348c8   LR: 0000005f4b89b63c   SP: 0000007ff5c9a450</span><br><span class="line">    X29: 0000007ff5c9a4d0  X28: 0000007ff5c9a490  X27: 0000005f4b8c02e8</span><br><span class="line">    X26: 00000075816fe000  X25: 0000000000000063  X24: 0000005f4b89e99c</span><br><span class="line">    X23: 0000005f4b8bf640  X22: 0000007ff5c9a4b0  X21: 0000007ff5c9a4a8</span><br><span class="line">    X20: b4000073f13a5328  X19: 0000000000000002  X18: 0000007581866000</span><br><span class="line">    X17: 00000075815348c0  X16: 0000007581552ef8  X15: 000000000000002f</span><br><span class="line">    X14: 0000000000000072  X13: f790000000012102  X12: 0000000032d3dd57</span><br><span class="line">    X11: 00000000f13a53bc  X10: b4000073f13a53a8   X9: b4000073f13a5328</span><br><span class="line">     X8: 0000000000000040   X7: 0000000000000000   X6: 0000000000000063</span><br><span class="line">     X5: b4000073813a469a   X4: ffffffffffffffff   X3: ffffffffffffffff</span><br><span class="line">     X2: 0000000000000002   X1: b4000073f13a5328   X0: 0000000000000001</span><br><span class="line">    ORIG_X0: 0000000000000001  SYSCALLNO: 40  PSTATE: 00001000</span><br></pre></td></tr></table></figure>

<h5 id="log"><a href="#log" class="headerlink" title="log"></a>log</h5><p>打印kernel最后log buffer保存的信息，一般也会包含堆栈和寄存器信息，分析可以对异常有一个大概的了解</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> <span class="built_in">log</span> &gt;log.txt</span></span><br></pre></td></tr></table></figure>

<h5 id="runq"><a href="#runq" class="headerlink" title="runq"></a>runq</h5><p>查看线程列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> runq -c 3  &gt;&gt;指定cpu3</span></span><br><span class="line">CPU 3 RUNQUEUE: ffffffc0ffec6700</span><br><span class="line">  CURRENT: PID: 7058   TASK: ffffffc06a47da00  COMMAND: &quot;sh&quot;</span><br><span class="line">  RT PRIO_ARRAY: ffffffc0ffec6868</span><br><span class="line">     [no tasks queued]</span><br><span class="line">  CFS RB_ROOT: ffffffc0ffec6790</span><br><span class="line">     [no tasks queued]</span><br></pre></td></tr></table></figure>

<h5 id="irq"><a href="#irq" class="headerlink" title="irq"></a>irq</h5><p>查看中断数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> irq</span></span><br><span class="line">IRQ   IRQ_DESC/_DATA      IRQACTION      NAME</span><br><span class="line">  0       (unused)          (unused)</span><br><span class="line">  1   ffffffc0fa821600      (unused)</span><br><span class="line">  2   ffffffc0fa821800  ffffffc0faaa3d80  &quot;/soc/aon/timer@64470000&quot;</span><br><span class="line">  3   ffffffc0fa821a00      (unused)</span><br><span class="line">  4   ffffffc0fa821c00  ffffffc0faaa4180  &quot;arch_timer&quot;   &gt;&gt;定时器中断</span><br><span class="line">  </span><br><span class="line"><span class="meta">  crash_arm64&gt;</span><span class="bash"> irq 4</span></span><br><span class="line"> IRQ   IRQ_DESC/_DATA      IRQACTION      NAME</span><br><span class="line">  4   ffffffc0fa821c00  ffffffc0faaa4180  &quot;arch_timer&quot;</span><br><span class="line">  </span><br><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> irqaction ffffffc0faaa4180</span></span><br><span class="line">struct irqaction &#123;</span><br><span class="line">  handler = 0xffffff8008f9a078 &lt;arch_timer_handler_phys$5757c1f5416e78392ea0a8126822dd28.cfi_jt&gt;, &gt;&gt;对应中断模块</span><br><span class="line">  dev_id = 0x0,</span><br><span class="line">  percpu_dev_id = 0xffffff8009761480,</span><br><span class="line">  next = 0x0,</span><br><span class="line">  thread_fn = 0x0,</span><br><span class="line">  thread = 0x0,</span><br><span class="line">  secondary = 0x0,</span><br><span class="line">  irq = 4,</span><br><span class="line">  flags = 17412,</span><br><span class="line">  thread_flags = 0,</span><br><span class="line">  thread_mask = 0,</span><br><span class="line">  name = 0xffffff8009304dca &quot;arch_timer&quot;,</span><br><span class="line">  dir = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看各中断触发在cpu上触发次数，也可以看出中断控制器驱动版本GICv3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> irq -s</span></span><br><span class="line">           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7</span><br><span class="line">  2:       5040       2761       2996       2917       4043       4225        999       1438    GICv3 /soc/aon/timer@64470000</span><br><span class="line">  4:      35885      27954      25117      23517      22156      20163      29762      28382    GICv3 arch_timer</span><br></pre></td></tr></table></figure>

<h5 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h5><p>查看数据结构成员，并打印结构体大小，默认下直接输出结构名即可打印</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> thread_struct  &gt;&gt;直接输入结构体即可</span></span><br><span class="line">struct thread_struct &#123;</span><br><span class="line">    struct cpu_context cpu_context;</span><br><span class="line">    unsigned long tp_value;</span><br><span class="line">    unsigned long tp2_value;</span><br><span class="line">    struct fpsimd_state fpsimd_state;</span><br><span class="line">    unsigned long fault_address;</span><br><span class="line">    unsigned long fault_code;</span><br><span class="line">    struct debug_info debug;</span><br><span class="line">&#125;</span><br><span class="line">SIZE: 960</span><br><span class="line"></span><br><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> struct thread_struct -o &gt;&gt;可以加选项-o(显示成员偏移)或者-x</span></span><br><span class="line">struct thread_struct &#123;</span><br><span class="line">    [0] struct cpu_context cpu_context;</span><br><span class="line">  [104] unsigned long tp_value;</span><br><span class="line">  [112] unsigned long tp2_value;</span><br><span class="line">  [128] struct fpsimd_state fpsimd_state;</span><br><span class="line">  [672] unsigned long fault_address;</span><br><span class="line">  [680] unsigned long fault_code;</span><br><span class="line">  [688] struct debug_info debug;</span><br><span class="line">&#125;</span><br><span class="line">SIZE: 960</span><br></pre></td></tr></table></figure>

<h5 id="rd"><a href="#rd" class="headerlink" title="rd"></a>rd</h5><p>打印指定内存地址的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> sysrq_crash_op</span></span><br><span class="line">sysrq_crash_op = $23 = &#123;</span><br><span class="line">  handler = 0xffffff8008f9a8fc &lt;sysrq_handle_crash$330e89e9e6de65c311d08fb99226844d.cfi_jt&gt;,</span><br><span class="line">  help_msg = 0xffffff8009364302 &quot;crash(c)&quot;,</span><br><span class="line">  action_msg = 0xffffff800931823a &quot;Trigger a crash&quot;,</span><br><span class="line">  enable_mask = 8</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> sysrq_key_op -o</span></span><br><span class="line">struct sysrq_key_op &#123;</span><br><span class="line">   [0] void (*handler)(int);</span><br><span class="line">   [8] char *help_msg;</span><br><span class="line">  [16] char *action_msg;</span><br><span class="line">  [24] int enable_mask;</span><br><span class="line">&#125;</span><br><span class="line">SIZE: 32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> rd 0xffffff8009364302 2</span></span><br><span class="line">ffffff8009364302:  2963286873617263 28746f6f62657200   crash(c).reboot(</span><br><span class="line"></span><br><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> rd 0xffffff800931823a 2</span></span><br><span class="line">ffffff800931823a:  2072656767697254 0068736172632061   Trigger a crash.</span><br><span class="line"></span><br><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> rd sysrq_crash_op 4   </span></span><br><span class="line">ffffff8009bbf798:  ffffff8008f9a8fc ffffff8009364302   .........C6.....</span><br><span class="line">ffffff8009bbf7a8:  ffffff800931823a 0000000000000008   :.1.............</span><br></pre></td></tr></table></figure>

<p>上面正确的解析为 0x63为c  0x72为r,  0x61为a，对应2963286873617263中的后三个字节</p>
<h5 id="dis"><a href="#dis" class="headerlink" title="dis"></a>dis</h5><p>反编译 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> dis msleep -lx</span></span><br><span class="line">/code/bsp/kernel/kernel4.14/kernel/time/timer.c: 1919</span><br><span class="line">0xffffff80082e8bdc &lt;$x.165&gt;:    stp     x29, x30, [sp,#-32]!</span><br><span class="line">0xffffff80082e8be0 &lt;msleep+0x4&gt;:        stp     x20, x19, [sp,#16]</span><br><span class="line">0xffffff80082e8be4 &lt;msleep+0x8&gt;:        mov     x29, sp</span><br><span class="line">0xffffff80082e8be8 &lt;msleep+0xc&gt;:        mov     w19, w0</span><br><span class="line">0xffffff80082e8bec &lt;msleep+0x10&gt;:       nop</span><br><span class="line">/code/bsp/kernel/kernel4.14/kernel/time/time.c: 616</span><br><span class="line">0xffffff80082e8bf0 &lt;msleep+0x14&gt;:       mov     w8, w19</span><br><span class="line">/code/bsp/kernel/kernel4.14/kernel/time/timer.c: 1920</span><br><span class="line">0xffffff80082e8bf4 &lt;msleep+0x18&gt;:       cmp     w19, #0x0</span><br><span class="line">/code/bsp/kernel/kernel4.14/kernel/time/time.c: 616</span><br><span class="line">0xffffff80082e8bf8 &lt;msleep+0x1c&gt;:       add     x8, x8, #0x3</span><br><span class="line">0xffffff80082e8bfc &lt;msleep+0x20&gt;:       mov     x9, #0x3fffffffffffffff         // #4611686018427387903</span><br><span class="line">0xffffff80082e8c00 &lt;msleep+0x24&gt;:       lsr     x8, x8, #2</span><br><span class="line">/code/bsp/kernel/kernel4.14/kernel/time/timer.c: 1920</span><br><span class="line">0xffffff80082e8c04 &lt;msleep+0x28&gt;:       csinc   x0, x9, x8, lt</span><br><span class="line">0xffffff80082e8c08 &lt;msleep+0x2c&gt;:       mov     w19, #0x2                       // #2</span><br><span class="line">0xffffff80082e8c0c &lt;msleep+0x30&gt;:       mrs     x20, sp_el0</span><br><span class="line">g/code/bsp/kernel/kernel4.14/kernel/time/timer.c: 1793</span><br><span class="line">0xffffff80082e8c10 &lt;msleep+0x34&gt;:       str     x19, [x20,#32]</span><br><span class="line">/code/bsp/kernel/kernel4.14/kernel/time/timer.c: 1794</span><br><span class="line">0xffffff80082e8c14 &lt;msleep+0x38&gt;:       bl      0xffffff8008f7a4d4 &lt;$x.136&gt;</span><br><span class="line">/code/bsp/kernel/kernel4.14/kernel/time/timer.c: 1922</span><br><span class="line">0xffffff80082e8c18 &lt;msleep+0x3c&gt;:       cbnz    x0, 0xffffff80082e8c10 &lt;msleep+0x34&gt;</span><br><span class="line">/code/bsp/kernel/kernel4.14/kernel/time/timer.c: 1924</span><br><span class="line">0xffffff80082e8c1c &lt;msleep+0x40&gt;:       ldp     x20, x19, [sp,#16]</span><br><span class="line">0xffffff80082e8c20 &lt;msleep+0x44&gt;:       ldp     x29, x30, [sp],#32</span><br><span class="line">0xffffff80082e8c24 &lt;msleep+0x48&gt;:       ret</span><br></pre></td></tr></table></figure>

<h5 id="vtop"><a href="#vtop" class="headerlink" title="vtop"></a>vtop</h5><p>虚拟地址到物理地址的映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> vtop 0xffffff8009364302</span></span><br><span class="line">VIRTUAL           PHYSICAL</span><br><span class="line">ffffff8009364302  81364302</span><br><span class="line"></span><br><span class="line">PAGE DIRECTORY: ffffff800a063000</span><br><span class="line">   PGD: ffffff800a063000 =&gt; 17fffd003</span><br><span class="line">   PMD: ffffffc0ffffd248 =&gt; 81200791   页中间目录，二级页表索引中可以称为页表，存放PTE页表项</span><br><span class="line">  PAGE: 81200000  (2MB)    页表项+偏移</span><br><span class="line"></span><br><span class="line">  PTE     PHYSICAL  FLAGS</span><br><span class="line">81200791  81200000  (VALID|RDONLY|SHARED|AF)    </span><br><span class="line"></span><br><span class="line">      PAGE               PHYSICAL      MAPPING       INDEX CNT FLAGS</span><br><span class="line">ffffffbf0004d900         81364000                0        0  1 1000 reserved</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> rd -p 81364302  打印物理地址内的内存信息</span></span><br><span class="line">        81364302:  2963286873617263                    crash(c)</span><br></pre></td></tr></table></figure>

<h5 id="sym"><a href="#sym" class="headerlink" title="sym"></a>sym</h5><p>功能：映射转化</p>
<p>打印全部的符号表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">crash_arm64&gt;</span><span class="bash"> sym -l | grep -n <span class="string">&quot;sysrq_crash_op&quot;</span></span></span><br><span class="line">265279:ffffff8009bbf798 (d) sysrq_crash_op</span><br></pre></td></tr></table></figure>

<p>符号转化为虚拟地址</p>
<h2 id="缩略语"><a href="#缩略语" class="headerlink" title="缩略语"></a>缩略语</h2><ol>
<li>FIQ Fast Interrupt Request 快速中断模式</li>
<li>NMI No-Maskable Interrupt 不可屏蔽中断</li>
<li>IPI Inter-Process Interrupt  处理器中断</li>
<li>GIC Generic Interrupt Controller 中断控制器</li>
<li>SGI Software Generated Interrupt 软件触发中断，也称为IPI中断</li>
<li>ISR interrupt service routine 中断服务程序</li>
<li>FIQ 快速中断 </li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
        <tag>linux</tag>
        <tag>kernel-tool</tag>
        <tag>程序调试</tag>
        <tag>sysdump</tag>
        <tag>crash</tag>
        <tag>kdump</tag>
      </tags>
  </entry>
  <entry>
    <title>内核实践-linux5.12.0-rc8</title>
    <url>/archives/2.html</url>
    <content><![CDATA[<h1 id="内核实践-linux5-12-0-rc8"><a href="#内核实践-linux5-12-0-rc8" class="headerlink" title="内核实践-linux5.12.0-rc8"></a>内核实践-linux5.12.0-rc8</h1><p><a id="0"></a></p>
<ul>
<li><a href="#1">环境配置</a></li>
<li><a href="#2">编译</a></li>
<li><a href="#3">qemu-guest-run</a></li>
<li><a href="#4">gdb</a></li>
<li><a href="#5">BusyBox</a></li>
<li><a href="#6">Crash</a></li>
<li><a href="#7">参考</a></li>
</ul>
<a id="more"></a>
<hr>
<p>这篇文章除了回顾，更多的是希望能进一步探索内核，包括gdb和qemu</p>
<p><a id="1"></a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>本地系统为ubuntu14,gcc和g++版本都太老，需要升级到ubuntu16.<br>同时ubuntu16默认的gcc和gcc都是4.9的，也需要升级到5.0以上<br>升级完查看本地环境,已经升级到6.0</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#gcc --version</span></span><br><span class="line"><span class="attribute">gcc</span> (Ubuntu <span class="number">6</span>.<span class="number">5</span>.<span class="number">0</span>-<span class="number">2</span>ubuntu<span class="number">1</span>~<span class="number">16</span>.<span class="number">04</span>) <span class="number">6</span>.<span class="number">5</span>.<span class="number">0</span> <span class="number">20181026</span></span><br><span class="line"><span class="comment">#g++ --version</span></span><br><span class="line"><span class="attribute">g</span>++ (Ubuntu <span class="number">6</span>.<span class="number">5</span>.<span class="number">0</span>-<span class="number">2</span>ubuntu<span class="number">1</span>~<span class="number">16</span>.<span class="number">04</span>) <span class="number">6</span>.<span class="number">5</span>.<span class="number">0</span> <span class="number">20181026</span></span><br></pre></td></tr></table></figure>

<p>升级gcc和g++如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br><span class="line">sudo apt-<span class="keyword">get</span> install gcc<span class="number">-6</span> g++<span class="number">-6</span></span><br><span class="line"><span class="comment">//通过软链接选择高版本</span></span><br><span class="line"># cd /usr/bin</span><br><span class="line"># rm -rf gcc</span><br><span class="line"># ln -s gcc<span class="number">-6</span> gcc</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root      <span class="number">7</span>  <span class="number">4</span>月 <span class="number">15</span> <span class="number">18</span>:<span class="number">50</span> gcc -&gt; gcc<span class="number">-6</span></span><br><span class="line"></span><br><span class="line">#  rm -rf g++</span><br><span class="line"># ln -s g++<span class="number">-6</span> g++</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root      <span class="number">7</span>  <span class="number">4</span>月 <span class="number">15</span> <span class="number">18</span>:<span class="number">51</span> g++ -&gt; g++<span class="number">-6</span></span><br></pre></td></tr></table></figure>

<p><a id="2"></a></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><a href="#0">回到主目录</a></p>
<p>在编译前，先简单介绍一下内核相关文件的存放路径</p>
<ol>
<li>内核源码放置路径 目前我们系统uname -r 为:4.4.0-210-generic ，源代码路径:/usr/src/linux-headers-4.4.0-210-generic</li>
<li>配置文件，内核引导文件，虚拟挂载系统文件 /boot config-4.4.0-210-generic  vmlinuz-4.4.0-210-generic initrd.img-4.4.0-210-generic </li>
<li>模块安装路径: 方便我们动态链接模块 /lib/modules/4.4.0-210-generic</li>
</ol>
<h3 id="编译内核文档"><a href="#编译内核文档" class="headerlink" title="编译内核文档"></a>编译内核文档</h3><p>linux提供了内核帮助文档，这里支持很多种格式，这里我使用html的，使用sphinx编写，需要配置环境</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>安装依赖包</span><br><span class="line">apt-get install graphviz dvipng latexmk librsvg2-bin texlive-xetex</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>window10内核子系统需要额外安装,否则make menuconfig异常</span><br><span class="line">apt-get install python3-pip libncurses-dev flex bison libelf-dev</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>通过pip安装   sphinx_rtd_theme</span><br><span class="line"><span class="comment">#apt-get install python-pip</span></span><br><span class="line"><span class="comment">#pip install sphinx sphinx_rtd_theme</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/bin/pip&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    sys.<span class="keyword">exit</span>(main())</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python2.7/dist-packages/pip/__init__.py&quot;</span>, line <span class="number">16</span>, <span class="keyword">in</span> main</span><br><span class="line">    from pip._internal.utils.entrypoints import _wrapper</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python2.7/dist-packages/pip/_internal/utils/entrypoints.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from pip._internal.cli.main import main</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python2.7/dist-packages/pip/_internal/cli/main.py&quot;</span>, line <span class="number">60</span></span><br><span class="line">    sys.stderr.write(f<span class="string">&quot;ERROR: &#123;exc&#125;&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="regexp">//</span>pipe版本不对，需要升级到pip3.<span class="number">5</span></span><br><span class="line"><span class="comment">#wget https://bootstrap.pypa.io/pip/3.5/get-pip.py </span></span><br><span class="line"><span class="comment">#python3.5 get-pip.py</span></span><br><span class="line"><span class="comment">## whereis pip</span></span><br><span class="line">pip: <span class="regexp">/usr/</span>bin<span class="regexp">/pip /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/pip3.5 /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/pip /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/pip3.4 /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/pip2.7 /u</span>sr<span class="regexp">/share/m</span>an<span class="regexp">/man1/</span>pip.<span class="number">1</span>.gz</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>通过pip3.<span class="number">5</span>重新安装sphinx</span><br><span class="line"><span class="comment">#pip3.5 install sphinx sphinx_rtd_theme</span></span><br><span class="line">Installing collected packages: pytz, sphinxcontrib-serializinghtml, sphinxcontrib-qthelp, sphinxcontrib-jsmath, sphinxcontrib-htmlhelp, sphinxcontrib-devhelp, sphinxcontrib-applehelp, snowballstemmer, Pygments, packaging, imagesize, docutils, babel, alabaster, sphinx, sphinx-rtd-theme</span><br><span class="line">  Attempting uninstall: pytz</span><br><span class="line">    Found existing installation: pytz <span class="number">2014.10</span></span><br><span class="line">    Uninstalling pytz-<span class="number">2014.10</span>:</span><br><span class="line">      Successfully uninstalled pytz-<span class="number">2014.10</span></span><br><span class="line">Successfully installed Pygments-<span class="number">2.8</span>.<span class="number">1</span> alabaster-<span class="number">0.7</span>.<span class="number">12</span> babel-<span class="number">2.9</span>.<span class="number">0</span> docutils-<span class="number">0.16</span> imagesize-<span class="number">1.2</span>.<span class="number">0</span> packaging-<span class="number">20.9</span> pytz-<span class="number">2021.1</span> snowballstemmer-<span class="number">2.1</span>.<span class="number">0</span> sphinx-<span class="number">3.5</span>.<span class="number">4</span> sphinx-rtd-theme-<span class="number">0.5</span>.<span class="number">2</span> sphinxcontrib-applehelp-<span class="number">1.0</span>.<span class="number">2</span> sphinxcontrib-devhelp-<span class="number">1.0</span>.<span class="number">2</span> sphinxcontrib-htmlhelp-<span class="number">1.0</span>.<span class="number">3</span> sphinxcontrib-jsmath-<span class="number">1.0</span>.<span class="number">1</span> sphinxcontrib-qthelp-<span class="number">1.0</span>.<span class="number">3</span> sphinxcontrib-serializinghtml-<span class="number">1.1</span>.<span class="number">4</span></span><br><span class="line"></span><br><span class="line">在Makefile下查看文档生成细节，mandocs已经不再支持</span><br><span class="line"><span class="regexp">//</span>生成内核文档html</span><br><span class="line"><span class="comment">#make htmldocs</span></span><br><span class="line"><span class="regexp">//</span>查看内核文档</span><br><span class="line">浏览器： Documentation<span class="regexp">/output/i</span>ndex.html</span><br></pre></td></tr></table></figure>



<h3 id="内核功能配置文件"><a href="#内核功能配置文件" class="headerlink" title="内核功能配置文件"></a>内核功能配置文件</h3><p>编译前确定清除之前遗留的配置文件</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">make mrproper</span></span><br></pre></td></tr></table></figure>

<p>最好使用本机系统使用的配置文件，从/boot/config-4.4.0-210-generic copy到 编译根目录.config</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cp</span> /boot/config-<span class="number">4</span>.<span class="number">4</span>.<span class="number">0</span>-<span class="number">210</span>-generic  /github/linux/.config</span><br></pre></td></tr></table></figure>

<p>以图形界面的方式选择内核功能</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span> menuconfig  &gt;我们在我们<span class="built_in">copy</span>过来的配置上增加修改，配置完成保存下来的和<span class="built_in">copy</span>过来的不是完全一样的</span><br></pre></td></tr></table></figure>

<p>这里我们针对我们之后需要的调试做配置修改<br>确定增加kdb和kgdb支持</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">确定CONFIG_GDB_SCRIPTS打开</span><br><span class="line">确定架构支持CONFIG_FRAME_POINTER</span><br><span class="line"><span class="comment">//kgdb</span></span><br><span class="line">CONFIG_FRAME_POINTER=<span class="symbol">y</span></span><br><span class="line">CONFIG_KGDB=<span class="symbol">y</span></span><br><span class="line">CONFIG_KGDB_SERIAL_CONSOLE=<span class="symbol">y</span></span><br><span class="line"><span class="comment">//kdb</span></span><br><span class="line">CONFIG_FRAME_POINTER=<span class="symbol">y</span></span><br><span class="line">CONFIG_KGDB=<span class="symbol">y</span></span><br><span class="line">CONFIG_KGDB_SERIAL_CONSOLE=<span class="symbol">y</span></span><br><span class="line">CONFIG_KGDB_KDB=<span class="symbol">y</span></span><br><span class="line">CONFIG_KDB_KEYBOARD=<span class="symbol">y</span></span><br></pre></td></tr></table></figure>

<p>增加initramfs编译到内核文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">CONFIG_BLK_DEV_INITRD</span>=y</span><br><span class="line"><span class="attr">CONFIG_INITRAMFS_SOURCE</span>=<span class="string">&quot;&quot;</span>    &gt;&gt;这里需要设置为空，不然当挂载分区时会一直挂不上，mount_root函数处理create_dev(<span class="string">&quot;/dev/root&quot;</span>, ROOT_DEV) 返回报错-<span class="number">2</span>,导致主动触发panic   panic(<span class="string">&quot;VFS: Unable to mount root fs on %s&quot;</span>, b)<span class="comment">;</span></span><br><span class="line"><span class="attr">CONFIG_INITRAMFS_ROOT_UID</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">CONFIG_INITRAMFS_ROOT_GID</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h3><p>完整的内核编译生成</p>
<ol>
<li>符号映射表，我们可以通过这个在内核运行异常时去根据符号找到对应的变量名   编译根目录System.map</li>
<li>压缩引导内核bzImage,属于gzip压缩的vmlinuz,不是ELF的vmlinux</li>
<li>虚拟文件系统，用来引导早期运行的驱动等，比如SCSI硬盘需要模块化，加载模块需要在根目录，但是此时硬盘根本无法使用，目录树不存在，故使用initrd来新建虚拟文件系统，仿真成为根目录，initrd.img-xxxx  需要mkinitrd生成</li>
</ol>
<p>编译引导内核</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">make</span> <span class="selector-tag">bzImage</span>     <span class="selector-tag">path</span><span class="comment">// arch/x86/boot/</span></span><br><span class="line"><span class="comment">//非 ELF文件，gzip特殊压缩的引导文件</span></span><br><span class="line"># <span class="selector-tag">file</span> <span class="selector-tag">bzImage</span> </span><br><span class="line"><span class="selector-tag">bzImage</span>: <span class="selector-tag">Linux</span> <span class="selector-tag">kernel</span> <span class="selector-tag">x86</span> <span class="selector-tag">boot</span> <span class="selector-tag">executable</span> <span class="selector-tag">bzImage</span>, <span class="selector-tag">version</span> <span class="selector-tag">5</span><span class="selector-class">.12</span><span class="selector-class">.0-rc8</span>+ (root<span class="variable">@sholck</span>) <span class="selector-id">#1</span> <span class="selector-tag">SMP</span> <span class="selector-tag">Fri</span> <span class="selector-tag">Apr</span> <span class="selector-tag">23</span> <span class="selector-tag">16</span><span class="selector-pseudo">:19</span><span class="selector-pseudo">:21</span> <span class="selector-tag">CST</span> <span class="selector-tag">2021</span>, <span class="selector-tag">RO-rootFS</span>, <span class="selector-tag">swap_dev</span> <span class="selector-tag">0x9</span>, <span class="selector-tag">Normal</span> <span class="selector-tag">VGA</span></span><br></pre></td></tr></table></figure>

<p>编译模块</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">make modules</span></span><br></pre></td></tr></table></figure>

<p>内核模块安装</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">make modules_install  模块copy到 /<span class="class"><span class="keyword">lib</span>/<span class="title">modules</span></span></span><br><span class="line">/<span class="class"><span class="keyword">lib</span>/<span class="title">modules</span>  <span class="comment">#ls</span></span></span><br><span class="line"><span class="number">4.4</span>.<span class="number">0</span>-<span class="number">148</span>-generic  <span class="number">4.4</span>.<span class="number">0</span>-<span class="number">210</span>-generic  <span class="number">5.12</span>.<span class="number">0</span>-rc8+</span><br></pre></td></tr></table></figure>

<p>创建虚拟文件系统</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"># mkinitramfs -o /<span class="keyword">boot</span>/initrd.img-5.12.0-rc8+ 5.12.0-rc8+</span><br><span class="line">#<span class="keyword">file</span> /<span class="keyword">boot</span>/initrd.img-5.12.0-rc8+</span><br><span class="line">/<span class="keyword">boot</span>/initrd.img-5.12.0-rc8+: ASCII cpio archive (SVR4 with <span class="keyword">no</span> <span class="keyword">CRC</span>)    &lt;&lt;实际使用报错</span><br><span class="line"></span><br><span class="line"><span class="comment">//window子系统WSL下执行</span></span><br><span class="line">#mkinitramfs -o /<span class="keyword">boot</span>/initrd.img-5.13.0-rc3+ 5.13.0-rc3+</span><br><span class="line">cryptsetup: <span class="keyword">ERROR</span>: Couldn&#x27;t resolve device rootfs</span><br><span class="line">cryptsetup: WARNING: Couldn&#x27;t determine root device</span><br><span class="line">grep: /proc/swaps: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br><span class="line">W: Couldn&#x27;t identify <span class="keyword">type</span> of root <span class="keyword">file</span> system <span class="keyword">for</span> fsck hook</span><br><span class="line"># <span class="keyword">file</span> /<span class="keyword">boot</span>/initrd.img-5.13.0-rc3+ &gt;&gt;格式不一样</span><br><span class="line">/<span class="keyword">boot</span>/initrd.img-5.13.0-rc3+: LZ4 compressed data (v0.1-v0.9)</span><br></pre></td></tr></table></figure>

<p>copy内核文件到boot</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">#cp arch<span class="regexp">/x86/</span>boot<span class="regexp">/bzImage /</span>boot/vmlinuz-<span class="number">5.12</span>.<span class="number">0</span>-rc8+ </span><br><span class="line">#cp .config <span class="regexp">/boot/</span>config-<span class="number">5.12</span>.<span class="number">0</span>-rc8+</span><br></pre></td></tr></table></figure>

<p>vmlinux 未压缩的内核ELF文件，not stripped，可以供gdb调试使用<br>stripped和 not stripped区别， stripped的程序没有符号表信息，相反no stripped的程序会更方便调试</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file vmlinux</span></span><br><span class="line"><span class="attribute">vmlinux</span>: ELF <span class="number">64</span>-bit LSB executable, x<span class="number">86</span>-<span class="number">64</span>, version <span class="number">1</span> (SYSV), statically linked, BuildID[sha<span class="number">1</span>]=<span class="number">3849</span>f<span class="number">6</span>b<span class="number">6</span>d<span class="number">84719</span>fc<span class="number">749595</span>fef<span class="number">84659843</span>f<span class="number">50</span>bb<span class="number">02</span>, not stripped</span><br></pre></td></tr></table></figure>

<p>压缩过后的vmlinux文件</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd arch/x86/boot/compressed</span></span><br><span class="line"><span class="comment"># file vmlinux.bin  </span></span><br><span class="line"><span class="attribute">vmlinux</span>.bin: ELF <span class="number">64</span>-bit LSB executable, x<span class="number">86</span>-<span class="number">64</span>, version <span class="number">1</span> (SYSV), statically linked, BuildID[sha<span class="number">1</span>]=<span class="number">5</span>c<span class="number">57</span>d<span class="number">3</span>fb<span class="number">9</span>d<span class="number">396</span>d<span class="number">1</span>a<span class="number">98</span>b<span class="number">4</span>a<span class="number">482</span>e<span class="number">5</span>e<span class="number">8</span>d<span class="number">5</span>d<span class="number">26543</span>bdc<span class="number">1</span>, stripped</span><br><span class="line"><span class="comment"># file vmlinux</span></span><br><span class="line"><span class="attribute">vmlinux</span>: ELF <span class="number">64</span>-bit LSB shared object, x<span class="number">86</span>-<span class="number">64</span>, version <span class="number">1</span> (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure>


<p><a id="3"></a></p>
<h2 id="qemu-guest-run"><a href="#qemu-guest-run" class="headerlink" title="qemu-guest-run"></a>qemu-guest-run</h2><p><a href="#0">回到主目录</a></p>
<p>先检查cpu是否支持虚拟化</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"># egrep -c <span class="string">&#x27;(svm|vmx)&#x27;</span> <span class="regexp">/proc/</span>cpuinfo</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>检查本机已经加载的虚拟化模块</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># lsmod |grep -n <span class="string">&quot;kvm&quot;</span></span><br><span class="line"><span class="number">15</span>:kvm_intel             <span class="number">176128</span>  <span class="number">0</span></span><br><span class="line"><span class="number">39</span>:kvm                   <span class="number">561152</span>  <span class="number">1</span> kvm_intel</span><br><span class="line"><span class="number">42</span>:irqbypass              <span class="number">16384</span>  <span class="number">1</span> kvm</span><br><span class="line"><span class="comment">//如果没有，执行modprobe kvm和 modprobe kvm_intel, /dev下会有一个kvm的字符设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//window子系统WSL下执行lsmod异常</span></span><br></pre></td></tr></table></figure>
<p>qemu依赖包安装</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">apt-get <span class="keyword">install </span>qemu qemu-kvm libvirt-<span class="keyword">bin </span>virt-manager <span class="keyword">bridge-utils </span>-y</span><br></pre></td></tr></table></figure>

<p>检查qemu-kvm是否安装成功</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"># virsh -c qemu:///system list</span><br><span class="line"><span class="code"> Id    名称                         状态</span></span><br><span class="line">----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>本次测试使用initramfs来运行<br>我们需要将initramfs加载到内存rootfs，启动init进程</p>
<p>编写init代码，并打包到cpio中</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">cat &gt; hello.c &lt;&lt; EOF</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  printf(<span class="string">&quot;Hello world!\n&quot;</span>)<span class="comment">;</span></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">999999999</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#gcc -static hello.c -o init</span></span><br><span class="line"><span class="meta">#echo init | cpio -o -H newc | gzip &gt; test.cpio.gz</span></span><br><span class="line"><span class="meta">#echo init | cpio -o -H newc  &gt; test.cpio</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># file test.cpio</span></span><br><span class="line">test.cpio: ASCII cpio archive (SVR4 <span class="keyword">with</span> no CRC)</span><br><span class="line"><span class="meta"># file test.cpio.gz </span></span><br><span class="line">test.cpio.gz: gzip compressed data, last modified: Mon Apr <span class="number">26</span> <span class="number">08</span>:<span class="number">21</span>:<span class="number">00</span> <span class="number">2021</span>, from Unix</span><br></pre></td></tr></table></figure>

<p>执行测试</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//命令行模式，init执行玩会卡住，正常设计逻辑</span><br><span class="line">qemu-system-x86_64 -m 2G -enable-kvm -initrd test.cpio -kernel vmlinuz-5.12.0-rc8+ -s -append &quot;console=ttyS0 rdinit=init loglevel=8&quot;  -nographic   </span><br><span class="line">//窗口模式  ctrl+alt+f推出qemu窗口  ctrl+alt+g释放鼠标</span><br><span class="line">qemu-system-x86_64 -m 2G -enable-kvm -initrd test.cpio -kernel vmlinuz-5.12.0-rc8+ -s -append &quot;rdinit=init loglevel=8&quot;</span><br><span class="line"></span><br><span class="line">//-m 指定guest 运行内存,默认为128M</span><br><span class="line">对应报错</span><br><span class="line">warning: TCG doesn&#x27;t support requested feature: CPUID.01H:ECX.vmx [bit 5]</span><br><span class="line">qemu: fatal: Trying to <span class="keyword">execute</span> code outside RAM <span class="keyword">or</span> ROM <span class="keyword">at</span> <span class="number">0x00000000000b17f3</span></span><br><span class="line"></span><br><span class="line">//-kernel 指定bzImage，不能是ELF的vmlinux</span><br><span class="line">对应报错</span><br><span class="line">qemu: linux kernel too <span class="keyword">old</span> <span class="keyword">to</span> <span class="keyword">load</span> a ram disk</span><br><span class="line"></span><br><span class="line">//-initrd 指定cpio包，gzip -d 压缩或者不压缩都行, 我们自己制作</span><br><span class="line">对应报错</span><br><span class="line">Trying <span class="keyword">to</span> unpack rootfs image <span class="keyword">as</span> initramfs...</span><br><span class="line">Initramfs unpacking <span class="keyword">failed</span>: write <span class="keyword">error</span></span><br><span class="line"></span><br><span class="line">// -s gdbserver端口，gdb可以通过这个端口和guest连接</span><br><span class="line"></span><br><span class="line">//rdinit=init,指定rootfs下init的程序</span><br><span class="line">正确打印：</span><br><span class="line"> Run init <span class="keyword">as</span> init process  init作为init进程</span><br><span class="line">   <span class="keyword">with</span> arguments:</span><br><span class="line">     init  </span><br><span class="line">   <span class="keyword">with</span> environment:</span><br><span class="line">     HOME=/</span><br><span class="line">     TERM=linux</span><br><span class="line">Hello world!</span><br><span class="line"></span><br><span class="line">//如果kernel没有找到init进程，便会去解析参数root=,挂载另一个文件系统，将initrd image写入到 ram disk设备，这个时候需要指定root=作为ram disk</span><br><span class="line"><span class="keyword">Failed</span> <span class="keyword">to</span> <span class="keyword">create</span> /dev/root: <span class="number">-2</span></span><br><span class="line">VFS: Cannot <span class="keyword">open</span> root device <span class="string">&quot;(null)&quot;</span> <span class="keyword">or</span> <span class="literal">unknown</span>-<span class="keyword">block</span>(<span class="number">0</span>,<span class="number">0</span>): <span class="keyword">error</span> <span class="number">-2</span></span><br><span class="line">Kernel panic - <span class="keyword">not</span> syncing: VFS: Unable <span class="keyword">to</span> <span class="keyword">mount</span> root fs <span class="keyword">on</span> <span class="literal">unknown</span>-<span class="keyword">block</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>结果展示，WSL运行，ubuntu主机抄的原主机的config配置，没有Hello world打印<br><img src="/images/linux/init-hello.png" alt="alt"></p>
<p><a id="4"></a></p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p><a href="#0">回到主目录</a></p>
<p>针对gdb调试，需要导入其包含符号表的vmlinux<br>符号表单独保存在一个文件System.map</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#gdb</span></span><br><span class="line">file vmlinux</span><br><span class="line">或者</span><br><span class="line"><span class="meta">#gdb vmlinux</span></span><br></pre></td></tr></table></figure>

<p>连接guest的gdb server</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(gdb) target remote:<span class="number">1234</span></span><br><span class="line">Remote debugging using :<span class="number">1234</span></span><br><span class="line"><span class="number">0xffffffffb9a7ce6e</span> <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure>

<p>设置断点</p>
<blockquote>
<p>符号表对应 ffffffff82ce4bdb T start_kernel</p>
</blockquote>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">b</span> start_kernel</span><br><span class="line"><span class="attribute">Note</span>: breakpoint <span class="number">2</span> also set at pc <span class="number">0</span>xffffffff<span class="number">82</span>ce<span class="number">4</span>bdb. </span><br><span class="line"><span class="attribute">Breakpoint</span> <span class="number">3</span> at <span class="number">0</span>xffffffff<span class="number">82</span>ce<span class="number">4</span>bdb: file init/main.c, line <span class="number">853</span></span><br></pre></td></tr></table></figure>

<p><a id="5"></a></p>
<h2 id="BusyBox"><a href="#BusyBox" class="headerlink" title="BusyBox"></a>BusyBox</h2><p><a href="#0">回到主目录</a></p>
<p><a href="https://busybox.net/">busybox下载地址</a><br>下载完成tar -jxvf解压到/github/busybox</p>
<p>同kernel,配置文件为.config  </p>
<h3 id="配置安装"><a href="#配置安装" class="headerlink" title="配置安装"></a>配置安装</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">清除配置：<span class="keyword">make</span> mrproper</span><br><span class="line">配置confi<span class="variable">g:</span> <span class="keyword">make</span> menuconfig</span><br><span class="line">编译：<span class="keyword">make</span> -j12</span><br><span class="line">安装: <span class="keyword">make</span> install  </span><br><span class="line">安装成功提示：</span><br><span class="line">You will probably need <span class="keyword">to</span> <span class="keyword">make</span> your busybox binary</span><br><span class="line">setuid root <span class="keyword">to</span> ensure <span class="keyword">all</span> configured applets will</span><br><span class="line">work properly.</span><br></pre></td></tr></table></figure>

<h3 id="制作initramfs"><a href="#制作initramfs" class="headerlink" title="制作initramfs"></a>制作initramfs</h3><p>制作步骤：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mkdir -p initramfs/x86-busybox</span></span><br><span class="line"><span class="comment">#cd initramfs/x86-busybox</span></span><br><span class="line"><span class="comment">#mkdir -p &#123;bin,sbin,etc,proc,sys,usr/&#123;bin,sbin&#125;&#125;  创建一下文件夹</span></span><br><span class="line"></span><br><span class="line">//补充以下，若无会导致本地ubuntu16的qemu启动的内核无echo日志输出，并直接进入 因为init退出触发的Kernel panic:  not syncing: Attempted to kill init</span><br><span class="line">//WSL没有以下内核启动依旧可以进入虚拟文件系统</span><br><span class="line"><span class="comment">#mkdir dev</span></span><br><span class="line"><span class="comment">#cp -a /dev/&#123;null,console,tty,tty1,tty2,tty3,tty4&#125; dev/.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cp -a /github/busybox/busybox-1.33.1/_install/* .  // -a等价于 -pdr  递归赋值文件，保留文件属性，软连接文件复制</span></span><br><span class="line"><span class="comment">#find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; initramfs-busybox-x86.cpio.gz  //打包</span></span><br><span class="line"></span><br><span class="line">//创建init进程 sh脚本解释器使用sh，非bash,否则允许报错Failed to execute init (<span class="keyword">error</span> <span class="number">-2</span>)</span><br><span class="line"><span class="comment">#cat &gt; init&lt;&lt; EOF</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">mount -t <span class="keyword">proc</span><span class="title"> none</span> /<span class="keyword">proc</span></span><br><span class="line">mount -t<span class="title"> sysfs</span> none /sys</span><br><span class="line">echo -e &quot;\nBoot<span class="title"> took</span> $(cut -d&#x27; &#x27; -f1 /<span class="keyword">proc</span>/uptime)<span class="title"> seconds\n&quot;</span></span><br><span class="line"><span class="title">exec</span> /bin/sh</span><br><span class="line">EOF</span><br><span class="line">#chmod<span class="title"> u+x</span> init</span><br><span class="line">//运行</span><br><span class="line">#qemu-system-x86_64 -m 2G  -initrd<span class="title"> initramfs-busybox-x86.cpio.gz</span> -kernel ../vmlinuz-5.13.0-rc3+ -s -append &quot;console=ttyS0<span class="title"> rdinit=init</span> loglevel=8&quot;  -nographic  2&gt;&amp;1 |<span class="title"> tee</span> build.log </span><br></pre></td></tr></table></figure>
<p>使用busybox编译出来的initramfs报错，因为没有把init文件放置在initramfs/x86-busybox，导致打包时没有打包进去</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[    <span class="number">3.464451</span>] <span class="attr">md:</span> <span class="string">Waiting</span> <span class="string">for</span> <span class="string">all</span> <span class="string">devices</span> <span class="string">to</span> <span class="string">be</span> <span class="string">available</span> <span class="string">before</span> <span class="string">autodetect</span></span><br><span class="line">[    <span class="number">3.465100</span>] <span class="attr">md:</span> <span class="string">If</span> <span class="string">you</span> <span class="string">don&#x27;t</span> <span class="string">use</span> <span class="string">raid,</span> <span class="string">use</span> <span class="string">raid=noautodetect</span></span><br><span class="line">[    <span class="number">3.465719</span>] <span class="attr">md:</span> <span class="string">Autodetecting</span> <span class="string">RAID</span> <span class="string">arrays.</span></span><br><span class="line">[    <span class="number">3.466213</span>] <span class="attr">md:</span> <span class="string">autorun</span> <span class="string">...</span></span><br><span class="line">[    <span class="number">3.466446</span>] <span class="attr">md:</span> <span class="string">...</span> <span class="string">autorun</span> <span class="string">DONE.</span></span><br><span class="line">[    <span class="number">3.477954</span>] <span class="string">modprobe</span> <span class="string">(67)</span> <span class="attr">used greatest stack depth:</span> <span class="number">14688</span> <span class="string">bytes</span> <span class="string">left</span></span><br><span class="line">[    <span class="number">3.479263</span>] <span class="attr">VFS:</span> <span class="string">Cannot</span> <span class="string">open</span> <span class="string">root</span> <span class="string">device</span> <span class="string">&quot;(null)&quot;</span> <span class="string">or</span> <span class="string">unknown-block(0,0):</span> <span class="string">error</span> <span class="number">-6</span></span><br><span class="line">[    <span class="number">3.480054</span>] <span class="string">Please</span> <span class="string">append</span> <span class="string">a</span> <span class="string">correct</span> <span class="string">&quot;root=&quot;</span> <span class="string">boot</span> <span class="string">option;</span> <span class="attr">here are the available partitions:</span></span><br><span class="line">[    <span class="number">3.481083</span>] <span class="string">0b00</span>         <span class="number">1048575</span> <span class="string">sr0</span></span><br><span class="line">[    <span class="number">3.481213</span>]  <span class="attr">driver:</span> <span class="string">sr</span></span><br><span class="line">[    <span class="number">3.481794</span>] <span class="attr">Kernel panic - not syncing: VFS:</span> <span class="string">Unable</span> <span class="string">to</span> <span class="string">mount</span> <span class="string">root</span> <span class="string">fs</span> <span class="string">on</span> <span class="string">unknown-block(0,0)</span></span><br><span class="line"></span><br><span class="line"><span class="string">以上错误是因为kernel没有找到init进程，便会去解析参数root=,挂载另一个文件系统，将initrd</span> <span class="string">image写入到</span> <span class="string">ram</span> <span class="string">disk设备，这个时候需要指定root=作为ram</span> <span class="string">disk</span></span><br></pre></td></tr></table></figure>
<p>正确打包再执行一次<br><img src="/images/linux/busybox-enter-console.png" alt="alt"><br>控制台执行exit以后会进入kernel crash，trace如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[  137.134655]</span> Kernel panic - <span class="keyword">not</span> syncing: Attempted to kill init! exitcode=<span class="number">0x00000000</span></span><br><span class="line"><span class="string">[  137.135538]</span> CPU: <span class="number">0</span> PID: <span class="number">1</span> Comm: sh Not tainted <span class="number">5.13</span><span class="number">.0</span>-rc3+ #<span class="number">1</span></span><br><span class="line"><span class="string">[  137.136020]</span> Hardware name: QEMU Standard PC (i440FX + PIIX, <span class="number">1996</span>), BIOS <span class="number">1.13</span><span class="number">.0</span><span class="number">-1</span>ubuntu1<span class="number">.1</span> <span class="number">04</span>/<span class="number">01</span>/<span class="number">2014</span></span><br><span class="line"><span class="string">[  137.136867]</span> Call Trace:</span><br><span class="line"><span class="string">[  137.138242]</span>  dump_stack+<span class="number">0x64</span>/<span class="number">0x7c</span></span><br><span class="line"><span class="string">[  137.138576]</span>  panic+<span class="number">0xf6</span>/<span class="number">0x2b7</span></span><br><span class="line"><span class="string">[  137.138765]</span>  ? set_next_entity+<span class="number">0x98</span>/<span class="number">0x160</span></span><br><span class="line"><span class="string">[  137.139003]</span>  do_exit.cold+<span class="number">0xa0</span>/<span class="number">0xe3</span></span><br><span class="line"><span class="string">[  137.139205]</span>  do_group_exit+<span class="number">0x35</span>/<span class="number">0x90</span></span><br><span class="line"><span class="string">[  137.139412]</span>  __x64_sys_exit_group+<span class="number">0xf</span>/<span class="number">0x10</span></span><br><span class="line"><span class="string">[  137.139682]</span>  do_syscall_64+<span class="number">0x40</span>/<span class="number">0x80</span></span><br><span class="line"><span class="string">[  137.139896]</span>  entry_SYSCALL_64_after_hwframe+<span class="number">0x44</span>/<span class="number">0xae</span></span><br><span class="line"><span class="string">[  137.140384]</span> RIP: <span class="number">0033</span>:<span class="number">0x495f96</span></span><br><span class="line"><span class="string">[  137.140834]</span> Code: fa <span class="number">41</span> b8 e7 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> be <span class="number">3</span>c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> eb <span class="number">15</span> <span class="number">66</span> <span class="number">0f</span> <span class="number">1f</span> <span class="number">44</span> <span class="number">00</span> <span class="number">00</span> <span class="number">89</span> d7 <span class="number">89</span> f0 <span class="number">0f</span> <span class="number">05</span> <span class="number">48</span> <span class="number">3</span>d <span class="number">00</span> f0 ff ff <span class="number">77</span> <span class="number">22</span> f4 <span class="number">89</span> d7 <span class="number">44</span> <span class="number">89</span> c0 <span class="number">0f</span> <span class="number">05</span> &lt;<span class="number">48</span>&gt; <span class="number">3</span>d <span class="number">00</span> f0</span><br><span class="line"><span class="string">[  137.142124]</span> RSP: <span class="number">002</span>b:<span class="number">00007f</span>ff3d497458 EFLAGS: <span class="number">00000202</span> ORIG_RAX: <span class="number">00000000000000e7</span></span><br><span class="line"><span class="string">[  137.142598]</span> RAX: ffffffffffffffda RBX: <span class="number">0000000001</span>a4a004 RCX: <span class="number">0000000000495f</span>96</span><br><span class="line"><span class="string">[  137.142986]</span> RDX: <span class="number">0000000000000000</span> RSI: <span class="number">000000000000003</span>c RDI: <span class="number">0000000000000000</span></span><br><span class="line"><span class="string">[  137.143379]</span> RBP: <span class="number">0000000000000004</span> R08: <span class="number">00000000000000e7</span> R09: ffffffffffffffe0</span><br><span class="line"><span class="string">[  137.143764]</span> R10: <span class="number">0000000001</span>a4bf10 R11: <span class="number">0000000000000202</span> R12: <span class="number">00007f</span>ff3d497828</span><br><span class="line"><span class="string">[  137.144145]</span> R13: <span class="number">0000000000000000</span> R14: <span class="number">0000000000000001</span> R15: <span class="number">0000000000000000</span></span><br><span class="line"><span class="string">[  137.145227]</span> Kernel Offset: <span class="number">0x24600000</span> <span class="keyword">from</span> <span class="number">0xffffffff81000000</span> (relocation range: <span class="number">0xffffffff80000000</span><span class="number">-0xffffffffbfffffff</span>)</span><br><span class="line"><span class="string">[  137.146167]</span> ---[ end Kernel panic - <span class="keyword">not</span> syncing: Attempted to kill init! exitcode=<span class="number">0x00000000</span> ]---</span><br></pre></td></tr></table></figure>
<p>当init进程退出时，触发panic<br><img src="/images/linux/init-process-exit-trigger-panic.png" alt="alt"></p>
<p><a id="6"></a></p>
<h2 id="Crash"><a href="#Crash" class="headerlink" title="Crash"></a>Crash</h2><p>因为需要将转储内核将存储在文件分区中，因此需要使用rootfs来挂载，initramfs是只存在内存中的。</p>
<h3 id="配置rootfs-kexec环境"><a href="#配置rootfs-kexec环境" class="headerlink" title="配置rootfs kexec环境"></a>配置rootfs kexec环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  package get http://kernel.org/pub/linux/utils/kernel/kexec/kexec-tools.tar.gz</span><br><span class="line">➜  package tar -zxvf kexec-tools.tar.gz</span><br><span class="line">➜  package cd kexec-tools-2.0.23 </span><br><span class="line">➜  package LDFLAGS=-static ./configure ARCH=x86_64 --build=x86_64-linux-gnu --host=x86-64-linux-gnu --target=x86_64-linux-gnu --without-xen &gt;&gt;交叉编译</span><br><span class="line">➜  package make</span><br><span class="line">➜  package cd build</span><br><span class="line">➜  build cp -r man /github/busybox/initramfs/x86-busybox-rootfs/.</span><br><span class="line">➜  build cp -r lib /github/busybox/initramfs/x86-busybox-rootfs/.</span><br><span class="line">➜  build cp -r sbin /github/busybox/initramfs/x86-busybox-rootfs/.</span><br></pre></td></tr></table></figure>

<h3 id="构建rootfs镜像"><a href="#构建rootfs镜像" class="headerlink" title="构建rootfs镜像"></a>构建rootfs镜像</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">➜  build  cd <span class="regexp">/github/</span>busybox<span class="regexp">/initramfs/</span></span><br><span class="line">➜  initramfs dd <span class="keyword">if</span>=<span class="regexp">/dev/</span>zero of=rootfs.img bs=<span class="number">1</span>M count=<span class="number">8</span>k oflag=direct  <span class="regexp">//</span><span class="number">8</span>G大小, 要比运行内存要大，不然装不下转储内存</span><br><span class="line">➜  initramfs mkfs.ext4 rootfs.img &gt;&gt;设置文件系统格式</span><br><span class="line">➜  initramfs mkdir rootfs</span><br><span class="line">➜  initramfs mount rootfs.img rootfs</span><br><span class="line"><span class="regexp">//</span>下一步需要将我们需要的文件打包到rootfs分区，因为测试crash，当第二kernel启动时依旧需要引导内核，因此需要复制linux驱动引导内核到文件系统内</span><br><span class="line">➜  initramfs cd x86-busybox-rootfs </span><br><span class="line">➜  x86-busybox-rootfs cp <span class="regexp">/github/</span>linux<span class="regexp">/arch/</span>x86_64<span class="regexp">/boot/</span>bzImage <span class="regexp">/github/</span>busybox<span class="regexp">/initramfs/</span>x86-busybox-rootfs/vmlinuz-<span class="number">5.17</span>.<span class="number">0</span>+</span><br><span class="line">➜  x86-busybox-rootfs mkdir -p &#123;bin,sbin,etc,proc,sys,usr/&#123;bin,sbin&#125;&#125;</span><br><span class="line">➜  x86-busybox-rootfs mkdir dev</span><br><span class="line">➜  x86-busybox-rootfs cp -a <span class="regexp">/dev/</span>&#123;null,console,tty,tty1,tty2,tty3,tty4&#125; dev/.</span><br><span class="line">➜  x86-busybox-rootfs cp -a <span class="regexp">/github/</span>busybox<span class="regexp">/busybox-1.33.1/</span>_install/*</span><br><span class="line">➜  x86-busybox-rootfs cd ..</span><br><span class="line">➜  initramfs cp -r x86-busybox-rootfs<span class="regexp">/* rootfs/</span>.</span><br><span class="line"><span class="regexp">//</span>打包完成，退出挂载</span><br><span class="line">➜  initramfs umount rootfs </span><br><span class="line"><span class="regexp">//</span>检查此文件系统</span><br><span class="line">➜  initramfs e2fsck -p -f rootfs.img</span><br><span class="line">rootfs.img: <span class="number">441</span><span class="regexp">/262144 files (0.0% non-contiguous), 554776/</span><span class="number">1048576</span> blocks</span><br></pre></td></tr></table></figure>

<h3 id="安装最新的crash"><a href="#安装最新的crash" class="headerlink" title="安装最新的crash"></a>安装最新的crash</h3><p><a href="https://crash-utility.github.io/">crash官网</a></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>安装依赖</span><br><span class="line">sudo apt-get install texinfo  </span><br><span class="line"><span class="regexp">//</span>下载安装，最好通过github库编译安装</span><br><span class="line">wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/crash-utility/</span>crash<span class="regexp">/archive/</span><span class="number">8.0</span>.<span class="number">0</span>.tar.gz</span><br><span class="line">tar -zxvf crash-<span class="number">8.0</span>.<span class="number">0</span>.tar.gz</span><br><span class="line"><span class="regexp">//</span>安装，crash会自动下载匹配的gdb版本</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<h3 id="内核启动"><a href="#内核启动" class="headerlink" title="内核启动"></a>内核启动</h3><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">➜  initramfs qemu-system-x86_64 -m <span class="number">1024</span>  -smp <span class="number">2</span>  -hda rootfs.img  -kernel /kvm-qemu-system/linux-vmlinux/<span class="number">5.17</span><span class="number">.0</span>+/vmlinuz<span class="number">-5.17</span><span class="number">.0</span>+   -s -<span class="keyword">append</span> <span class="string">&quot;root=/dev/sda rdinit=init crashkernel=128M console=ttyS0 rw&quot;</span>  -nographic <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee build.log  &gt;&gt;需要增加rw获取全部权限</span><br><span class="line"></span><br><span class="line">mount -t <span class="keyword">proc</span><span class="title"> none</span> /<span class="keyword">proc</span></span><br><span class="line">mount -t<span class="title"> sysfs</span> none /sys  //挂载<span class="keyword">proc</span>和sys虚拟文件系统</span><br><span class="line"></span><br><span class="line">//检查crashkernel=128M是否有生效</span><br><span class="line">#<span class="title"> cat</span> /<span class="keyword">proc</span>/iomem</span><br><span class="line">...</span><br><span class="line">00001000-0009fbff :<span class="title"> System</span> RAM  //系统物理内存启始地址为0x00001000</span><br><span class="line">...</span><br><span class="line">b7000000-beffffff :<span class="title"> Crash</span> kernel //有专门为转储内存留出空间</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 设置kexec<span class="title"> command-line</span></span><br><span class="line"><span class="title">#</span> kexec -p --command-line=&quot;console=ttyS0<span class="title"> root=/dev/sda</span> rw&quot;<span class="title"> vmlinuz-5.17.0\+</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">//通过sysrq触发panic</span></span><br><span class="line"><span class="title">/</span> #<span class="title"> echo</span> c &gt;/<span class="keyword">proc</span>/sysrq-trigger</span><br><span class="line">[  190.613526]<span class="title"> sysrq:</span> Trigger<span class="title"> a</span> crash</span><br><span class="line">[  190.613757]<span class="title"> Kernel</span> panic -<span class="title"> not</span> syncing:<span class="title"> sysrq</span> triggered<span class="title"> crash</span></span><br><span class="line"><span class="title">...</span></span><br><span class="line"><span class="title">[</span>  190.619596]  &lt;/TASK&gt;</span><br><span class="line">[    0.000000]<span class="title"> Linux</span> version 5.17.0+ (root@sholck) (gcc (Ubuntu 6.5.0-2ubuntu1~16.04) 6.5.0 20181026,<span class="title"> GNU</span> ld (GNU<span class="title"> Binutils</span> for<span class="title"> Ubuntu)</span> 2.26.1) #7<span class="title"> SMP</span> PREEMPT_DYNAMIC<span class="title"> Thu</span> Mar 24 14:58:15<span class="title"> CST</span> 2022</span><br><span class="line">[    0.000000]<span class="title"> Command</span> line:<span class="title"> console=ttyS0</span> root=/dev/sda<span class="title"> rw</span> acpi_rsdp=0xf6440<span class="title"> elfcorehdr=3128692K</span>  &gt;&gt;第二内核启动</span><br><span class="line"></span><br><span class="line">mount -t<span class="title"> proc</span> none /<span class="keyword">proc</span></span><br><span class="line">mount -t<span class="title"> sysfs</span> none /sys  //重新挂载<span class="keyword">proc</span>和sys虚拟文件系统</span><br><span class="line"></span><br><span class="line">//copy 转储内存到本地</span><br><span class="line">cp /<span class="keyword">proc</span>/vmcore /.</span><br><span class="line">poweroff</span><br><span class="line"></span><br><span class="line">➜<span class="title">  initramfs</span> mount<span class="title"> rootfs.img</span> rootfs</span><br><span class="line">➜<span class="title">  initramfs</span> cd<span class="title"> rootfs</span> </span><br><span class="line">➜<span class="title">  rootfs</span> cp<span class="title"> vmcore</span> /kvm-qemu-system/linux-vmlinux/5.17.0+/vmcore</span><br><span class="line">➜<span class="title">  initramfs</span> umount<span class="title"> rootfs</span></span><br></pre></td></tr></table></figure>

<h3 id="转储分析"><a href="#转储分析" class="headerlink" title="转储分析"></a>转储分析</h3><p>通过crash对copy到本地的转储分析</p>
<p>crash最好升级到最新，不然可能出现以下问题</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">➜  5.17.0+ crash<span class="emphasis">_x86_</span>64  vmlinux vmcore</span><br><span class="line"></span><br><span class="line"><span class="symbol">WARNING: </span>kernel relocated [928MB]: patching 127077 gdb minimal<span class="emphasis">_symbol values</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">please wait... (patching 127077 gdb minimal_</span>symbol values) [1]    6126 segmentation fault (core dumped)  crash<span class="emphasis">_x86_</span>64 -m phys<span class="emphasis">_offset=0x10000 vmlinux vmcore   &gt;&gt;分析失败，升级crash修复</span></span><br><span class="line"><span class="emphasis"></span></span><br></pre></td></tr></table></figure>

<p>重新升级解析</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">➜</span>  <span class="string">rootfs</span> <span class="string">crash</span> <span class="string">vmlinux</span> <span class="string">vmcore</span></span><br><span class="line"></span><br><span class="line"><span class="string">crash</span> <span class="number">8.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2002</span><span class="number">-2021</span>  <span class="string">Red</span> <span class="string">Hat,</span> <span class="string">Inc.</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2004</span><span class="string">,</span> <span class="number">2005</span><span class="string">,</span> <span class="number">2006</span><span class="string">,</span> <span class="number">2010  </span><span class="string">IBM</span> <span class="string">Corporation</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">1999</span><span class="number">-2006</span>  <span class="string">Hewlett-Packard</span> <span class="string">Co</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2005</span><span class="string">,</span> <span class="number">2006</span><span class="string">,</span> <span class="number">2011</span><span class="string">,</span> <span class="number">2012  </span><span class="string">Fujitsu</span> <span class="string">Limited</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2006</span><span class="string">,</span> <span class="number">2007  </span><span class="string">VA</span> <span class="string">Linux</span> <span class="string">Systems</span> <span class="string">Japan</span> <span class="string">K.K.</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2005</span><span class="string">,</span> <span class="number">2011</span><span class="string">,</span> <span class="number">2020</span><span class="number">-2021</span>  <span class="string">NEC</span> <span class="string">Corporation</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">1999</span><span class="string">,</span> <span class="number">2002</span><span class="string">,</span> <span class="number">2007  </span><span class="string">Silicon</span> <span class="string">Graphics,</span> <span class="string">Inc.</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">1999</span><span class="string">,</span> <span class="number">2000</span><span class="string">,</span> <span class="number">2001</span><span class="string">,</span> <span class="number">2002  </span><span class="string">Mission</span> <span class="string">Critical</span> <span class="string">Linux,</span> <span class="string">Inc.</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2015</span><span class="string">,</span> <span class="number">2021  </span><span class="string">VMware,</span> <span class="string">Inc.</span></span><br><span class="line"><span class="string">This</span> <span class="string">program</span> <span class="string">is</span> <span class="string">free</span> <span class="string">software,</span> <span class="string">covered</span> <span class="string">by</span> <span class="string">the</span> <span class="string">GNU</span> <span class="string">General</span> <span class="string">Public</span> <span class="string">License,</span></span><br><span class="line"><span class="string">and</span> <span class="string">you</span> <span class="string">are</span> <span class="string">welcome</span> <span class="string">to</span> <span class="string">change</span> <span class="string">it</span> <span class="string">and/or</span> <span class="string">distribute</span> <span class="string">copies</span> <span class="string">of</span> <span class="string">it</span> <span class="string">under</span></span><br><span class="line"><span class="string">certain</span> <span class="string">conditions.</span>  <span class="string">Enter</span> <span class="string">&quot;help copying&quot;</span> <span class="string">to</span> <span class="string">see</span> <span class="string">the</span> <span class="string">conditions.</span></span><br><span class="line"><span class="string">This</span> <span class="string">program</span> <span class="string">has</span> <span class="string">absolutely</span> <span class="literal">no</span> <span class="string">warranty.</span>  <span class="string">Enter</span> <span class="string">&quot;help warranty&quot;</span> <span class="string">for</span> <span class="string">details.</span></span><br><span class="line"> </span><br><span class="line"><span class="string">GNU</span> <span class="string">gdb</span> <span class="string">(GDB)</span> <span class="number">10.2</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2021 </span><span class="string">Free</span> <span class="string">Software</span> <span class="string">Foundation,</span> <span class="string">Inc.</span></span><br><span class="line"><span class="string">License</span> <span class="string">GPLv3+:</span> <span class="string">GNU</span> <span class="string">GPL</span> <span class="string">version</span> <span class="number">3</span> <span class="string">or</span> <span class="string">later</span> <span class="string">&lt;http://gnu.org/licenses/gpl.html&gt;</span></span><br><span class="line"><span class="attr">This is free software:</span> <span class="string">you</span> <span class="string">are</span> <span class="string">free</span> <span class="string">to</span> <span class="string">change</span> <span class="string">and</span> <span class="string">redistribute</span> <span class="string">it.</span></span><br><span class="line"><span class="string">There</span> <span class="string">is</span> <span class="literal">NO</span> <span class="string">WARRANTY,</span> <span class="string">to</span> <span class="string">the</span> <span class="string">extent</span> <span class="string">permitted</span> <span class="string">by</span> <span class="string">law.</span></span><br><span class="line"><span class="string">Type</span> <span class="string">&quot;show copying&quot;</span> <span class="string">and</span> <span class="string">&quot;show warranty&quot;</span> <span class="string">for</span> <span class="string">details.</span></span><br><span class="line"><span class="string">This</span> <span class="string">GDB</span> <span class="string">was</span> <span class="string">configured</span> <span class="string">as</span> <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span><span class="string">.</span></span><br><span class="line"><span class="string">Type</span> <span class="string">&quot;show configuration&quot;</span> <span class="string">for</span> <span class="string">configuration</span> <span class="string">details.</span></span><br><span class="line"><span class="attr">Find the GDB manual and other documentation resources online at:</span></span><br><span class="line">    <span class="string">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span></span><br><span class="line"></span><br><span class="line"><span class="string">For</span> <span class="string">help,</span> <span class="string">type</span> <span class="string">&quot;help&quot;</span><span class="string">.</span></span><br><span class="line"><span class="string">Type</span> <span class="string">&quot;apropos word&quot;</span> <span class="string">to</span> <span class="string">search</span> <span class="string">for</span> <span class="string">commands</span> <span class="string">related</span> <span class="string">to</span> <span class="string">&quot;word&quot;</span><span class="string">...</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">KERNEL:</span> <span class="string">vmlinux</span>                           </span><br><span class="line">    <span class="attr">DUMPFILE:</span> <span class="string">vmcore</span></span><br><span class="line">        <span class="attr">CPUS:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">DATE:</span> <span class="string">Fri</span> <span class="string">Mar</span> <span class="number">25</span> <span class="number">18</span><span class="string">:00:11</span> <span class="string">CST</span> <span class="number">2022</span></span><br><span class="line">      <span class="attr">UPTIME:</span> <span class="number">00</span><span class="string">:03:52</span></span><br><span class="line"><span class="attr">LOAD AVERAGE:</span> <span class="number">0.00</span><span class="string">,</span> <span class="number">0.00</span><span class="string">,</span> <span class="number">0.00</span></span><br><span class="line">       <span class="attr">TASKS:</span> <span class="number">69</span></span><br><span class="line">    <span class="attr">NODENAME:</span> <span class="string">(none)</span></span><br><span class="line">     <span class="attr">RELEASE:</span> <span class="number">5.17</span><span class="number">.0</span><span class="string">+</span></span><br><span class="line">     <span class="attr">VERSION:</span> <span class="comment">#11 SMP PREEMPT_DYNAMIC Fri Mar 25 17:52:02 CST 2022</span></span><br><span class="line">     <span class="attr">MACHINE:</span> <span class="string">x86_64</span>  <span class="string">(3191</span> <span class="string">Mhz)</span></span><br><span class="line">      <span class="attr">MEMORY:</span> <span class="number">1</span> <span class="string">GB</span></span><br><span class="line">       <span class="attr">PANIC:</span> <span class="string">&quot;Kernel panic - not syncing: sysrq triggered crash&quot;</span></span><br><span class="line">         <span class="attr">PID:</span> <span class="number">99</span></span><br><span class="line">     <span class="attr">COMMAND:</span> <span class="string">&quot;sh&quot;</span></span><br><span class="line">        <span class="attr">TASK:</span> <span class="string">ffff944341f24000</span>  [<span class="attr">THREAD_INFO:</span> <span class="string">ffff944341f24000</span>]</span><br><span class="line">         <span class="attr">CPU:</span> <span class="number">1</span></span><br><span class="line">       <span class="attr">STATE:</span> <span class="string">TASK_RUNNING</span> <span class="string">(PANIC)</span></span><br><span class="line"><span class="string">crash&gt;</span> <span class="string">bt</span></span><br><span class="line"><span class="attr">PID: 99     TASK: ffff944341f24000  CPU: 1   COMMAND:</span> <span class="string">&quot;sh&quot;</span></span><br><span class="line"> <span class="comment">#0 [ffffa7de404e3cb8] machine_kexec at ffffffffb806b8bf</span></span><br><span class="line"> <span class="comment">#1 [ffffa7de404e3d10] __crash_kexec at ffffffffb8154afd</span></span><br><span class="line"> <span class="comment">#2 [ffffa7de404e3dd8] panic at ffffffffb8af2dd2</span></span><br><span class="line"> <span class="comment">#3 [ffffa7de404e3e60] sysrq_handle_crash at ffffffffb86c42c6</span></span><br><span class="line"> <span class="comment">#4 [ffffa7de404e3e68] __handle_sysrq at ffffffffb86c46e8</span></span><br><span class="line"> <span class="comment">#5 [ffffa7de404e3e98] write_sysrq_trigger at ffffffffb86c4c2b</span></span><br><span class="line"> <span class="comment">#6 [ffffa7de404e3ea8] proc_reg_write at ffffffffb83b4c36</span></span><br><span class="line"> <span class="comment">#7 [ffffa7de404e3ec0] vfs_write at ffffffffb8310d93</span></span><br><span class="line"> <span class="comment">#8 [ffffa7de404e3ef8] ksys_write at ffffffffb83110ec</span></span><br><span class="line"> <span class="comment">#9 [ffffa7de404e3f38] do_syscall_64 at ffffffffb8afd11a</span></span><br><span class="line"><span class="comment">#10 [ffffa7de404e3f50] entry_SYSCALL_64_after_hwframe at ffffffffb8c0007c</span></span><br><span class="line">    <span class="attr">RIP: 00000000004bd8b0  RSP: 00007ffca4226bf8  RFLAGS:</span> <span class="number">00000246</span></span><br><span class="line">    <span class="attr">RAX: ffffffffffffffda  RBX: 0000000001a6d860  RCX:</span> <span class="string">00000000004bd8b0</span></span><br><span class="line">    <span class="attr">RDX: 0000000000000002  RSI: 0000000001a71500  RDI:</span> <span class="number">0000000000000001</span></span><br><span class="line">    <span class="attr">RBP: 0000000000000001   R8: fefefefefefefeff   R9:</span> <span class="string">fefefeff00a4ff62</span></span><br><span class="line">    <span class="attr">R10: 0000000000464e00  R11: 0000000000000246  R12:</span> <span class="string">0000000001a71500</span></span><br><span class="line">    <span class="attr">R13: 0000000000000002  R14: 0000000000000001  R15:</span> <span class="number">0000000000000000</span></span><br><span class="line">    <span class="attr">ORIG_RAX: 0000000000000001  CS: 0033  SS:</span> <span class="string">002b</span></span><br></pre></td></tr></table></figure>

<p><a id="7"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wipan/p/9272255.html">在qemu上运行BusyBox</a><br><a href="https://consen.github.io/2018/01/17/debug-linux-kernel-with-qemu-and-gdb/">使用QEMU和GDB调试Linux内核</a><br><a href="https://blog.csdn.net/u011011827/article/details/111227545">VFS: Cannot open root device 解决思路</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内核编译</tag>
        <tag>busybox</tag>
        <tag>QEMU</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
</search>
