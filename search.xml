<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Camx-Feature2</title>
    <url>/archives/8a2ade18.html</url>
    <content><![CDATA[<h1 id="Feature2"><a href="#Feature2" class="headerlink" title="Feature2"></a>Feature2</h1><p>当我们想要去实现特定功能的时候，我们需要使用FGM管理实现feature功能的各类组件 并根据feature拓扑创建对应的pipeline去实现，这些组件包括FGS,FPM,线程池，TBM。本篇文章将从feature组件的创建以及各组件的功能组合如何实现特定feature来描述，而关联<a href="https://sholck.top/archives/8a2ade15.html">底层的pipeline建立和node处理</a>，<a href="https://sholck.top/archives/8a2ade14.html">PCR逻辑</a>已经在其他文章详细描述，本文不再重新描述。</p>
<ul>
<li><a href="#1">feature2框架介绍</a></li>
<li><a href="#2">configure_stream</a></li>
<li><a href="#3">feature instance connect</a></li>
<li><a href="#4">callback</a></li>
<li><a href="#5">TBM详解</a></li>
<li><a href="#6">TM详解</a></li>
</ul>
<p><a id="1"></a></p>
<h2 id="feature2框架介绍"><a href="#feature2框架介绍" class="headerlink" title="feature2框架介绍"></a>feature2框架介绍</h2><p>下图feature2大致的组件框架。</p>
<p><img src="/images/feature2/feature2-frame.png" alt="alt"></p>
<a id="more"></a> 

<p><a id="2"></a></p>
<h2 id="configure-stream"><a href="#configure-stream" class="headerlink" title="configure_stream"></a>configure_stream</h2><p>在configure_stream阶段，主要为  </p>
<ol>
<li>Feature2Wrapper的创建  </li>
<li>Feature2GraphManager（FGM）和TargetBufferManager（TBM）的创建</li>
</ol>
<p>大致流程如下，不包括feature instance的initialize到finalized.</p>
<p><img src="/images/feature2/feature2-initialize.png" alt="alt"></p>
<h3 id="Feature2Wrapper的创建"><a href="#Feature2Wrapper的创建" class="headerlink" title="Feature2Wrapper的创建"></a>Feature2Wrapper的创建</h3><ol>
<li>针对部分usecase,根据下发的opMode，选择对应的feature场景，比如快拍支持</li>
</ol>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="function"><span class="params">(StreamConfigModeFastShutter == ExtensionModule::GetInstance()-&gt;GetOpMode(m_cameraId))</span></span></span><br><span class="line"><span class="function">&#123;    </span></span><br><span class="line"><span class="function">    <span class="title">enabledAdvanceFeatures</span> = <span class="title">AdvanceFeatureSWMF</span>|<span class="title">AdvanceFeatureMFNR</span>|<span class="title">AdvanceFeatureAIDE</span>;</span></span><br><span class="line"><span class="function">&#125;    </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>log如下</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">chxadvancedcamerausecase</span><span class="selector-class">.cpp</span><span class="selector-pseudo">:6513</span> <span class="selector-tag">SelectFeatures</span>() <span class="selector-tag">SelectFeatures</span>(), <span class="selector-tag">enabled</span> <span class="selector-tag">feature</span> <span class="selector-tag">mask</span><span class="selector-pseudo">:40</span></span><br><span class="line"><span class="selector-tag">chxadvancedcamerausecase</span><span class="selector-class">.cpp</span><span class="selector-pseudo">:6585</span> <span class="selector-tag">SelectFeatures</span>() <span class="selector-tag">num</span> <span class="selector-tag">features</span> <span class="selector-tag">selected</span><span class="selector-pseudo">:1</span>, <span class="selector-tag">FeatureType</span> <span class="selector-tag">for</span> <span class="selector-tag">preview</span><span class="selector-pseudo">:7</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>针对单双摄设置Fk stream,双摄额外设置主辅摄的internalInputStream，包括RDI和FD，这两个stream已经在mc usecase申请资源CreateMultiCameraResource中空间申请并填充。</li>
<li>Feature2Wrapper初始化<br>a. m_internalInputStreamMap  映射usecase内部的output stream到feature内部external stream,比如双摄的RDI stream<br>b. m_pFrameworkStreams 管理fk stream</li>
</ol>
<h3 id="FGM和TBM的创建"><a href="#FGM和TBM的创建" class="headerlink" title="FGM和TBM的创建"></a>FGM和TBM的创建</h3><h4 id="FGM创建"><a href="#FGM创建" class="headerlink" title="FGM创建"></a>FGM创建</h4><ol>
<li>设置该feature2wrapper的cb，用来处理PCR的处理</li>
<li>feature 的input stream指针空间单独copy，CloneStreamConfig申请空间过大，需check 并告知qcom</li>
<li>设置该FGMd的cb，处理chi的notify和feature的message</li>
<li>依次创建FGS，FPM，线程管理</li>
<li>pGetFGDListForConfig对FGS拿到的FGD和FPM从all feature instance中hook中拿到的cap中match和过滤</li>
<li>CreateVirtualSuperGraph对single feature graph进行过滤并整合为VirtualSuperGraph，同时确定包含的feature instance</li>
<li>对feature instance进行create,configure,Finalized</li>
</ol>
<h5 id="FGS创建"><a href="#FGS创建" class="headerlink" title="FGS创建"></a>FGS创建</h5><ol>
<li><p>通过LoadFeatureGraphSelectorOps和FGS库挂hook，hook为ChiFeature2GraphSelectorOpsEntry<br>，回调对象指针为m_feature2GraphSelectorOps。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chifeature2graphmanager</span>.cpp:<span class="number">345</span> LoadFeatureGraphSelectorOps() No graph selector library files found in the path /vendor/lib<span class="number">64</span>/camera/components/feature<span class="number">2</span>/oem</span><br><span class="line"><span class="attribute">chifeature2graphmanager</span>.cpp:<span class="number">365</span> LoadFeatureGraphSelectorOps() Loading from:/vendor/lib<span class="number">64</span>/com.qti.feature<span class="number">2</span>.gs.mannar.so, size:<span class="number">72</span>, pCreateOps:<span class="number">0</span>x<span class="number">736644</span>f<span class="number">658</span>K</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过pCreate进行FGS的create   </p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">a. BuildCameraIdSet根据全部逻辑id的类型分类，由m_cameraIdMap管理  cameraID<span class="comment">-----type</span></span><br><span class="line"></span><br><span class="line">b. 设置FGD Table的描述GraphDescriptorTables ，主要为三部分构成。 </span><br><span class="line">pCameraIdDescriptorNameSet  camera <span class="keyword">set</span> <span class="keyword">type</span>对应的一个FGDescriptorName集合</span><br><span class="line">pFeatureGraphDescriptorsMap  FGD <span class="keyword">name</span>到FDG 的映射</span><br><span class="line">pFeatureGraphDescKeysMap  包含camera <span class="keyword">set</span> <span class="keyword">type</span>和FDGnam等，用来表示该平台支持的feature <span class="keyword">instance</span>。</span><br><span class="line"></span><br><span class="line">c. rFeatureDescNameSet featureDescName集合的设置，根据<span class="keyword">memory</span>分别设置。  </span><br><span class="line">这三部分都是由两部分组成，OEM赋值和PopulateAllTables插入</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>FGS的initialze 通过AssignStreamIntentPerFwkStream针对FGS的输出流进行stream intent判定。enum ChiStreamIntent</li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chifeature2graphselector</span>.cpp:<span class="number">8565</span> AssignStreamIntentPerFwkStream() Feature<span class="number">2</span>Mapping: Stream Intent CHI_STREAM_INTENT_PREVIEW for <span class="number">0</span>xb<span class="number">400007402</span>c<span class="number">56488</span> format: <span class="number">0</span>x<span class="number">22</span> width: <span class="number">1440</span> height: <span class="number">1080</span> usage: <span class="number">0</span>x<span class="number">900</span></span><br><span class="line"><span class="attribute">chifeature2graphselector</span>.cpp:<span class="number">8565</span> AssignStreamIntentPerFwkStream() Feature<span class="number">2</span>Mapping: Stream Intent CHI_STREAM_INTENT_STILL_CAPTURE for <span class="number">0</span>xb<span class="number">400007402</span>c<span class="number">81</span>c<span class="number">48</span> format: <span class="number">0</span>x<span class="number">21</span> width: <span class="number">4160</span> height: <span class="number">3120</span> usage: <span class="number">0</span>x<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="FPM创建-参数传入FGS设置的m-featureDescNameSet"><a href="#FPM创建-参数传入FGS设置的m-featureDescNameSet" class="headerlink" title="FPM创建 参数传入FGS设置的m_featureDescNameSet"></a>FPM创建 参数传入FGS设置的m_featureDescNameSet</h5><ol>
<li>ProbeChiFeature2Features获取所有feature instance的hook,hook为ChiFeature2OpsEntry，打印并将每一个feature的cap和m_featureDescNameSet进行匹配，那么匹配成功的代表运行功能支持。同时将这个cap和所对应的feature instance 的回调指针ops插入到m_featureVersionToOpsMap.<br>下面是sm4350feature instance支持的cap  </li>
</ol>
<table>
<thead>
<tr>
<th>anchorsync</th>
<th>demux</th>
<th>derivedoffline</th>
<th>frameselect</th>
<th>fusion</th>
<th>mcreprocrt</th>
</tr>
</thead>
<tbody><tr>
<td>AnchorSync</td>
<td>Demux</td>
<td>Yuv2Yuv</td>
<td>FrameSelect</td>
<td>FUSION</td>
<td>MultiCameraReprocessRealtime</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>realtimeserializer</th>
<th>rtmcx</th>
<th>serializer</th>
<th>statsregeneration</th>
<th>rawhdr</th>
</tr>
</thead>
<tbody><tr>
<td>RealTimeSerializer</td>
<td>RealTimeMCX</td>
<td>Serializer</td>
<td>StatsRegeneratio</td>
<td>RawHDR</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>fusion</th>
<th>mfsr</th>
</tr>
</thead>
<tbody><tr>
<td>FUSION</td>
<td>MFSR</td>
</tr>
<tr>
<td>BOKEH</td>
<td>MFNR</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>hdr</th>
<th>rt</th>
</tr>
</thead>
<tbody><tr>
<td>HDR</td>
<td>RealTime</td>
</tr>
<tr>
<td>ThreeFrameMFHDR</td>
<td>RealTimeNZSL</td>
</tr>
<tr>
<td>TwoFrameMFHDR</td>
<td>RealTimeWithSWRemosaic</td>
</tr>
</tbody></table>
<p>下面是 generic 的Cap:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Bayer2Yuv</span> JPEG  FormatConvertor YUVReprocess  RealtimePostProcessor Yuv<span class="number">2</span>Yuv  SWRemosaic  Y<span class="number">2</span>YRTDiffDimen Y<span class="number">2</span>YMultiPreview  PostFusionIPE </span><br></pre></td></tr></table></figure>

<p>对feature具体的描述在<br>chi-cdk/oem/qcom/feature2/chifeature2graphselector/descriptors/generated/features</p>
<h5 id="TM（CHIThreadManage）创建"><a href="#TM（CHIThreadManage）创建" class="headerlink" title="TM（CHIThreadManage）创建"></a>TM（CHIThreadManage）创建</h5><p>通过StartThreads对线程池管理的16个线程进行触发设置，触发WorkerThreadBody</p>
<h5 id="FGD匹配"><a href="#FGD匹配" class="headerlink" title="FGD匹配"></a>FGD匹配</h5><p>pGetFGDListForConfig通过m_featureVersionToOpsMap和FGD Table去进行整合。匹配规则如下</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 该camera逻辑id必须在m_cameraIdMap存在，且cameraType和pCameraIdDescriptorNameSet中一致,这样可以确定到一个FGD <span class="keyword">name</span> set集合，都是该cameraType对应的</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> ((std::find(rCameraIdSet.begin(), rCameraIdSet.end(), cameraId) == rCameraIdSet.end()) || (rPair.first != cameraType))</span><br><span class="line">              &#123;    </span><br><span class="line">                  continue;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line"><span class="number">2</span>. 对FGDname set进行遍历，确定对应的FGD</span><br><span class="line">                  const ChiFeature2GraphDesc&amp; rFeatureGraphDesc =</span><br><span class="line">                      <span class="function"><span class="title">pGraphDescriptorTables</span>-&gt;</span><span class="function"><span class="title">pFeatureGraphDescriptorsMap</span>-&gt;</span><span class="built_in">at</span>(pDescriptorName); </span><br><span class="line">                </span><br><span class="line"><span class="number">3</span>. 针对单双摄FGD 对过滤，规则为IsSkipFeatureGraph，对FGD下的所有feature instance检查，匹配cap,cap所属的Ops,FGD下有多个instance的比如：MultiCameraFusionFeatureGraphFeatureInstanceDescs</span><br><span class="line">    a.低内存设备不走cds graph.</span><br><span class="line">    b.ChiFeature2Type判断，设置在feature instance中，比如SWMFFeatureDescriptor和SWMFAIDenoiserInstanceProps的组成在部分平台不支持</span><br><span class="line">    c.feature2掩码进行过滤的，比如IsSWMFEnabled()和IsAIDEEnabled()</span><br><span class="line">    d.每一个feature instance <span class="keyword">name</span>去和我们从feature动态库中拿到的去匹配</span><br><span class="line">    e.非rawinput的，不处理Bayer2YUVJPEG和Bayer2YUV这两个graph</span><br><span class="line">    </span><br><span class="line">下面是普通预览不开MFNR的过滤</span><br><span class="line">IsSkipFeatureGraph() Skip Raw reprocess graph: Bayer2YUV</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph Bayer2YUV</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph RTBayer2YUVSWMFJPEG</span><br><span class="line">IsSkipFeatureGraph() Skip Raw reprocess graph: Bayer2YUVJPEG</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph Bayer2YUVJPEG</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph RTBayer2YUVSWMFAIDenoiserJPEG</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph RTBayer2YUVSWMF</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph RTBayer2YUVSWMFAIDenoiser</span><br><span class="line"></span><br><span class="line">用到的single garph有</span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>R<span class="function"><span class="title">ealtimeFG</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTM<span class="function"><span class="title">emcpyYUV</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTB<span class="function"><span class="title">ayer2YUVHDRT1JPEG</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTB<span class="function"><span class="title">ayer2YUVJPEG</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTB<span class="function"><span class="title">ayer2YUV</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTB<span class="function"><span class="title">ayer2YUVCDSJPEG</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTR<span class="function"><span class="title">awHDRBayer2YUVJPEGOEM</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTR<span class="function"><span class="title">awHDRBayer2YUVOEM</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTB<span class="function"><span class="title">ayer2YUVCDS</span>-&gt;</span><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. CallCloneGraphDescriptor对匹配成功的graph进行clone并插入到m_clonedFeatureGraphDescriptorsMap和push到m_pFeature2GraphDescs vector中</span><br><span class="line"><span class="number">5</span>. UpdateInstancePropsForGraph 对该graph下的所有feature instance ， ExtSrcLinks, ExtSinkLinks,InternalLinks进行instanceProps设置，默认设置为该逻辑id下的物理id.</span><br><span class="line">针对有input stream为yuv或者预览格式的，且输出为YUV的，增加YUVReprocessFeatureGraphDescriptor，如果输出为JPEG的，增加YUVJPEGReprocessFeatureGraphDescriptor。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Feature-Instance整合"><a href="#Feature-Instance整合" class="headerlink" title="Feature Instance整合"></a>Feature Instance整合</h5><p>该整合为所匹配到的graph下的所有fature instance, extSrcLinks，extSinkLinks,internalLinks的整合</p>
<ol>
<li>CreateVirtualSuperGraph创建，通过MergeFeatureGraphs进行整合，单摄命名为VirtualSuperGraph，双摄命名为MultiCameraVirtualSuperGraph，整合规则暂时不深入研究<br>整合完毕的feature instance打印如下：</li>
</ol>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">CreateFeatureInstances</span>() <span class="selector-pseudo">:VirtualSuperGraph</span>, <span class="selector-tag">numFeatureInstances</span><span class="selector-pseudo">:7</span>, <span class="selector-tag">logicalCameraId</span><span class="selector-pseudo">:0</span></span><br></pre></td></tr></table></figure>

<p>到目前为止，我们已经拿到了全部我们需要的feature instance，links规则,之后通过FPM去管理。</p>
<h5 id="feature-instance-create–-gt-Finalized"><a href="#feature-instance-create–-gt-Finalized" class="headerlink" title="feature instance create–&gt;Finalized"></a>feature instance create–&gt;Finalized</h5><p>下面是一份详细的流程处理</p>
<p><img src="/images/feature2/feature2-configure-finalize.png" alt="alt"></p>
<h5 id="feature-instace-create"><a href="#feature-instace-create" class="headerlink" title="feature instace create"></a>feature instace create</h5><p>这部分主要由CreateFeatureInstances去实现<br>遍历virtualGraph的成员feature instance,下面以RealTime去描述</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> DoStreamNegotiation 将feature instance name去和m_featureVersionToOpsMap(包含instance对应的hook Ops)match,然后进行stramNegotiation.</span><br><span class="line"></span><br><span class="line">chifeature2featurepool.cpp:<span class="number">217</span> DoStreamNegotiation() feature:RealTime, pStreamNegotiation:<span class="number">0x736685b998</span>K</span><br><span class="line"></span><br><span class="line">假如为ZSL snapshot negotiation,</span><br><span class="line">    a. clone RDI stream，这个RDI stream定义在chifeature2utils.h，</span><br><span class="line">    b. 通过GetSensorOutputDimension去获取RDI stream的witdh,high,bpp，方便设置格式,默认bpp为<span class="number">10</span>,那么格式为RAW10</span><br><span class="line">    c. MapStreamPerFeature对feature input stream(fk stream/RDI+FD)进行流类型判定，并添加对应的ChiFeature2Type映射。</span><br><span class="line">    </span><br><span class="line"> chifeature2utils.cpp:<span class="number">339</span> MapStreamPerFeature() Enter :numStreams:<span class="number">2</span>                                                                                       </span><br><span class="line"> chifeature2utils.cpp:<span class="number">351</span> MapStreamPerFeature() Classify: <span class="number">0xb400007402c56488</span> format: <span class="number">34</span> width: <span class="number">1440</span> height: <span class="number">1080</span> gralloc:<span class="number">0x900</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">357</span> MapStreamPerFeature() Identified Preview</span><br><span class="line"> chifeature2utils.cpp:<span class="number">351</span> MapStreamPerFeature() Classify: <span class="number">0xb400007402c81c48</span> format: <span class="number">33</span> width: <span class="number">4160</span> height: <span class="number">3120</span> gralloc:<span class="number">0x3</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">417</span> MapStreamPerFeature() Identified JPEG</span><br><span class="line"> chifeature2utils.cpp:<span class="number">457</span> MapStreamPerFeature() Map Streams Scan:</span><br><span class="line"> chifeature2utils.cpp:<span class="number">458</span> MapStreamPerFeature()     numPreview: <span class="number">1</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">459</span> MapStreamPerFeature()     numVideo: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">460</span> MapStreamPerFeature()     numAllYUV: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">461</span> MapStreamPerFeature()     num4kYUV: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">462</span> MapStreamPerFeature()     numJPEG: <span class="number">1</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">463</span> MapStreamPerFeature()     numRAW: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">464</span> MapStreamPerFeature()     numZSL: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">465</span> MapStreamPerFeature()     ThumbnailYUV: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">466</span> MapStreamPerFeature()     numB2YOut: <span class="number">1</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">603</span> MapStreamPerFeature() Final classification: Stream:<span class="number">0xb400007402c56488</span> feature:<span class="number">0</span> format: <span class="number">34</span> width: <span class="number">1440</span> height: <span class="number">1080</span> gralloc: <span class="number">0x900</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>通过对流类型判断，根据streamIntent去clone对应类型的stream,如果没有该streamIntent(CHI_STREAM_INTENT_POSTVIEW)的stream，那么按照chifeature2utils.h设置的PostViewStreamsOutput来clone.</span><br><span class="line"></span><br><span class="line">DoStreamNegotiation() <span class="number">0</span></span><br><span class="line">DoStreamNegotiation() Accepting_Streams_REALTIME Stream Stream:<span class="number">0xb400007402c56488</span> Format: <span class="number">34</span> width: <span class="number">1440</span> height: <span class="number">1080</span> gralloc: <span class="number">0x900</span></span><br><span class="line">DoStreamNegotiation() <span class="number">1</span></span><br><span class="line">DoStreamNegotiation() Rejecting_Streams_REALTIME Stream Stream:<span class="number">0xb400007402c81c48</span> Format: <span class="number">33</span> width: <span class="number">4160</span> height: <span class="number">3120</span> gralloc: <span class="number">0x3</span></span><br><span class="line">DoStreamNegotiation() Cloning Video Stream</span><br><span class="line">DoStreamNegotiation() numStream:<span class="number">6</span>    &lt;&lt;可见协商该feature instance 的<span class="keyword">out</span> stream为<span class="number">6</span>条</span><br><span class="line"></span><br><span class="line">这<span class="number">6</span>条应该是preview,postview,RDI,IdeaRaw,video,yuv(部分平台为fd),之后可以通过ClassifyStream 函数log中的streamIntent来判断</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 通过UpdateInstancePropsInGraphDesc更新feature instance和links(针对多摄feature instance ).</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建feature instance</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">DoFeatureCreate最终调用ChiFeature2Base::Initialize进行feature instance父类的初始化</span><br><span class="line"></span><br><span class="line">a.注册线程ProcessAsyncFeatureJobs。</span><br><span class="line"></span><br><span class="line">chithreadmanager.cpp:<span class="number">178</span> RegisterJobFamily() Async Job Registered isSync: <span class="number">1</span>, m_numThreads: <span class="number">16</span></span><br><span class="line">chithreadmanager.cpp:<span class="number">187</span> RegisterJobFamily() Registered Fn. Async_RealTime_Create (<span class="number">0x736b27f618</span>) RegJobHandle <span class="number">4294967296</span>, NumOfRegisteredJob <span class="number">1</span></span><br><span class="line"></span><br><span class="line">b. ClassifyStream 根据流的streamType，决定push到pInputStreams还是pOutputStreams</span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">1440</span> X <span class="number">1080</span> Format = <span class="number">0x22</span> Usage = <span class="number">0x900</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb400007402c56488</span> (<span class="built_in">int</span>ent =<span class="number">1</span> bpp = <span class="number">0</span>) PhyCamId = </span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">320</span> X <span class="number">240</span> Format = <span class="number">0x23</span> Usage = <span class="number">0x0</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb4000073e2c95710</span> (<span class="built_in">int</span>ent = <span class="number">6</span> bpp = <span class="number">0</span>) PhyCamId = (<span class="literal">null</span>)</span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">4208</span> X <span class="number">3120</span> Format = <span class="number">0x25</span> Usage = <span class="number">0x20002</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb4000073e2c96580</span> (<span class="built_in">int</span>ent = <span class="number">8</span> bpp = <span class="number">10</span>) PhyCamId = (<span class="literal">null</span>)</span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">4096</span> X <span class="number">3072</span> Format = <span class="number">0x20</span> Usage = <span class="number">0x20002</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb4000073e2c95780</span> (<span class="built_in">int</span>ent = <span class="number">2</span> bpp = <span class="number">0</span>) PhyCamId = (<span class="literal">null</span>)</span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">1440</span> X <span class="number">1080</span> Format = <span class="number">0x23</span> Usage = <span class="number">0x0</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb4000073e2c95630</span> (<span class="built_in">int</span>ent = <span class="number">3</span> bpp = <span class="number">0</span>) PhyCamId = (<span class="literal">null</span>)</span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">640</span> X <span class="number">480</span> Format = <span class="number">0x23</span> Usage = <span class="number">0x0</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb4000073e2c97700</span> (<span class="built_in">int</span>ent = <span class="number">7</span> bpp = <span class="number">0</span>) PhyCamId = (<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">c.设置最大的m_maxFeatureExecutionTime,判断是否超时处理。</span><br><span class="line"></span><br><span class="line">d.创建的全部feature instance如下</span><br><span class="line">CreateFeatureInstances() RealTime(<span class="number">0xb400007472ce27f0</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">CreateFeatureInstances() RawHDR(<span class="number">0xb400007472c52f10</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">CreateFeatureInstances() Bayer2Yuv(<span class="number">0xb400007472c83f70</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; </span><br><span class="line">CreateFeatureInstances() Bayer2Yuv(<span class="number">0xb400007472cd5050</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">16384</span>&#125;</span><br><span class="line">CreateFeatureInstances() HDR(<span class="number">0xb400007472c96530</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; </span><br><span class="line">CreateFeatureInstances() JPEG(<span class="number">0xb400007472c8acd0</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">CreateFeatureInstances() Yuv2Yuv(<span class="number">0xb400007472cb5c50</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">33</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">总共<span class="number">7</span>个instance，对应</span><br><span class="line">CreateFeatureInstances() :VirtualSuperGraph, numFeatureInstances:<span class="number">7</span>, logicalCameraId:<span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>CDS feature enable要求：</p>
<ol>
<li>feature instance type 为B2Y</li>
<li>instanceFlags.isCDSSnapshot 为1</li>
<li>该feature下的output流尺寸必须为4的倍数</li>
<li>针对QCFA，必须为instanceFlags.isCDSSnapshot &amp;&amp; instanceFlags.isNZSLSnapshot</li>
</ol>
<h5 id="feature-instance-configure-amp-finialize"><a href="#feature-instance-configure-amp-finialize" class="headerlink" title="feature instance configure&amp;finialize"></a>feature instance configure&amp;finialize</h5><p>先针对enable feature vector（有自己的排序规则）进行反向遍历处理</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> negotiationsMap对OutputPortRequirement的映射规则<span class="comment">//todo negotiationsMap未满足条件映射</span></span><br><span class="line"><span class="number">2.</span> 通过.ConfigureFeature在feature instance中去初始化pipeline. 一条pipeline是在feature 拓扑中定义的  </span><br><span class="line">    a.从feature instance中获取定义的session number和 pipeline number</span><br><span class="line">    比如我们已经知道一个feature instance的name为RealTime， 那么可以知道对应的cap也为RealTime，</span><br><span class="line">    对应的ChiFeature2Descriptor 类型ChiFeature2Descriptor 定义在feature2/chifeature2graphselector/descriptors/generated/features/g_chifeature2realtimedescriptor.cpp下</span><br><span class="line">    </span><br><span class="line">      CDK_VISIBILITY_PUBLIC extern <span class="keyword">const</span> ChiFeature2Descriptor RealTimeFeatureDescriptor =</span><br><span class="line">  &#123;                                                        </span><br><span class="line">      <span class="number">0</span>,                                                                               <span class="comment">// Feature Id</span></span><br><span class="line">      <span class="string">&quot;RealTime&quot;</span>,                                                                      <span class="comment">// Feature Name</span></span><br><span class="line">      <span class="number">1</span>,                                                                               <span class="comment">// Num Stage Descriptors</span></span><br><span class="line">      &amp;RealTime_StageDescriptors[<span class="number">0</span>],                                                   <span class="comment">// Stage Descriptors</span></span><br><span class="line">      <span class="number">1</span>,                                                                               <span class="comment">// Num Session Descriptors</span></span><br><span class="line">      &amp;RealTime_SessionDescriptors[<span class="number">0</span>],                                                 <span class="comment">// Session Descriptors</span></span><br><span class="line">      <span class="number">5</span>,                                                                               <span class="comment">// Num Internal Links</span></span><br><span class="line">      &amp;RealTime_InternalLinks[<span class="number">0</span>],                                                      <span class="comment">// Internal Link Descriptors</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">    PrepareFeatureData() Feature2Mapping: FeatureName = RealTime, numSessions = <span class="number">1</span>, numPipelines = <span class="number">14</span> numPorts = <span class="number">280</span></span><br><span class="line">    RealTime feature instance下一共有<span class="number">14</span>条pipeline中，定义在RealTime_Session0_PipelineDescs。但这个时候pipeline拓扑我们是不知道的</span><br><span class="line">    </span><br><span class="line">    下面从b到e，将根据session和pipeline desc填充pSessionData和pSessionData-&gt;pPipelineData</span><br><span class="line">    b.针对每一个session，设置对应的session回调，针对session下的每一个pipeline，feature instance 通过OnPipelineSelect判断是否支持。</span><br><span class="line">    </span><br><span class="line">    chifeature2realtime.cpp:<span class="number">2851</span> OnPipelineSelect() featureName:RealTime, pipelineName:ZSLPreviewRaw_LT1080p, instanceFlags &#123;nzsl:<span class="number">0</span>, swremosaic:<span class="number">0</span>, hwremosaic:<span class="number">0</span>, bpscam:<span class="number">0</span>, shdr <span class="number">0</span>, mfhdr <span class="number">0</span>&#125; isPipelineSupported <span class="number">1</span> Screengrab:<span class="number">0</span>, platformSocId <span class="number">454</span></span><br><span class="line">    </span><br><span class="line">    c.拿到m_pChiUsecase，并通过pipeline name确定pipelne index，方便之后CloneUsecase和PruneUsecaseDescriptor确定pipeline拓扑</span><br><span class="line">    </span><br><span class="line">    PrepareFeatureData() session: <span class="number">0</span>, name: RealTime, pipeline: <span class="number">0</span>, name: ZSLPreviewRaw_LT1080p</span><br><span class="line">    </span><br><span class="line">    d.根据pipeline中input和output的描述，在pipeline的pInputPortData和pOutputPortData分别增加对于的描述，针对InternalLinks，将sinkport的描述也增加到对应pipeline的pInputPortData描述中</span><br><span class="line">    </span><br><span class="line">    e.拿到pInternalLinkDesc中的sink port对在的pipeline data,并给pInputPortData添加对应sink port描述的pSinkPortData。</span><br><span class="line">    </span><br><span class="line">    f.通过CloneUsecase和PruneUsecaseDescriptor确定pipeline拓扑</span><br><span class="line">    </span><br><span class="line">    g.通过PopulateDisabledStatus检查pipelineData中的input和output data的targetName是否在usecae拓扑中source Target和 sink Target的targetName match.</span><br><span class="line">    </span><br><span class="line">   *pSinkPortData push_back(pInternalLinkDesc[linkPortIdx].pSinkPort)---&gt; pInputPortData ----- sourceTarget</span><br><span class="line">   </span><br><span class="line">                                                                          pOutputPortData ----- sinkTarget</span><br><span class="line">                                                                          </span><br><span class="line">    PopulateDisabledStatus() RealTime : ZSLPreviewRaw_LT1080p:ZSL_In_Raw : Port Status : <span class="number">1</span> = &gt; <span class="number">0</span> SrcPort : (Raw_Out)</span><br><span class="line">    PopulateDisabledStatus() RealTime : ZSLPreviewRaw_LT1080p:ZSL_In_FD : Port Status : <span class="number">1</span> = &gt; <span class="number">1</span> SrcPort : (Fd_Out)</span><br><span class="line">    PopulateDisabledStatus() RealTime : ZSLPreviewRaw_LT1080p:MFHDR_long_raw_In : Port Status : <span class="number">1</span> = &gt; <span class="number">1</span> SrcPort : (MFHDR_ZSL_In_Long_Raw_out))</span><br><span class="line">    PopulateDisabledStatus() RealTime : ZSLPreviewRaw_LT1080p:MFHDR_short_raw_In : Port Status : <span class="number">1</span> = &gt; <span class="number">1</span> SrcPort : (MFHDR_ZSL_In_Short_Raw_out)</span><br><span class="line">    </span><br><span class="line">    h.针对pSinkTarget和pSrcTarget，进行AssignStreams和AssignTargets，这个时候会有一个对应关系。匹配规则如下</span><br><span class="line">        <span class="number">1.</span>对应关系   pInputPortData ----- sourceTarget</span><br><span class="line">                     pOutputPortData ----- sinkTarget</span><br><span class="line">        <span class="number">2.</span>从PortData中找到和Single Target 中target name一致的port（但是Raw_Out 和 Raw_Callback pTargetName一致，会造成共享一个result stream ），然后针对这个target进行流分配，调用AssignStreams，先申请result stream空间，然后将feature instance 要处理的stream <span class="built_in">int</span>ent和port 支持的stream <span class="built_in">int</span>ent匹配，将匹配成功的stream用pStreamMatched数组标记。将匹配的stream地址赋值给target stream,同时将target stream指向的空间复制到result stream申请的空间</span><br><span class="line">        </span><br><span class="line">        GetTargetStreamWithIntent() MATCHED: CHI_STREAM_INTENT_PREVIEW <span class="keyword">for</span> Target: TARGET_BUFFER_DISPLAY ChiStream: <span class="number">0xb400007402c56488</span> format: <span class="number">34</span> width: <span class="number">1440</span> height: <span class="number">1080</span></span><br><span class="line">        </span><br><span class="line">        GetTargetStreamWithIntent() Feature2Mapping: Target Stream: TARGET_BUFFER_DISPLAY <span class="number">0xb400007402c56488</span> Intent: CHI_STREAM_INTENT_PREVIEW Resolution: <span class="number">1440</span> X <span class="number">1080</span> Format = <span class="number">34</span></span><br><span class="line">        </span><br><span class="line">        GetTargetStreamWithIntent() FeatureStreamMapping: TargetName = TARGET_BUFFER_DISPLAY StreamPtr:<span class="number">0xb4000073e2c91110</span> Intent: CHI_STREAM_INTENT_PREVIEW Resolution = <span class="number">1440</span>X1080 Format = <span class="number">34</span> Direction = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        InitializeTargetStream() Add feature <span class="number">0</span> Target TARGET_BUFFER_DISPLAY instance <span class="number">0</span> stream <span class="number">0xb400007402c56488</span>, cameraId <span class="number">0</span></span><br><span class="line">        InitializeTargetStream() RealTime: Target:TARGET_BUFFER_DISPLAY, PortKey:Display_Out:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">3</span> stream:target:<span class="number">0xb4000073e2c91110</span>:<span class="number">0xb400007402c56488</span>Stream: <span class="number">1440</span> X <span class="number">1080</span>:<span class="number">0x22</span>:<span class="number">0</span>:<span class="number">0x900</span>:<span class="number">1</span></span><br><span class="line">        chifeature2base.cpp:<span class="number">8289</span> AssignStreams() RealTime: Assign Stream (<span class="number">0xb4000073e2c91110</span>): Target = TARGET_BUFFER_DISPLAY resolution <span class="number">1440</span>x1080 format <span class="number">0x22</span> usage <span class="number">900</span> type <span class="number">0</span></span><br><span class="line">        <span class="number">3.</span>AssignTargets针对rDstPortData.pTarget为空且target name相同的，同步pTargetDesc的pTarget和pTarget-&gt;pChiStream（用来buffer回调的result stream）到rDstPortData</span><br><span class="line">        </span><br><span class="line">        RealTime: Output Port: (<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>) : Display_Out : target: TARGET_BUFFER_DISPLAY stream:<span class="number">0xb4000073e2c91110</span> targetStream:<span class="number">0xb4000073e2c91110</span>Res:<span class="number">1440</span>X1080</span><br><span class="line">        </span><br><span class="line">    i. OnInitialize注册feature instance PCR处理函数SubmitRequestJob</span><br><span class="line">    j. OnConfigureOutputPorts <span class="comment">//配置规则todo，未见log打印</span></span><br><span class="line">    k. ConfigurePipelineData <span class="comment">//创建pipeline并OnConfigureInputPorts 配置规则todo，未见配置log打印。</span></span><br><span class="line">    l. 此时feature instance实例 状态机设置为ChiFeature2Status::Configured</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 基于feature input requirement更新 feature output requirement <span class="comment">//规则todo log未见打印</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 调用FinalizeInitialization</span><br><span class="line">   FinalizeInitialization() finalize initialization RealTime</span><br><span class="line">   </span><br><span class="line">   这里通过rFinalizedInputs和finalizedOutputs， InternalLinks来实现不同feature pipeline相连端口的Assgin stream尺寸的一致性。</span><br><span class="line">   </span><br><span class="line">    chifeature2featurepool.cpp:<span class="number">1006</span> FinalizeFeatureInstances() [RealTime:<span class="number">0</span>] Output Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125; influences [Bayer2Yuv:<span class="number">0</span>] Input Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;(Fmt: <span class="number">0x25</span> [<span class="number">4208</span> x <span class="number">3120</span>])</span><br><span class="line">    chifeature2featurepool.cpp:<span class="number">1006</span> FinalizeFeatureInstances() [RealTime:<span class="number">0</span>] Output Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125; influences [Bayer2Yuv:<span class="number">8</span>] Input Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;(Fmt: <span class="number">0x25</span> [<span class="number">4208</span> x <span class="number">3120</span>])</span><br><span class="line">    chifeature2featurepool.cpp:<span class="number">1006</span> FinalizeFeatureInstances() [RealTime:<span class="number">0</span>] Output Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125; influences [RawHDR:<span class="number">0</span>] Input Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;(Fmt: <span class="number">0x25</span> [<span class="number">4208</span> x <span class="number">3120</span>])</span><br><span class="line">    chifeature2featurepool.cpp:<span class="number">1006</span> FinalizeFeatureInstances() [Bayer2Yuv:<span class="number">0</span>] Output Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; influences [JPEG:<span class="number">0</span>] Input Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;(Fmt: <span class="number">0x23</span> [<span class="number">4160</span> x <span class="number">3120</span>])</span><br><span class="line">    chifeature2featurepool.cpp:<span class="number">1006</span> FinalizeFeatureInstances() [Bayer2Yuv:<span class="number">0</span>] Output Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; influences [HDR:<span class="number">0</span>] Input Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;(Fmt: <span class="number">0x23</span> [<span class="number">4160</span> x <span class="number">3120</span>])</span><br><span class="line"></span><br><span class="line">   a.通过FinalizeSessionData 创建 非defer session </span><br><span class="line">   camxsession.cpp:<span class="number">2345</span> Initialize() Session (<span class="number">0xb40000732e345040</span>) Initialized ZSLPreviewRaw_L     T1080p</span><br><span class="line">   </span><br><span class="line">   b.给每一条pipeline的OutputMeta和SettingMeta,pipeline上port创建TBM. 正好对应<span class="number">6</span>条stream的<span class="number">6</span>个port</span><br><span class="line">   CreateTargetBufferManagers() metamanagerName:SettingTargetBuffer_ZSLPreviewRaw_LT1080p pSettingMetaTbm:<span class="number">0xb400007472cc78b0</span></span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:Display_Out port idx:<span class="number">0</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c91110</span>, format:<span class="number">34</span>, w x h: <span class="number">1440</span> x <span class="number">1080</span> usage <span class="number">20900</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">0</span> Max:</span><br><span class="line">   CreateTargetBufferManagers() isChiFenceEnabled:<span class="number">0</span>, RealTime: PortTargetBuffer_RealTime:Display_Out_0: Res: <span class="number">1440</span>X1080 Format = <span class="number">0X22</span>, Min Buffer = <span class="number">0</span>, Max Buffer = <span class="number">8</span>, isChiGrallocBufferUsed=<span class="number">0</span></span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:Raw_Out port idx:<span class="number">1</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c926f0</span>, format:<span class="number">37</span>, w x h: <span class="number">4208</span> x <span class="number">3120</span> usage <span class="number">20002</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">9</span> Max:<span class="number">64</span></span><br><span class="line">   CreateTargetBufferManagers() isChiFenceEnabled:<span class="number">0</span>, RealTime: PortTargetBuffer_RealTime:Raw_Out_0: Res: <span class="number">4208</span>X3120 Format = <span class="number">0X25</span>, Min Buffer = <span class="number">9</span>, Max Buffer = <span class="number">64</span>, isChiGrallocBufferUsed=</span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:Video_Out port idx:<span class="number">3</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c92680</span>, format:<span class="number">35</span>, w x h: <span class="number">1440</span> x <span class="number">1080</span> usage <span class="number">20000</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">0</span> Max:<span class="number">8</span></span><br><span class="line">   CreateTargetBufferManagers() isChiFenceEnabled:<span class="number">0</span>, RealTime: PortTargetBuffer_RealTime:Video_Out_0: Res: <span class="number">1440</span>X1080 Format = <span class="number">0X23</span>, Min Buffer = <span class="number">0</span>, Max Buffer = <span class="number">8</span>, isChiGrallocBufferUsed=<span class="number">0</span></span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:Yuv_Out port idx:<span class="number">6</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c91340</span>, format:<span class="number">35</span>, w x h: <span class="number">640</span> x <span class="number">480</span> usage <span class="number">20000</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">0</span> Max:<span class="number">8</span></span><br><span class="line">   CreateTargetBufferManagers() isChiFenceEnabled:<span class="number">0</span>, RealTime: PortTargetBuffer_RealTime:Yuv_Out_0: Res: <span class="number">640</span>X480 Format = <span class="number">0X23</span>, Min Buffer = <span class="number">0</span>, Max Buffer = <span class="number">8</span>, isChiGrallocBufferUsed=<span class="number">0</span></span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:PostView_Out port idx:<span class="number">7</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c95c50</span>, format:<span class="number">35</span>, w x h: <span class="number">320</span> x <span class="number">240</span> usage <span class="number">20000</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">0</span> Max:<span class="number">8</span></span><br><span class="line">   CreateTargetBufferManagers() isChiFenceEnabled:<span class="number">0</span>, RealTime: PortTargetBuffer_RealTime:PostView_Out_0: Res: <span class="number">320</span>X240 Format = <span class="number">0X23</span>, Min Buffer = <span class="number">0</span>, Max Buffer = <span class="number">8</span>, isChiGrallocBufferUsed=<span class="number">0</span></span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:IDEALRaw_Out port idx:<span class="number">14</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c93870</span>, format:<span class="number">32</span>, w x h: <span class="number">4096</span> x <span class="number">3072</span> usage <span class="number">20002</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">0</span> Max:<span class="number">8</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   Raw_Out 和 Raw_Callback pTargetName一致，会造成共享一个result stream，一个TBM</span><br><span class="line">   </span><br><span class="line">   FinalizeSessionData() RealTime Raw_Out pushing back output stream(<span class="number">0xb4000073e2c926f0</span>) fmt <span class="number">0x25</span> dims <span class="keyword">from</span> [<span class="number">4208</span> x <span class="number">3120</span>]</span><br><span class="line">   FinalizeSessionData() RealTime Raw_Callback pushing back output stream(<span class="number">0xb4000073e2c926f0</span>) fmt <span class="number">0x25</span> dims <span class="keyword">from</span> [<span class="number">4208</span> x <span class="number">3120</span>]</span><br><span class="line">   CreateTargetBufferManagers() Linking port Raw_Out -&gt; Raw_Callback</span><br><span class="line">   CreateTargetBufferManagers() Feature: RealTime Sharing TBM <span class="keyword">for</span> port Raw_Callback</span><br><span class="line">   BuildLinkedPortListForPort() LinkedPort:pPort_Raw_Out:(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)-&gt;rPort_Raw_Callback[<span class="number">4</span>]:(<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">   BuildLinkedPortListForPort() LinkedPort:pPort_Raw_Callback:(<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>)-&gt;rPort_Raw_Out[<span class="number">1</span>]:(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   c.PrepareStageData<span class="comment">//其实并没有做实际性的工作，根据Feature Instance Desc和Stage Desc，已经建立好的SessionData，PipelineData匹配检查</span></span><br><span class="line">   </span><br><span class="line">   d.PostJob m_hAsyncFeatureJob 建立defer session</span><br><span class="line">   e. m_pStreamData的构建 见图</span><br><span class="line"></span><br><span class="line">   f.创建RequestThread线程 flush wait feature instance.</span><br><span class="line">   g.feature instance 状态机设置为ChiFeature2Status::Finalized</span><br></pre></td></tr></table></figure>


<h4 id="TBM的创建"><a href="#TBM的创建" class="headerlink" title="TBM的创建"></a>TBM的创建</h4><p>对F2W的input stream（双摄的RDI.FD）和 fk stream 和metadata TBM绑定</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">chifeature2wrapper.cpp:1804 CreateTargetBufferManagers() Framework Target Buffer Manager [<span class="string">FWK_34_TBM</span>][<span class="symbol">0xb400007472c8e1f0</span>] created. stream=0xb400007402c56488 type=0 format=34</span><br><span class="line"></span><br><span class="line">chifeature2wrapper.cpp:1804 CreateTargetBufferManagers() Framework Target Buffer Manager [<span class="string">FWK_33_TBM</span>][<span class="symbol">0xb400007472c99730</span>] created. stream=0xb400007402c81c48 type=0 format=33</span><br><span class="line"></span><br><span class="line">chifeature2wrapper.cpp:1842 CreateTargetBufferManagers() Wrapper meta target buffer created 0xb400007472cdaaf0 ,physicalCamIdx:0 </span><br></pre></td></tr></table></figure>

<p><a id="3"></a></p>
<h3 id="feature-instance-connect"><a href="#feature-instance-connect" class="headerlink" title="feature instance connect"></a>feature instance connect</h3><p><a id="4"></a></p>
<h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p><a id="5"></a></p>
<h3 id="TBM详解"><a href="#TBM详解" class="headerlink" title="TBM详解"></a>TBM详解</h3><p><a id="6"></a></p>
<h3 id="TM详解"><a href="#TM详解" class="headerlink" title="TM详解"></a>TM详解</h3>]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>Feature2</tag>
      </tags>
  </entry>
  <entry>
    <title>Camx-Feature2-featureInstanceConnect</title>
    <url>/archives/8a2ade19.html</url>
    <content><![CDATA[<h1 id="Camx-Feature2-featureInstanceConnect"><a href="#Camx-Feature2-featureInstanceConnect" class="headerlink" title="Camx-Feature2-featureInstanceConnect"></a>Camx-Feature2-featureInstanceConnect</h1><p>在这小节中，我们会对feature graph的整合和feature instance之间的连接有个大致的了解</p>
<p>从之前GetAllFeatureGraphDescriptors中过滤掉一部分的featureGraphDesc，剩下的按照组合规则构成VirtualSuperGraph，那么具体各feature之间的连接顺序和规则是通过什么来确定的?</p>
<p>下面是sm4350当前预览的feature 拓扑详细的描述了之间的连接</p>
<p><img src="/images/feature2/feature2-featureInstanceConnect.png" alt="alt"></p>
<p>整理之前的全部信息，包括整合以后的feature instance下的stream和端口组合。 </p>
<details>
  <summary>确定需要组合的featureGraphDesc</summary>

<pre><code>Insert single graph:cameraID 0-&gt;RealtimeFG-&gt;0 //无 internal link
Insert single graph:cameraID 0-&gt;RTMemcpyYUV-&gt;0 //无feature instance 
Insert single graph:cameraID 0-&gt;RTBayer2YUVHDRT1JPEG-&gt;0
Insert single graph:cameraID 0-&gt;RTBayer2YUVJPEG-&gt;0
Insert single graph:cameraID 0-&gt;RTBayer2YUV-&gt;0
Insert single graph:cameraID 0-&gt;RTBayer2YUVCDSJPEG-&gt;0
Insert single graph:cameraID 0-&gt;RTRawHDRBayer2YUVJPEGOEM-&gt;0
Insert single graph:cameraID 0-&gt;RTRawHDRBayer2YUVOEM-&gt;0
Insert single graph:cameraID 0-&gt;RTBayer2YUVCDS-&gt;0</code></pre>
</details>

<details>
  <summary>确定VirtualSuperGraph下包含的feature instance</summary>

<pre><code>CreateFeatureInstances() :VirtualSuperGraph, numFeatureInstances:7, logicalCameraId:0
CreateFeatureInstances() RealTime(0xb400007472ce27f0) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;0, 0, 0, 0&#125;
CreateFeatureInstances() RawHDR(0xb400007472c52f10) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;10, 0, 0, 0&#125;
CreateFeatureInstances() Bayer2Yuv(0xb400007472c83f70) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;1, 0, 0, 0&#125;
CreateFeatureInstances() Bayer2Yuv(0xb400007472cd5050) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;1, 8, 0, 16384&#125;
CreateFeatureInstances() HDR(0xb400007472c96530) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;6, 0, 0, 0&#125;
CreateFeatureInstances() JPEG(0xb400007472c8acd0) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;5, 0, 0, 0&#125;
CreateFeatureInstances() Yuv2Yuv(0xb400007472cb5c50) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;33, 0, 0, 0&#125;</code></pre>
</details>

<details>
  <summary>确定各feature instance下的stream</summary>

<pre><code>//RealTime
DoStreamNegotiation() numStream:6
ClassifyStream() Name = RealTime: Res: 1440 X 1080 Format = 0x22 Usage = 0x900 Type = 0 STREAM = 0xb400007402c56488 (intent = 1 bpp = 0) PhyCamId =  &gt;&gt;configure_stream预览流
ClassifyStream() Name = RealTime: Res: 320 X 240 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c95710 (intent = 6 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = RealTime: Res: 4208 X 3120 Format = 0x25 Usage = 0x20002 Type = 0 STREAM = 0xb4000073e2c96580 (intent = 8 bpp = 10) PhyCamId = (null)
ClassifyStream() Name = RealTime: Res: 4096 X 3072 Format = 0x20 Usage = 0x20002 Type = 0 STREAM = 0xb4000073e2c95780 (intent = 2 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = RealTime: Res: 1440 X 1080 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c95630 (intent = 3 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = RealTime: Res: 640 X 480 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c97700 (intent = 7 bpp = 0) PhyCamId = (null)
//RawHDR
ClassifyStream() Name = RawHDR: Res: 4208 X 3120 Format = 0x25 Usage = 0x20022 Type = 1 STREAM = 0xb4000073e2c93800 (intent = 5 bpp = 0) PhyCamId = (null) 
ClassifyStream() Name = RawHDR: Res: 4208 X 3120 Format = 0x25 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c979a0 (intent = 2 bpp = 0) PhyCamId = (null)
//Bayer2Yuv
DoStreamNegotiation() numStream:4 screenGrab: 0
ClassifyStream() Name = Bayer2Yuv: Res: 4208 X 3120 Format = 0x25 Usage = 0x20022 Type = 1 STREAM = 0xb4000073e2c95400 (intent = 7 bpp = 10) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c933a0 (intent = 2 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c959b0 (intent = 7 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c97e70 (intent = 7 bpp = 0) PhyCamId = (null)
//Bayer2Yuv CDS
DoStreamNegotiation() numStream:4 screenGrab: 0
ClassifyStream() Name = Bayer2Yuv: Res: 4208 X 3120 Format = 0x25 Usage = 0x20022 Type = 1 STREAM = 0xb4000073e2c96dd0 (intent = 7 bpp = 10) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c8d130 (intent = 2 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c97230 (intent = 7 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c94de0 (intent = 7 bpp = 0) PhyCamId = (null)
//HDR
ClassifyStream() Name = HDR: Res: 4160 X 3120 Format = 0x23 Usage = 0x20022 Type = 0 STREAM = 0xb4000073e2c95160 (intent = 2 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = HDR: Res: 4160 X 3120 Format = 0x23 Usage = 0x20022 Type = 1 STREAM = 0xb4000073e2c951d0 (intent = 2 bpp = 0) PhyCamId = (null)
//JPEG
DoStreamNegotiation() numStream:2 screenGrab: 0 
ClassifyStream() Name = JPEG: Res: 4160 X 3120 Format = 0x23 Usage = 0x20022 Type = 1 STREAM = 0xb4000073e2c932c0 (intent = 7 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = JPEG: Res: 4160 X 3120 Format = 0x21 Usage = 0x3 Type = 0 STREAM = 0xb400007402c81c48 (intent = 2 bpp = 0) PhyCamId = &gt;&gt;configure_stream 拍照流
//Yuv2Yuv
ClassifyStream() Name = Yuv2Yuv: Res: 1440 X 1080 Format = 0x22 Usage = 0x900 Type = 0 STREAM = 0xb400007402c56488 (intent = 1 bpp = 0) PhyCamId  =&gt;&gt;configure_stream预览流
ClassifyStream() Name = Yuv2Yuv: Res: 4160 X 3120 Format = 0x21 Usage = 0x3 Type = 0 STREAM = 0xb400007402c81c48 (intent = 2 bpp = 0) PhyCamId = &gt;&gt;configure_stream 拍照流</code></pre>
</details>

<details>
  <summary>确定各feature instance下的port</summary>

<pre><code>//重复的已经删除
//realtime all links 
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 2&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 5&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 3&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 4&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 6&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 7&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 8&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 14&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 19&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//RawHDR
operator()() VirtualSuperGraph (RawHDR:0) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RawHDR:0) &#123;0, 0, 4&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RawHDR:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RawHDR:0) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RawHDR:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//Bayer2Yuv feature 1 instance 0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 1&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 2&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 3&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//Bayer2Yuv feature 1 instance 8
operator()() VirtualSuperGraph (Bayer2Yuv:8) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x4000, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:8) &#123;0, 0, 1&#125; Dir: 1 Flags: 0x4000, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:8) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x4000, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:8) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x4000, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:8) &#123;0, 0, 2&#125; Dir: 3 Flags: 0x4000, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//HDR
operator()() VirtualSuperGraph (HDR:0) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (HDR:0) &#123;0, 0, 4&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (HDR:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (HDR:0) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//JPEG
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 1&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 2&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 3&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//Yuv2Yuv
operator()() VirtualSuperGraph (Yuv2Yuv:0) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Yuv2Yuv:0) &#123;0, 0, 1&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Yuv2Yuv:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0</code></pre>
</details>


]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>Feature2</tag>
      </tags>
  </entry>
  <entry>
    <title>生产力工具记录</title>
    <url>/archives/8a2ade17.html</url>
    <content><![CDATA[<h1 id="生产力工具记录"><a href="#生产力工具记录" class="headerlink" title="生产力工具记录"></a>生产力工具记录</h1><p>下面是一些生产力工具</p>
<ul>
<li>Hexo</li>
<li>draw.io</li>
<li>vim/tmux/cscope/ctags/fzf/taglist/ag</li>
<li>HHKB types</li>
</ul>
<a id="more"></a> 
<hr>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>hexo官网链接：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<p>本地主要维护两个仓库： </p>
<blockquote>
<p>1.hexo-blog维护 博客hexo源代码 私有库<br>2.xiaer1921.github.io  维护博客hexo 生产代码</p>
</blockquote>
<h3 id="本地实践记录"><a href="#本地实践记录" class="headerlink" title="本地实践记录"></a>本地实践记录</h3><ol>
<li>在执行hexo g之后，如果需要将代码部署到github，需要额外在public文件夹中新加文件CNAME，内容为你的域名，比如sholck.top.或者在source文件中增加CNAME文件，这样在hexo g时会自动复制到public文件下。  </li>
<li>需要将配置的md文件配置为644权限  </li>
<li>本地安装配置<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">npm config set registry https:<span class="regexp">//</span>registry.npm.taobao.org  <span class="regexp">//</span>增加淘宝源</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">hexo -v </span><br><span class="line">报错 <span class="regexp">/usr/</span>bin/env: node: 没有那个文件或目录</span><br><span class="line">解决：为node增加软链接 sudo ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/nodejs /u</span>sr<span class="regexp">/bin/</span>node</span><br><span class="line"></span><br><span class="line">报错 SyntaxError: Use of const <span class="keyword">in</span> strict mode. </span><br><span class="line">原因: node版本过低 node -v 查看版本</span><br><span class="line">解决：升级nodejs </span><br><span class="line">npm cache clean -f</span><br><span class="line">sudo npm install -g n</span><br><span class="line">sudo n stable</span><br><span class="line"></span><br><span class="line">重新安装hexo-cli</span><br><span class="line"><span class="comment">#hexo -v 正确打印各插件版本信息</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="功能学习"><a href="#功能学习" class="headerlink" title="功能学习"></a>功能学习</h3><ol>
<li><p>当前文本无法高亮,使用==text==无效，使用以下第三种方法</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. hexo支持，但是有道云不支持</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;红色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:green&quot;</span>&gt;绿色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:yellow&quot;</span>&gt;黄色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:blue&quot;</span>&gt;蓝色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. ==text== 有道云支持，但是hexo不支持</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. &lt;<span class="built_in">font</span> <span class="built_in">color</span>=#2196F3 &gt;text&lt;/<span class="built_in">font</span>&gt; 兼容</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码高亮配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">在_config.yml中增加如下配置：</span><br><span class="line"><span class="attr">highlight_theme:</span> night eightie <span class="comment">//主题</span></span><br><span class="line">auto_detect 设置为<span class="literal">true</span></span><br><span class="line">themes<span class="regexp">/next/</span>source/lib </span><br><span class="line">路径下下载主题git clone git<span class="meta">@github</span>.<span class="attr">com:</span>chriskempson/tomorrow-theme.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用命令</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">clean 清理生成文件</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g 生成文件</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">s 启动hexo服务</span></span><br><span class="line"><span class="attr">http</span>:<span class="string">//localhost:4000/  可查看hexo启动运行的hexo服务界面</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>图片加载</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">先把图片放在<span class="keyword">source</span><span class="regexp">/images/</span></span><br><span class="line">eg：<span class="keyword">source</span><span class="regexp">/images/</span>CR-hal-chi-camx.png</span><br><span class="line">    </span><br><span class="line">在md中加入:</span><br><span class="line">    ![alt](<span class="regexp">/images/</span>PCR-hal-chi-camx.png)</span><br></pre></td></tr></table></figure>
</li>
<li><p>置顶+标签</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">置顶+标签：</span><br><span class="line"><span class="keyword">tags:</span> Camx</span><br><span class="line">top: true</span><br><span class="line">多tags配置：</span><br><span class="line"><span class="keyword">tags:</span> </span><br><span class="line">    - Camera-Camx</span><br><span class="line">    - PCR</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加分类页</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>categories 创建分类页</span><br><span class="line">在文章增加如下部分：</span><br><span class="line"></span><br><span class="line">categories: Hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>折叠</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>代码与文本对齐<br>需要三个反单引号和前面的文本对齐</p>
</li>
<li><p>跳转</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在需要跳转的前面增加</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用跳转</span><br><span class="line"><span class="bullet">-</span> [<span class="string">前言 基本概念的简介</span>](<span class="link">#1</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>折叠</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  文本和标题空一行，且文本前最好多一个table</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h2><p>制图神器，与github相关联，通过XML来描述图片元素之间关系，每次修改都会push到github，制图相关的还有XMind,StarUML,但是StarUML界面不太友好<br>目前使用到的是时序图，实现比较简单，但是发现想要在完成的时序图中间增加流程比较困难。</p>
<hr>
<h2 id="vim-tmux-cscope-ctags-fzf-taglist-ag"><a href="#vim-tmux-cscope-ctags-fzf-taglist-ag" class="headerlink" title="vim/tmux/cscope/ctags/fzf/taglist/ag"></a>vim/tmux/cscope/ctags/fzf/taglist/ag</h2><p>用了vim已经有5年了，一路上磕磕巴巴，插件也试了不少，tmux，fzf都是慢慢中间开始学过来的，终究没有从vim脱坑，配置文件改了又改，可惜一直没有记录，现在像一个大杂烩。故重新复习，总结，修炼。</p>
<h3 id="zsh学习"><a href="#zsh学习" class="headerlink" title="zsh学习"></a>zsh学习</h3><p>zsh配置到一半发现ubuntu子系统运行命令卡顿，也没有专门去处理。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">bash切到zsh,一般ubuntu会自带zsh.</span><br><span class="line">https:<span class="regexp">//ohmyz</span>.sh/<span class="comment">#install提示的命令无法下载，故选择安装包安装</span></span><br><span class="line"></span><br><span class="line">On MyZsh 安装包下载：https:<span class="regexp">//pan</span>.baidu.com/<span class="keyword">s</span>/<span class="number">1</span>NBEDP622Y-b0DPd6maHqpA   提取码：mfhe</span><br><span class="line"></span><br><span class="line">执行sh install.sh会进行安装，配置完成会提示配置文件为~<span class="regexp">/.zshrc.</span></span><br><span class="line"><span class="regexp">我们需要将一些~/</span>.bashrc下的客制化移动到~<span class="regexp">/.zshrc.</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">安装完成界面命令提示符已经发生改变，不在是之前的一大长串的当前路径，仅仅提示当前所在的文件名。</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">发现两个问题：</span></span><br><span class="line"><span class="regexp">1.bash和zsh 按键绑定不一样，fzf 配置文件允许报错。</span></span><br><span class="line"><span class="regexp">2.zsh 运行卡顿，不知道是不是我window下ubuntu子系统的缘故。</span></span><br></pre></td></tr></table></figure>

<h3 id="fzf记录"><a href="#fzf记录" class="headerlink" title="fzf记录"></a>fzf记录</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install highlight</span><br><span class="line"><span class="comment">#vim ~/.bashrc</span></span><br><span class="line"><span class="comment"># 搜索时高亮显示文件内容</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">FZF_DEFAULT_OPTS</span>=<span class="string">&quot;--height 40% --layout=reverse --preview &#x27;(highlight -O ansi &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500&#x27;&quot;</span></span><br><span class="line"><span class="comment"># 指定索引目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">FZF_DEFAULT_COMMAND</span>=<span class="string">&#x27;find code_pathXX&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#vim ~/.vimrc</span></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class="string">&#x27;dir&#x27;</span>: <span class="string">&#x27;~/.fzf&#x27;</span>, <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;./install --all&#x27;</span>  &#125;</span><br><span class="line">Plugin <span class="string">&#x27;junegunn/fzf.vim&#x27;</span></span><br><span class="line"><span class="builtin-name">set</span> runtimepath^=~/.vim/bundle/fzf</span><br><span class="line"><span class="builtin-name">set</span> rtp+=/root/.vim/bundle/fzf/bin/fzf</span><br><span class="line">nmap &lt;C-p&gt; :Files&lt;CR&gt;</span><br><span class="line">nmap &lt;C-e&gt; :Buffers&lt;CR&gt;</span><br><span class="line">nmap &lt;C-h&gt; :History&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;let g:fzf_action = &#123; &#x27;ctrl-e&#x27;: &#x27;edit&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="tmux记录"><a href="#tmux记录" class="headerlink" title="tmux记录"></a>tmux记录</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">当前绘画面板panel最大化 bind+z 在当前窗口有多panel时，如果需要当前panel最大化，这个方法是很方便的</span><br><span class="line">删除指定的<span class="keyword">session</span>           tmux kill-<span class="keyword">session</span> -t SESSION_NAME</span><br><span class="line">连接上某个已存在的<span class="keyword">session</span>   tmux a -t SESSION_NAME;</span><br><span class="line"><span class="keyword">session</span> 重命名   bind,:   输入 <span class="keyword">rename</span>-<span class="keyword">session</span> <span class="built_in">new</span>-<span class="type">name</span></span><br></pre></td></tr></table></figure>

<h2 id="HHKB"><a href="#HHKB" class="headerlink" title="HHKB"></a>HHKB</h2><p>HHKB使用手册<br><img src="/images/HHKB.png" alt="alt"></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">DIP开关说明：</span><br><span class="line">开关下为off，上为<span class="keyword">on</span></span><br><span class="line"><span class="number">1</span>和<span class="number">2</span> 设置为off, windows键盘设置模式</span><br><span class="line"><span class="number">3</span> <span class="keyword">on</span>为backspace, off为delete, 设置为<span class="keyword">on</span></span><br><span class="line"><span class="number">4</span>和<span class="number">5</span>搭配使用， <span class="number">5</span> <span class="keyword">on</span>， 会互换 al和◇功能</span><br><span class="line"><span class="number">4</span> <span class="keyword">on</span> ,◇功能设置为Fn</span><br><span class="line"><span class="number">6</span> <span class="keyword">on</span>启用唤醒</span><br></pre></td></tr></table></figure>

<p>上下左右跳转：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">将功能4设置为on</span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ [</span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ ;  </span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ &#x27; </span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ /</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>hexo</tag>
        <tag>draw.io</tag>
        <tag>fzf</tag>
      </tags>
  </entry>
  <entry>
    <title>session flush timeout学习</title>
    <url>/archives/8a2ade16.html</url>
    <content><![CDATA[<h1 id="session-flush-timeout学习"><a href="#session-flush-timeout学习" class="headerlink" title="session flush timeout学习"></a>session flush timeout学习</h1><ul>
<li>背景</li>
<li>超时处理流程</li>
<li>Condition处理</li>
<li>扩展</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前做过的mtkcam或者camx,都有对timeout进行调整的处理。当前碰到一个拍照没有图片返回的案例，故对这个案例进行分析。</p>
<a id="more"></a>

<p>异常log如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">RuninT:CameraTest2( 4357): take piture time out(TIMEOUT<span class="emphasis">_LIMIT/1000s) and quit test</span></span><br><span class="line"><span class="emphasis">RuninT:Utility( 4357): upfail:pref_</span>cameratake<span class="emphasis">_piture_</span>time<span class="emphasis">_out</span></span><br><span class="line"><span class="emphasis">RuninT:CameraTest2( 4357): onPause()</span></span><br><span class="line"><span class="emphasis">RuninT:CameraTest2( 4357): close Camera...</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"> camxhal3.cpp:1488 flush() HalOp: Begin FLUSH: 0xb4000070d3e2d040, logicalCameraId: 1, cameraId: 1</span></span><br><span class="line"><span class="emphasis"> CamX    (  834): [<span class="string">ERROR</span>][<span class="symbol">CORE   </span>] camxsession.cpp:125 WaitTillAllResultsAvailable() TimedWait for results timed out at 350 ms with error CamxResultETimeout! Pending results:</span></span><br><span class="line"><span class="emphasis"> CamX    (  834): [<span class="string">ERROR</span>][<span class="symbol">CORE   </span>] camxsession.cpp:138 WaitTillAllResultsAvailable() Flush Timedout</span></span><br><span class="line"><span class="emphasis"> CamX    (  834): [<span class="string">ERROR</span>][<span class="symbol">CORE   </span>] camxsession.cpp:284 FallbackFlush() Fallback TimedWait for results timed out at 100 ms with error CamxResultETimeout!</span></span><br><span class="line"><span class="emphasis"> CamX    (  834): [<span class="string">CORE_CFG</span>][<span class="symbol">CORE   </span>] camxnode.cpp:10938 Flush() Flushing Node JPEG_</span>SW:0 for requestId 1 on pipeline InternalZSLYuv2Jpeg:0</span><br><span class="line"> CamX    (  834): [<span class="string"> WARN</span>][<span class="symbol">JPEG   </span>] camxjpegswencnode.cpp:1577 CancelRequest() Flush called on requestId: 1, m<span class="emphasis">_currRequestId: 1, Main img engine ref: 0xb4000070d461c828</span></span><br><span class="line"><span class="emphasis"> CamX    (  834): [<span class="string"> WARN</span>][<span class="symbol">JPEG   </span>] camxjpegswencnode.cpp:1584 CancelRequest() Calling abort on main img encode, m_</span>bAbortCalledOnMain: 1</span><br></pre></td></tr></table></figure>

<p>当PCR处理时，如果一个node处理超时或者异常，这会直接影响与其有依赖关系的node, 则会对所处pipeline的处理造成延迟甚至堵塞。之后flush处理，需要对在PCR处理的session进行结果等待，这种情况属于isSessionFlush，如果在设置的时间阀值处理超时后，则需要对还在运行的pipeline进行处理。但无论是何种方面造成的延迟，通过时间阀数timeout来进行判定，理论上我们不允许等待时间太长。</p>
<hr>
<h2 id="超时处理流程"><a href="#超时处理流程" class="headerlink" title="超时处理流程"></a>超时处理流程</h2><p>下图是一个大体的超时处理流程，基于SessionFlush</p>
<p><img src="/images/flush-sessionWaittime.png" alt="alt"></p>
<p>camx的事务处理都是通过session来进行管理的，无论是session， pipeline， node都有一个timeout来进行判定是否处理超时。</p>
<h3 id="session-pipeline处理"><a href="#session-pipeline处理" class="headerlink" title="session-pipeline处理"></a>session-pipeline处理</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">//Func(<span class="name">selfWaitTillAllResultsAvailablecall</span>)</span><br><span class="line">sessionWaittime =Min( <span class="name">Max</span>(<span class="name">pipeline1Waittime</span>, pipeline2Waittime)+paddingtime, maxWaitTime )</span><br></pre></td></tr></table></figure>

<p>maxWaitTime 为camxsetting.xml中配置，为sessionMaxFlushWaitTime，默认设置为500ms<br>paddingtime    为camxsetting.xml中配置，为sessionResponseTimePadding，默认设置为50ms，用来描述pipeline除了PCR处理之外的其他动作用时。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">paddingTime = Utils::<span class="constructor">MaxUINT64(<span class="params">paddingTime</span>, <span class="params">paddingTime</span><span class="operator">*</span><span class="params">m_livePendingRequests</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><font color=#2196F3 >pipeline waittime为这条pipeline上 正在运行的node的最大reposeTime</font></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">result</span> = m_pWaitAllResultsAvailable-&gt;</span>T<span class="function"><span class="title">imedWait</span>(m_pWaitForResultsLock-&gt;</span>GetNativeHandle(), waitTime);</span><br></pre></td></tr></table></figure>

<p>下面是一些node的等待时间设置</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">Jpeg <span class="keyword">node</span><span class="title">为</span></span><br><span class="line"><span class="title">static</span> const UINT32 MaxDefaultFlushResponseTime     = <span class="number">450</span>; //default = <span class="number">300</span>           ///Default flush repsonse time (<span class="keyword">in</span> milliseconds)</span><br><span class="line"></span><br><span class="line">custom <span class="keyword">node</span><span class="title">为通过以下方式获取</span></span><br><span class="line"><span class="title">m_nodeCallbacks</span>.pGetFlushResponse(&amp;nodeResponse<span class="literal">Inf</span>o);</span><br><span class="line">在camxchinodeswmfnr.cpp节点中设置为：</span><br><span class="line">static const UINT32 MaxDefaultFlushResponseTime   = <span class="number">2000</span>;        ///<span class="tag">&lt; Default flush</span></span><br><span class="line"><span class="tag">repsonse time (in milliseconds)</span></span><br></pre></td></tr></table></figure>

<p>高通对其他节点有默认值为5ms<br>custom node中并出了关于responseTimeInMillisec的详细描述：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">// Each node needs <span class="built_in">to</span> publish <span class="keyword">a</span> response <span class="built_in">time</span> (<span class="built_in">milliseconds</span>) <span class="keyword">for</span> how <span class="keyword">long</span> <span class="keyword">it</span> takes <span class="built_in">to</span></span><br><span class="line">     <span class="comment"> // stop processing requests after flush call.</span></span><br><span class="line">     <span class="comment"> // During flush, session will consider this reponse time and will wait for nodes to flush gracefully.</span></span><br><span class="line">     <span class="comment"> // This response time can be computed dynamically based on the type of the node,</span></span><br><span class="line">     <span class="comment"> // otherwise default reponse time can be used.</span></span><br></pre></td></tr></table></figure>

<p>如果在sessionWaittime 之后还是没有获取到AllResult,则实际上还设置了100ms的额外等待时间sessionFallbackWaitTimemcamxsetting.xml中配置,为100ms。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">//Func(<span class="name">FallbackFlush</span>)</span><br><span class="line">result = waitCondition-&gt;TimedWait(<span class="name">m_pWaitForResultsLock-&gt;GetNativeHandle</span>(), fallbackWaitTime)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>如果这种情况下，还是没有处理完成（即存在pipeline的状态为STREAM_ON）,针对这种状态情况下的pipeline进行FlushPendingNodes操作</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (<span class="attribute">PipelineStatus</span>::STREAM_ON == m_pipelineData[pipelineIndex].pPipeline-&gt;GetPipelineStatus())</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="selector-tag">m_pipelineData</span><span class="selector-attr">[pipelineIndex]</span><span class="selector-class">.pPipeline-</span>&gt;<span class="selector-tag">FlushPendingNodes</span>();                                                                                                                                      </span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>

<p>这个时候已经认为超出了平台的忍耐，需要进行node flush处理。针对全部未处理完毕的request下的node，如果当前node处于Setup和Runing状态下的node进行flush。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">else</span> <span class="selector-tag">if</span> (<span class="attribute">PerRequestNodeStatus</span>::Setup == requestStatus || <span class="attribute">PerRequestNodeStatus</span>::Running == requestStatus)</span><br><span class="line">              &#123;    </span><br><span class="line">                  <span class="selector-tag">m_ppNodes</span><span class="selector-attr">[index]</span><span class="selector-tag">-</span>&gt;<span class="selector-tag">Flush</span>(requestId);                                                                                                                                                                </span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
<p>在node处理完毕，如果还有未处理完的pipeline,再通过100ms的超时来继续检查。</p>
<h3 id="node处理"><a href="#node处理" class="headerlink" title="node处理"></a>node处理</h3><p>node的flush包含如下处理：</p>
<ul>
<li>CancelRequest(requestId); 针对实现该操作的node, 比如<font color=#2196F3 >jpeg</font>， 有jpegswencnode(不同于custom node,继承于node类)，会对算法jpeg engine进行abort处理。没有实现的,比如<font color=#2196F3 >eis</font>，继续执行ChiNodeWrapper的实现，即等待RequestWaitTime，默认为5s，如果在这5s内，该node节点的ExecuteProcessRequest流程执行完毕，则允许m_pRequestProgress-&gt;<font color=#2196F3 >Broadcast</font>()来唤醒线程。如果超时，在raiserecoverysigabrt（camxsettings.xml ）配置为true的情况下，则会主动触发Abort信号。</li>
<li>.CSLFenceSignal通知fences失败处理。</li>
</ul>
<h2 id="Condition处理"><a href="#Condition处理" class="headerlink" title="Condition处理"></a>Condition处理</h2><p>关于相关的Condition处理： </p>
<ol>
<li>m_pWaitAllResultsAvailable   在NotifyProcessingDone通过m_pWaitAllResultsAvailable-&gt;Signal()唤醒，此时应该所有node都处理完毕，live pending requests为0。当然这要求有新的inject触发<br>线程ProcessResults处理，并在AdvanceMinExpectedResult处理中所有的result都返回的情况下使得canAdvance 为TRUE，从而进入NotifyProcessingDone流程。<font color=#2196F3 >这里发现一个相当有用的点，camxsettings.xml开启enableFPSLog能探测平均帧率CalculateResultFPS</font>。<br>这里的唤醒为<font color=#2196F3 >Signal</font>，使用pthread_cond_signal(&amp;m_conditionVar)来唤醒阻塞的指定线程。</li>
<li>FallbackFlush 因为isSessionFlush为TRUE，其实等待的唤醒同1.即为m_pWaitAllResultsAvailable，这里其实return是正常返回的。100ms超时</li>
<li>CancelRequest custom node处理。m_pRequestProgress-&gt;TimedWait 超时5s,需要ExecuteProcessRequest处理完毕之后进行<font color=#2196F3 >Broadcast</font>唤醒。通过pthread_cond_broadcast(&amp;m_conditionVar)来唤醒相关的阻塞线程，为啥需要唤醒多个线程，原因未知。5s超时</li>
<li>同2.</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>feature也存在timeout超时</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">m_maxFeatureExecutionTime</span> = CalculateMaxFeatureExecutionTime()<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>flush</tag>
      </tags>
  </entry>
  <entry>
    <title>单&amp;双摄configure stream流程</title>
    <url>/archives/8a2ade15.html</url>
    <content><![CDATA[<h1 id="单-amp-双摄configure-stream流程"><a href="#单-amp-双摄configure-stream流程" class="headerlink" title="单&amp;双摄configure stream流程"></a>单&amp;双摄configure stream流程</h1><ul>
<li>advance/feature2</li>
<li>hal3 callback chi</li>
<li>单摄usecase初始化处理</li>
<li>双摄usecase初始化处理</li>
</ul>
<h2 id="advance-feature2"><a href="#advance-feature2" class="headerlink" title="advance/feature2"></a>advance/feature2</h2><p>为什么起名为advance(提前)，代码架构直观可以发现一部分pipeline和node在FGM的pipeline和node之前创建。因此整个configure_stream大体上其实可以分为两个流程。<br>1.在SelectUsecaseConfig之后直接通过CameraUsecaseBase::Initialize去CreatePipeline的部分，这部分属于advance<br>2.PostUsecaseCreation去创建FGM,FGS,拿到FGD map,创建FPM，拿到全部feature instance的cap.之后对需要的每一个feature instance去initizlize,configure，最终创建pipeline，状态机成为Finalized.  </p>
<p>因此，把advance/feature2这部分放在首节，本文只针对advance 和 usecasemc部分描述，尽量不涉及feature部分</p>
<h2 id="hal3-callback-chi"><a href="#hal3-callback-chi" class="headerlink" title="hal3 callback chi"></a>hal3 callback chi</h2><p>configure_stream 和process_capture_request 都是framework下发，通过hal3处理，callback chi。process_capture_results则是由camx node 在PCR处理中主动callback.<br>process_capture_request 和 process_capture_result见双摄预览控制流程详解。</p>
<p>configure_stream入口为camxhal3entry.cpp,通过pHAL3-&gt;configure_streams进入hal3处理，hal3中调用pHALDevice-&gt;ConfigureStreams，在HALDevice::ConfigureStreams中主要进行三个处理.</p>
<a id="more"></a> 

<p>1.CheckValidStreamConfig 来判断framework下发的stream size和格式是否合规，在VTS测试中，就有测试size = MAX_INT这种情况测试。</p>
<p>2.chi_teardown_override_session  在CHIModuleInitialize前，应该释chi control 控制。</p>
<p>3.CHIModuleInitializ e进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pCHIAppCallbacks-&gt;chi_initialize_override_session(GetCameraId(),</span><br><span class="line">                                                  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">camera3_device_t</span>*&gt;(&amp;m_camera3Device),</span><br><span class="line">                                                  &amp;m_HALCallbacks,</span><br><span class="line">                                                  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">camera3_stream_configuration_t</span>*&gt;(pStreamConfigs),</span><br><span class="line">                                                  &amp;isOverrideEnabled,</span><br><span class="line">                                                  &amp;pPrivateData);</span><br></pre></td></tr></table></figure>

<p>chi_initialize_override_session则是通过调用com.qti.override.so中的chi_hal_override_entry函数赋值，此处不再赘述。详见双摄预览控制流程详解</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensioninterface.cpps</span></span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_initialize_override_session  = chi_initialize_override_session;</span><br></pre></td></tr></table></figure>

<p>故camx callback chi_initialize_override_session.通过pExtensionModule-&gt;InitializeOverrideSession进入ExtensionModule::InitializeOverrideSession。</p>
<p>在InitializeOverrideSession主要进行以下处理：</p>
<p>1.GetMatchingUsecase（）判断numPhysicalCameras&amp;&amp;num_streams获取到对应UsecaseId::MultiCamera.</p>
<p>2.通过CreateUsecaseObject来进行usecase的创建.通过pUsecaseMultiCamera-&gt;Initialize进行初始化,至此，才开始双摄usecase的处理</p>
<h3 id="单摄usecase初始化处理"><a href="#单摄usecase初始化处理" class="headerlink" title="单摄usecase初始化处理"></a>单摄usecase初始化处理</h3><p><img src="/images/configure_stream.png" alt="alt"></p>
<ol>
<li>初始化处理，包括target stream的判定和sensorIndexMode的获取， feature的初始化</li>
<li>针对每一条pipeline，设置对应的notify和result callback，方便pipeline对应的PCR处理完毕之后回调metadata/result和notify消息</li>
<li>CameraUsecaseBase::Initialize  通过ExtensionModules调用CreatePipelineDescriptor在camx通过Pipeline::Create创建pipeline,之后通过CreateNodes创建各node并进行初始化</li>
</ol>
<hr>
<h3 id="双摄usecase初始化处理"><a href="#双摄usecase初始化处理" class="headerlink" title="双摄usecase初始化处理"></a>双摄usecase初始化处理</h3><p>UsecaseMultiCamera::Initialize中</p>
<p>1.ClassifyTargetStream 针对下发的stream,根据流格式进行不同类型的流空间申请。</p>
<p>2.通过SelectUsecaseXML匹配到usecaseMap中的usecase XML，通过PruneUsecaseByStreamConfig对对应的pipeline 拓扑进行处理</p>
<p>3.CreateMultiCameraResource对每个摄像头的OutputSnapshotStream 和CreateMultiCameraResource等资源进行空间申请</p>
<p>4.CreateRDIResources 调用FindBestSensorMode获取对应的modeIndex等和CreateBufferManagers对MultiCameraResource的管理</p>
<p>5.CreatePipelines创建pipeline,CreateMetadataManager创建metadata</p>
<p>6.InitializeAdvanceFeatures 进行父类AdvanceCameraUsecase的初始化。双摄的feature设置为feature2 wrapper 0x40（单摄流程在CreateUsecaseObject会直接执行AdvanceCameraUsecase的初始化）</p>
<p>7.CreateSession 创建 REALTIME_SESSION session,针对拍照数据流，进行OfflineRequestThread线程处理</p>
<p>8.CreateMultiController来管理设备（比如在MultiRTBController::Create 中获取双摄参数配置等）</p>
<hr>
]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>configure_stream</tag>
      </tags>
  </entry>
  <entry>
    <title>单&amp;双摄预览控制流详解</title>
    <url>/archives/8a2ade14.html</url>
    <content><![CDATA[<h1 id="单-amp-双摄预览控制流详解"><a href="#单-amp-双摄预览控制流详解" class="headerlink" title="单&amp;双摄预览控制流详解"></a>单&amp;双摄预览控制流详解</h1><ul>
<li> Request从hal3到chi</li>
<li> chi端request双摄处理流程</li>
<li> camx端request双摄处理流程</li>
<li> Result返回</li>
</ul>
<hr>
<p>下图是PCR下发在hal3，chi，camx之间的简单流程(需要重新check双摄usecase和advance,Feature的关系，图中并不包括文中描述的Result返回部分)<br><img src="/images/PCR-hal-chi-camx.png" alt="alt"></p>
<hr>
<h2 id="Request从hal3到chi"><a href="#Request从hal3到chi" class="headerlink" title="Request从hal3到chi"></a>Request从hal3到chi</h2><html>
camxhal3.cpp中的g_jumpTableHAL3是framework与hal3的接口，对函数指针接口进行赋值，其中的configure_streams和process_capture_request分别是进行配流和预览时进行调用的。

<a id="more"></a> 

<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">//camxhal3.cpp </span><br><span class="line">JumpTableHAL3 g_jumpTableHAL3 =</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">    open,</span></span><br><span class="line"><span class="built_in">    get_number_of_cameras,</span></span><br><span class="line"><span class="built_in">    get_camera_info,</span></span><br><span class="line"><span class="built_in">    set_callbacks,</span></span><br><span class="line"><span class="built_in">    get_vendor_tag_ops,</span></span><br><span class="line"><span class="built_in">    open_legacy,</span></span><br><span class="line"><span class="built_in">    set_torch_mode,</span></span><br><span class="line"><span class="built_in">    init,</span></span><br><span class="line"><span class="built_in">    get_tag_count,</span></span><br><span class="line"><span class="built_in">    get_all_tags,</span></span><br><span class="line"><span class="built_in">    get_section_name,</span></span><br><span class="line"><span class="built_in">    get_tag_name,</span></span><br><span class="line"><span class="built_in">    get_tag_type,</span></span><br><span class="line"><span class="built_in">    close,</span></span><br><span class="line"><span class="built_in">    initialize,</span></span><br><span class="line"><span class="built_in">    configure_streams,</span>//配流</span><br><span class="line"><span class="built_in">    construct_default_request_settings,</span></span><br><span class="line"><span class="built_in">    process_capture_request,</span>//预览request中使用</span><br><span class="line"><span class="built_in">    dump,</span></span><br><span class="line"><span class="built_in">    flush,</span></span><br><span class="line"><span class="built_in">    camera_device_status_change,</span></span><br><span class="line"><span class="built_in">    torch_mode_status_change,</span></span><br><span class="line"><span class="built_in">    process_capture_result,</span></span><br><span class="line">    notify</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>目前针对process_capture_request流程进行分析。entry调用pHAL3-&gt;process_capture_request， 然后hal3中process_capture_request中调用pHALDevice-&gt;ProcessCaptureRequest(pRequest)，进入camxhaldevice.cpp。<br>在ProcessCaptureRequest中进行chi callback</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhaldevice.cpp  </span></span><br><span class="line">CamxResult HALDevice<span class="type">::ProcessCaptureRequest</span>(  </span><br><span class="line"><span class="params">...</span></span><br><span class="line">    result = GetCHIAppCallbacks()-&gt;chi_override_process_request  <span class="comment">//</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里获取到一个chi_hal_callback_ops_t实例，这是一个chi callback的结构体，对其函数指针chi_override_process_request进行调用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhaldevice.cpp </span></span><br><span class="line">CAMX_INLINE chi_hal_callback_ops_t* HALDevice::GetCHIAppCallbacks() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (HAL3Module::GetInstance()-&gt;GetCHIAppCallbacks());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而实例中chi_override_process_request函数指针的赋值为读取chi库中的chi_hal_override_entry指针地址来进行调用赋值。这里LibMap和LibGetAddr是我们之后经常会见到的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhal3module.cpp</span></span><br><span class="line">...</span><br><span class="line">                CAMX_LOG_INFO(CamxLogGroupHAL, <span class="string">&quot;opening CHI Module - %s&quot;</span>, &amp;moduleFileName[fileIndex]);</span><br><span class="line">                m_hChiOverrideModuleHandle = OsUtils::LibMap(&amp;moduleFileName[fileIndex]);<span class="comment">//打开com.qti.override.so库</span></span><br><span class="line">...</span><br><span class="line">           <span class="keyword">if</span> (<span class="literal">NULL</span> != m_hChiOverrideModuleHandle)</span><br><span class="line">            &#123;</span><br><span class="line">                CHIHALOverrideEntry funcCHIHALOverrideEntry =</span><br><span class="line">                    <span class="keyword">reinterpret_cast</span>&lt;CHIHALOverrideEntry&gt;(</span><br><span class="line">                        CamX::OsUtils::LibGetAddr(m_hChiOverrideModuleHandle, <span class="string">&quot;chi_hal_override_entry&quot;</span>));<span class="comment">//获取chi_hal_override_entry地址</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != funcCHIHALOverrideEntry)</span><br><span class="line">                &#123;</span><br><span class="line">                    funcCHIHALOverrideEntry(&amp;m_ChiAppCallbacks);<span class="comment">//chi这边调用进行函数指针赋值</span></span><br></pre></td></tr></table></figure>

<p>chi 端通过chi_hal_override_entry 进行函数指针赋值</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensioninterface.cpp</span></span><br><span class="line">void chi_hal_override_entry(</span><br><span class="line">    chi_hal_callback_ops_t* callbacks)</span><br><span class="line">&#123;</span><br><span class="line">    ExtensionModule* pExtensionModule = ExtensionModule::GetInstance();</span><br><span class="line"></span><br><span class="line">    CHX_ASSERT(NULL != callbacks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NULL != pExtensionModule)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_get_num_cameras              = chi_get_num_cameras;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_get_camera_info              = chi_get_camera_info;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_get_info                     = chi_get_info;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_initialize_override_session  = chi_initialize_override_session;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_finalize_override_session    = chi_finalize_override_session;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_override_process_request     = chi_override_process_request;<span class="comment">//Request callback 赋值</span></span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_teardown_override_session    = chi_teardown_override_session;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_extend_open                  = chi_extend_open;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_extend_close                 = chi_extend_close;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_remap_camera_id              = chi_remap_camera_id;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_modify_settings              = chi_modify_settings;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_get_default_request_settings = chi_get_default_request_settings;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_override_flush               = chi_override_flush;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_override_dump                = chi_override_dump;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，hal3端对request的callback调用其实是调用chi端的chi_override_process_request<br>以下为chi端的Request处理流程</p>
</html>

<hr>
<h2 id="chi端request双摄处理流程"><a href="#chi端request双摄处理流程" class="headerlink" title="chi端request双摄处理流程"></a>chi端request双摄处理流程</h2><html>
在OverrideProcessRequest处理中，通过双摄cameraid对应的usecase实例指针，进行ProcessCaptureRequest方法调用。

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensionmodule.cpp</span></span><br><span class="line">result = m_pSelectedUsecase<span class="literal">[<span class="identifier">logicalCameraId</span>]</span>-&gt;<span class="constructor">ProcessCaptureRequest(<span class="params">pCaptureRequest</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>而双摄usecase实例指针在CreateUsecaseObject中获取，这个在之前双摄configure_stream中创建。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">m_pSelectedUsecase<span class="literal">[<span class="identifier">logicalCameraId</span>]</span> = m_pUsecaseFactory-&gt;<span class="constructor">CreateUsecaseObject(&amp;<span class="params">m_logicalCameraInfo</span>[<span class="params">logicalCameraId</span>],<span class="params">selectedUsecaseId</span>，StreamConfig)</span>;</span><br></pre></td></tr></table></figure>

<p>这里将一个UsecaseMultiCamera* 赋值给Usecase* </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxusecaseutils.cpp</span></span><br><span class="line">pUsecase = UsecaseMultiCamera::<span class="constructor">Create(<span class="params">pLogicalCameraInfo</span>, <span class="params">pStreamConfig</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>要注意，UsecaseMultiCamera其实是Usecase的子类，所以这里可以赋值。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">U<span class="function"><span class="title">secase</span> --&gt;</span>CameraUsecaseBase</span><br><span class="line">C<span class="function"><span class="title">ameraUsecaseBase</span>--&gt;</span>AdvancedCameraUsecase</span><br><span class="line">A<span class="function"><span class="title">dvancedCameraUsecase</span>--&gt;</span> UsecaseMultiCamera</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxadvancedcamerausecase.h </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraUsecaseBase</span> :</span> <span class="keyword">public</span> Usecase  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdvancedCameraUsecase</span> :</span> <span class="keyword">public</span> CameraUsecaseBase</span><br><span class="line"><span class="comment">//chxusecasemc.h </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsecaseMultiCamera</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> AdvancedCameraUsecase</span><br></pre></td></tr></table></figure>

<p>之后在ProcessCaptureRequest 中进行ExecuteCaptureRequest调用时，其实是UsecaseMultiCamera下的方法调用，单摄是在AdvancedCameraUsecase中处理。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>chxusecase.cpp </span><br><span class="line">  result = ExecuteCaptureRequest(pRequest);<span class="regexp">//</span> 这里详细讲述控制流，不针对 ProcessCaptureRequest下的buffer和pRequest-&gt;settings（Metadata）做处理解释。</span><br></pre></td></tr></table></figure>

<p>在ExecuteCaptureRequest便是针对不同情况，进行buffer copy和GenerateRealtimeRequest调用</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxusecasemc.cpp</span></span><br><span class="line"> result = <span class="constructor">GenerateRealtimeRequest(&amp;<span class="params">request</span>, NULL)</span>; </span><br></pre></td></tr></table></figure>

<p>GenerateRealtimeRequest主要做了两件事，第一件进行processSessionRequest，第二件为ActivatePendingPipeline。在<br>processSessionRequest进行submitRequest，在ActivatePendingPipeline中进行activepipeline.</p>
<ul>
<li>submitRequeste</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxusecase.cpp</span></span><br><span class="line">    <span class="keyword">if</span> (IsFlushing != GetFlushStatus())</span><br><span class="line">    &#123;</span><br><span class="line">        result = ExtensionModule::GetInstance()-&gt;SubmitRequest(pSubmitRequestData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//chxextensionmodule.cpp</span></span><br><span class="line">CDKResult ExtensionModule::SubmitRequest(</span><br><span class="line">    CHIPIPELINEREQUEST* pSubmitRequest)</span><br><span class="line">&#123;</span><br><span class="line">    CDKResult result = CDKResultSuccess;</span><br><span class="line"></span><br><span class="line">    result = g_chiContextOps.pSubmitPipelineRequest(m_hCHIContext, pSubmitRequest);<span class="comment">//camx调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>activepipeline</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensionmodule.cpp</span></span><br><span class="line"><span class="function">CDKResult <span class="title">ExtensionModule::ActivatePipeline</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">    CHIHANDLE             sessionHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">    CHIPIPELINEDESCRIPTOR pipelineHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_chiContextOps.pActivatePipeline(m_hCHIContext, sessionHandle, pipelineHandle, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而g_chiContextOps函数指针的的赋值，则全部来自于camera.qcom.so中ChiEntry函数的调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OSLIBRARYHANDLE handle  = ChxUtils::LibMap(pChiDriver);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != handle)</span><br><span class="line">&#123;</span><br><span class="line">    m_libraryHandle = handle;</span><br><span class="line">    CHX_LOG(<span class="string">&quot;CHI Opened driver library&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PCHIENTRY funcPChiEntry = <span class="keyword">reinterpret_cast</span>&lt;PCHIENTRY&gt;(ChxUtils::LibGetAddr(handle, <span class="string">&quot;ChiEntry&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != funcPChiEntry)</span><br><span class="line">    &#123;</span><br><span class="line">        CHX_LOG(<span class="string">&quot;CHI obtained ChiEntry point function&quot;</span>);</span><br><span class="line"></span><br><span class="line">        funcPChiEntry(&amp;g_chiContextOps);</span><br></pre></td></tr></table></figure>

<p>在camxchi.cpp中赋值如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxchi.cpp</span></span><br><span class="line">    pChiContextOps-&gt;pSubmitPipelineRequest     = CamX::ChiSubmitPipelineRequest;</span><br><span class="line">    pChiContextOps-&gt;pActivatePipeline          = CamX::ChiActivatePipeline;</span><br></pre></td></tr></table></figure>
</html>

<p>其实SubmitRequest和ActivatePipeline主要做了两件事session streamon 和 session ProcessCaptureRequest处理</p>
<hr>
<h2 id="camx端request双摄处理流程"><a href="#camx端request双摄处理流程" class="headerlink" title="camx端request双摄处理流程"></a>camx端request双摄处理流程</h2><html>
在ChiContext::SubmitRequest中，首先通过CheckValidInputRequest检查各个request的input ChiStreamBuffer， Validate output ChiStreamBuffer，InputMetadata，OutputMetadata是否有效。之后通过pSession->StreamOn和pSession->ProcessCaptureRequest进行pipeline初始化处理和PCR处理。

<p>在ChiContext::ActivatePipeline中，  其实也是进行session streamon。</p>
<h3 id="Session-streamon处理（FinalizeDeferPipeline-pipeline-streamon）"><a href="#Session-streamon处理（FinalizeDeferPipeline-pipeline-streamon）" class="headerlink" title="Session streamon处理（FinalizeDeferPipeline+ pipeline streamon）"></a>Session streamon处理（FinalizeDeferPipeline+ pipeline streamon）</h3><h4 id="session-streamon"><a href="#session-streamon" class="headerlink" title="session streamon"></a>session streamon</h4><p>主要处理如下：如果pipeline没有初始化完成，调用FinalizeDeferPipeline去完成初始化，之后再进行pipeline streamon.</p>
<p>FinalizeDeferPipeline主要包括以下处理：</p>
<ul>
<li>FinalizeInitialization完成node的初始化</li>
<li>CreateBufferManagers调用ImageBufferManager来完成node相关port buffer的创建。</li>
<li>NotifyPipelineCreated调用<font color=#2196F3 >PostPipelineCreate</font> 来进行node的延迟处理。比如eis node会完成eis lib的初始化。</li>
<li>WaitForDeferPipelineCreate等待PostPipelineCreate单线程处理完毕再FilterAndUpdatePublishSet来进行，通过GetMetadataPublishList来获取<font color=#2196F3 >custom node的metadata list</font> .比如nodeWrapper.</li>
</ul>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">CamxResult ChiNodeWrapper::QueryMetadataPublishList(</span><br><span class="line">    NodeMetadataList* pPublistTagList)</span><br><span class="line">&#123;</span><br><span class="line">    CamxResult <span class="attr">result</span> = CamxResultSuccess;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">NULL</span> == pPublistTagList)</span><br><span class="line">    &#123;</span><br><span class="line">        CAMX_LOG_ERROR(CamxLogGroupMeta, <span class="string">&quot;Node::%s pPublistTagList NULL&quot;</span>, NodeIdentifierString());</span><br><span class="line">        <span class="attr">result</span> = CamxResultEInvalidArg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">NULL</span> == m_nodeCallbacks.pQueryMetadataPublishList)</span><br><span class="line">    &#123;</span><br><span class="line">        pPublistTagList-&gt;<span class="attr">tagCount</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ChiNodeMetadataList chiMetadataList;</span><br><span class="line"></span><br><span class="line">        chiMetadataList.<span class="attr">hNodeSession</span> = m_hNodeSession;</span><br><span class="line">        chiMetadataList.<span class="attr">size</span>         = sizeof(ChiNodeMetadataList);</span><br><span class="line"></span><br><span class="line">        <span class="attr">result</span> = m_nodeCallbacks.pQueryMetadataPublishList(&amp;chiMetadataList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="attr">CamxResultSuccess</span> == result) &amp;&amp; (<span class="number">0</span> &lt; chiMetadataList.tagCount))</span><br><span class="line">        &#123;</span><br><span class="line">            pPublistTagList-&gt;<span class="attr">tagCount</span>        = chiMetadataList.tagCount;</span><br><span class="line">            pPublistTagList-&gt;<span class="attr">partialTagCount</span> = chiMetadataList.partialTagCount;</span><br><span class="line">            Utils::Memcpy(pPublistTagList-&gt;tagArray, chiMetadataList.tagArray,</span><br><span class="line">                          chiMetadataList.tagCount * sizeof(UINT32));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PrepareStreamOn 进行node streamon之前的相关配置，比如IFE node，完成IFEdsp的相关配置。比如sensor node 通过PrepareSensorUpdate完成参数曝光配置。<font color=#2196F3 >pipeline状态设置为FINALIZED</font>。</li>
</ul>
<h4 id="pipeline-streamon"><a href="#pipeline-streamon" class="headerlink" title="pipeline streamon"></a>pipeline streamon</h4><p>主要进行如下处理：</p>
<ul>
<li>CallNodeAcquireResources 调用AcquireResources进一步完成streamon前的配置，比如在sensor node中，完成当前sensor resolution setting的sensor寄存器写入和CSI的相关配置。全部node处理完毕，<font color=#2196F3 >pipeline状态设置为RESOURCES_ACQUIRED</font>。</li>
<li>通过StreamOn调用CSLStreamOn，CSLHwStreamOnKMDHardwares进一步调用deviceOp.StreamOn来完成node对应设备的启动。pipeline状态设置为<font color=#2196F3 >PipelineStatus::STREAM_ON</font></li>
<li>各node通过nNodeStreamOn调用AllocateBuffers完成buffer的申请和custom node callback的 pOnStreamOn调用。</li>
</ul>
</html>


<h3 id="pSession-gt-ProcessCaptureRequest处理"><a href="#pSession-gt-ProcessCaptureRequest处理" class="headerlink" title="pSession-&gt;ProcessCaptureRequest处理"></a>pSession-&gt;ProcessCaptureRequest处理</h3><p>在Session::ProcessCaptureRequest中，最重要的便是通过PostJob方法将capture request加入到线程中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//camxsession.cpp</span></span><br><span class="line">                <span class="string">VOID*</span> <span class="string">pData[]</span> <span class="string">=</span> &#123;<span class="string">this</span>, <span class="literal">NULL</span>&#125;<span class="string">;</span></span><br><span class="line">                <span class="string">result</span>        <span class="string">=</span> <span class="string">m_pThreadManager-&gt;PostJob(m_hJobFamilyHandle,</span></span><br><span class="line">                                                          <span class="literal">NULL</span><span class="string">,</span></span><br><span class="line">                                                          <span class="string">&amp;pData[0],</span></span><br><span class="line">                                                          <span class="literal">FALSE</span><span class="string">,</span></span><br><span class="line">                                                          <span class="literal">FALSE</span><span class="string">);</span></span><br></pre></td></tr></table></figure>

<p>在configure_stream早期，已经CHISession::Initialize队列中通过m_pThreadManager-&gt;RegisterJobFamily注册了该线程对应的处理函数。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxchisession.cpp</span></span><br><span class="line">        result = m_pThreadManager-&gt;RegisterJobFamily(ThreadJobCallback,</span><br><span class="line">                                                     wrapperName,</span><br><span class="line">                                                     <span class="built_in">NULL</span>,</span><br><span class="line">                                                     JobPriority<span class="type">::Normal</span>,</span><br><span class="line">                                                     <span class="literal">TRUE</span>,</span><br><span class="line">                                                     &amp;m_hJobFamilyHandle);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JobRegistry::RegisterNewJob过程中，将m_hJobFamilyHandle赋值并与TheadJobCallback绑定。</span></span><br><span class="line"><span class="comment">//camxthreadjobregistry.cpp</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line">        pRegisteredJob-&gt;funcAddr        = jobFuncAddr;</span><br><span class="line"><span class="params">...</span></span><br><span class="line">        *phJob = PackJobHandleFromRegisteredJob(pRegisteredJob);</span><br><span class="line">        pRegisteredJob-&gt;hRegister = *phJob;</span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure>

<p>线程触发ThreadJobCallback去处理此次的job.ThreadJobCallback调用ThreadJobExecute，进行ProcessResults和ProcessRequest处理，在第一帧request处理时，由于没有NotifyResult处理过CbType,类似Buffer,EarlyMetadata,Metadata，故直接进行ProcessRequest处理。</p>
<p>ProcessRequest处理逻辑是依次session, pipeline, node处理。</p>
<h4 id="Session-ProcessRequest处理"><a href="#Session-ProcessRequest处理" class="headerlink" title="Session::ProcessRequest处理"></a>Session::ProcessRequest处理</h4><p>在Session::ProcessRequest()处理中，调用OpenRequest去进行预期曝光时间下发，但是如果第一帧(request0)PCR不是在pipeline streamon的状态下,则不进行CSLOpenRequest 下发预期曝光时间处理。通过对SessionRequest素组遍历来处理对应CaptureRequest对应pipeline的PCR. SetupRequestData获取到需要的pipelineProcessRequestData数据后，进行ProcessRequest(&amp;pipelineProcessRequestData)处理。</p>
<h4 id="Pipeline-ProcessRequest处理"><a href="#Pipeline-ProcessRequest处理" class="headerlink" title="Pipeline::ProcessRequest处理"></a>Pipeline::ProcessRequest处理</h4><ul>
<li>首先调用CallNodeAcquireResources()将一个不是acquired状态的pipeline设置为acquired状态，<font color=#2196F3 >在之前pipeline streamon()已经调用过此接口函数，并将pipeline置为RESOURCES_ACQUIRED</font></li>
<li>之后对此次request中的stream里用到的node的进行SetupRequest处理，SetupRequestOutputPorts &amp;&amp; SetupRequestInputPorts 设置input 和 output端口。//todo </li>
</ul>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxnode.cpp</span></span><br><span class="line">    <span class="variable"><span class="keyword">if</span></span> (<span class="variable"><span class="literal">TRUE</span></span> == <span class="function"><span class="title">IsNodeEnabled</span>())</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable"><span class="class">result</span></span> = <span class="function"><span class="title">SetupRequestOutputPorts</span>(<span class="variable">pPerBatchedFrameInfo</span>);<span class="comment">//之后调用CSLFenceCallback去更新依赖性（NonSinkPort）或者调用m_pSession-&gt;NotifyResult(SinkPort/pipeline上的最后一个node)</span></span></span><br><span class="line"><span class="function">        <span class="variable"><span class="class">result</span></span> = <span class="title">SetupRequestInputPorts</span>(<span class="variable">pPerBatchedFrameInfo</span>);</span></span><br><span class="line"><span class="function">        *<span class="variable">pIsNodeEnabled</span> = <span class="variable"><span class="literal">TRUE</span></span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>AddDeferredNode </li>
</ul>
<ol>
<li>将所有非pipeline flush状态的node加入到DeferredRequestQueue管理的m_readyNodes队列。因为刚开始此时 全部的node其实未经过PCR处理，Property &amp;&amp; buffer &amp;&amp; chiFence dependency等依赖性未检查&amp;&amp;pDependencyUnit 为NULL</li>
<li>对node property &amp;&amp; buffer &amp;&amp; chi fence 进行依赖检查并添加</li>
</ol>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span> ((0 == pDependency-&gt;</span>propertyCount) &amp;&amp;</span><br><span class="line">    (<span class="number">0</span> == <span class="function"><span class="title">pDependency</span>-&gt;</span>fenceCount)    &amp;&amp;</span><br><span class="line">    (<span class="number">0</span> == <span class="function"><span class="title">pDependency</span>-&gt;</span>chiFenceCount))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Node doesn&#x27;t have any dependencies so it should be ready.</span></span><br><span class="line">    <span class="function"><span class="title">m_pReadyQueueLock</span>-&gt;</span>Lock();</span><br><span class="line">    m_readyNodes.InsertToTail(pNode);</span><br><span class="line">    <span class="function"><span class="title">m_pReadyQueueLock</span>-&gt;</span>Unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    m_deferredNodes.InsertToTail(pNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>DispatchReadyNodes</li>
</ul>
<ol>
<li>延迟node链表处理。对于满足要求的deferredNode list中的node，进行依赖dependency移除并通过UpdateOrRemoveDependency将property &amp;&amp;fence(buffer)&amp;&amp;chi fence 都满足的node从deferredNode list移动到readyNodes.如果不满足移动要求，则继续deferredNode list的下一个node dependency更新处理</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// Move the node to the ready queue</span></span><br><span class="line">    LightweightDoublyLinkedListNode* pDeferred = m_deferredNodes.<span class="constructor">FindByValue(<span class="params">pDependency</span>)</span>;</span><br><span class="line">    m_deferredNodes.<span class="constructor">RemoveNode(<span class="params">pDeferred</span>)</span>;</span><br><span class="line"></span><br><span class="line">    m_pReadyQueueLock-&gt;<span class="constructor">Lock()</span>;</span><br><span class="line">    m_readyNodes.<span class="constructor">InsertToTail(<span class="params">pDeferred</span>)</span>;</span><br><span class="line">    m_pReadyQueueLock-&gt;<span class="constructor">Unlock()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>对所有readyNodes中的结点通过PostJob进行DeferredWorkerWrapper处理，并移除readyNodes链表。PostJob会触发线程管理函数DeferredWorkerWrapper，注册在 DeferredRequestQueue::Initialize初始化阶段。</li>
</ol>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxdeferredrequestqueue.cpp</span></span><br><span class="line">CamxResult DeferredRequestQueue<span class="type">::Initialize</span>（</span><br><span class="line"><span class="params">...</span></span><br><span class="line"></span><br><span class="line">    result = m_pThreadManager-&gt;RegisterJobFamily(DeferredWorkerWrapper,</span><br><span class="line">                                                 wrapperName,</span><br><span class="line">                                                 <span class="built_in">NULL</span>,</span><br><span class="line">                                                 JobPriority<span class="type">::Normal</span>,</span><br><span class="line">                                                 <span class="literal">FALSE</span>,</span><br><span class="line">                                                 &amp;m_hDeferredWorker);     </span><br></pre></td></tr></table></figure>

<p>而DeferredWorkerWrapper调用DeferredWorkerCore，进行node的ProcessRequest处理。</p>
<p>在Node::ProcessRequest处理中，通过BindInputOutputBuffers将backing buffer与node的 input , output buffer绑定.</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//camxnode.cpp</span><br><span class="line">        // <span class="keyword">If</span> LateBinding <span class="keyword">is</span> enabled, <span class="keyword">input</span> <span class="keyword">and</span> output ImageBuffers may <span class="keyword">not</span> have backing <span class="keyword">buffers</span> yet.</span><br><span class="line">        // <span class="keyword">If</span> derived nodes <span class="keyword">set</span> needBuffersOnDependencyMet <span class="keyword">for</span> this sequenceId, that means, derived</span><br><span class="line">        // node <span class="keyword">is</span> going <span class="keyword">to</span> <span class="keyword">access</span> <span class="keyword">input</span>, output <span class="keyword">buffers</span> now. Lets bind <span class="keyword">buffers</span> <span class="keyword">to</span> ImageBuffers <span class="keyword">if</span> <span class="keyword">not</span> yet.</span><br><span class="line">            result = BindInputOutputBuffers(executeProcessData.pEnabledPortsInfo, <span class="keyword">TRUE</span>, <span class="keyword">TRUE</span>);</span><br></pre></td></tr></table></figure>

<p>之后再执行各个node实例中的ExecuteProcessRequest，在ChiNodeWrapper::ExecuteProcessRequest中进行buffer传递到chibuffer之后，进行m_nodeCallbacks.pProcessRequest(&amp;info)调用获取结果(custom node 调用不再详述)，并更新metadata.</p>
<p>node处理结束之后，PostJob调用进行ProcessFenceCallback处理.分为NonSink和Sink两种处理。NonSink（NonSinkPortFenceSignaled）调用UpdateDependency更新依赖，然后通过DisPatchReadyNodes继续处理。而sinkPort（SinkPortFenceSignaled）则通过m_pSission-&gt;NotifyResult向framework返回处理结果。</p>
<hr>
<h2 id="Result返回"><a href="#Result返回" class="headerlink" title="Result返回"></a>Result返回</h2><h3 id="camx-callback-return-chi-（ChiProcessPartialCaptureResult-callback）"><a href="#camx-callback-return-chi-（ChiProcessPartialCaptureResult-callback）" class="headerlink" title="camx callback return chi （ChiProcessPartialCaptureResult callback）"></a>camx callback return chi （ChiProcessPartialCaptureResult callback）</h3><p>在全部的node 的metadata或者sink Port的buffer处理完毕，我们就需要从node回调，经pipeline，session回调，最终将需要的数据capture result通过m_chiCallBacks(ChiProcessPartialCaptureResult/ChiProcessCaptureResult)返回给chi.</p>
<p>camx也需要通过m_chiCallBacks.ChiNotify进行SOF或者SHUTTER,ERROR通知。(ChiNotify)</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chi-cdk/api/common/chi.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ChiCallBacks</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/// @brief CHI app callback method to send back the capture results</span></span><br><span class="line">    <span class="keyword">void</span> (*ChiProcessCaptureResult)(</span><br><span class="line">        CHICAPTURERESULT*   pCaptureResult,</span><br><span class="line">        VOID*               pPrivateCallbackData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief Asynchronous notification callback method</span></span><br><span class="line">    <span class="keyword">void</span> (*ChiNotify)(</span><br><span class="line">        <span class="keyword">const</span> CHIMESSAGEDESCRIPTOR* pMessageDescriptor,</span><br><span class="line">        VOID*                       pPrivateCallbackData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief CHI app callback method to send back the partial capture results</span></span><br><span class="line">    <span class="keyword">void</span> (*ChiProcessPartialCaptureResult)(</span><br><span class="line">         CHIPARTIALCAPTURERESULT*   pCaptureResult,</span><br><span class="line">         VOID*                      pPrivateCallbackData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; CHICALLBACKS;</span><br></pre></td></tr></table></figure>
<p>回调实例m_chiCallBacks赋值在Session::Initialize。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxsession.cpp</span></span><br><span class="line">Utils::<span class="constructor">Memcpy(&amp;<span class="params">m_chiCallBacks</span>, <span class="params">pCreateData</span>-&gt;<span class="params">pChiAppCallBacks</span>, <span class="params">sizeof</span>(ChiCallBacks)</span>);</span><br></pre></td></tr></table></figure>

<p>pChiAppCallBacks为ChiContext::CreateSession中的ChiCallBacks*    pCallbacks参数，通过CHISession::Create传递到Session::Initialize中。</p>
<p>此时可以发现（ChiCreateSession）CreateSession为chi callback camx时使用的，同之前提到过得ChiActivatePipeline.</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">pChiContextOps-&gt;pCreateSession             = CamX::ChiCreateSession;</span><br></pre></td></tr></table></figure>

<p>在chi端为ExtensionModule::CreateSession调用进行callback, 在configure stream流程中已经研究过，Session::Create调用pSession-&gt;Initialize，进一步CreateSession。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">m_hSession</span> = ExtensionModule::GetInstance()-&gt;CreateSession(&amp;sessionCreateData)<span class="comment">; </span></span><br></pre></td></tr></table></figure>

<p>在双摄usecase初始化时，会进行预览session的创建。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>chxusecasemc.cpp</span><br><span class="line">CreateSession(REALTIME_SESSION);</span><br></pre></td></tr></table></figure>

<p>在这里，才是真正m_chiCallBacks赋值的参数，在camx ChiProcessPartialCaptureResult回调时，其实调用的是上层的SessionCbPartialCaptureResult</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">CDKResult UsecaseMultiCamera::CreateSession(</span><br><span class="line">    UINT32 sessionId)&#123;</span><br><span class="line">    <span class="comment">//camx真正的回调</span></span><br><span class="line">    callbacks.ChiNotify                       = SessionCbNotifyMessage;</span><br><span class="line">    callbacks.ChiProcessCaptureResult         = SessionCbCaptureResult;</span><br><span class="line">    callbacks.ChiProcessPartialCaptureResult  = SessionCbPartialCaptureResult;</span><br><span class="line">            m_sessionInfo[sessionId].m_pSession = Session::Create(pPipelines,</span><br><span class="line">                                                              numOfPipelines,</span><br><span class="line">                                                              <span class="variable">&amp;callbacks</span>,</span><br><span class="line">                                                              <span class="variable">&amp;</span>m_sessionInfo[sessionId].m_privateData); </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在SessionCbPartialCaptureResult处理中，针对双摄预览REALTIME_SESSION，进行ProcessDriverPartialCaptureResult处理，通过ProcessAndReturnPartialMetadataFinishedResults中的Usecase::ReturnFrameworkResult调用，ExtensionModule::GetInstance()-&gt;ReturnFrameworkResult(pResult, cameraID);返回到hal3中处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensionmodule.cpp</span></span><br><span class="line"><span class="function">VOID <span class="title">ExtensionModule::ReturnFrameworkResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">camera3_capture_result_t</span>* pResult,</span></span></span><br><span class="line"><span class="function"><span class="params">    UINT32 cameraID)</span></span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     m_HALOps[cameraID].process_capture_result(m_logicalCameraInfo[cameraID].m_pCamera3Device, pResult);</span><br><span class="line">     ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="process-capture-result-amp-amp-notify-chi-hal3-hook"><a href="#process-capture-result-amp-amp-notify-chi-hal3-hook" class="headerlink" title="process_capture_result &amp;&amp; notify   chi-hal3 hook"></a>process_capture_result &amp;&amp; notify   chi-hal3 hook</h3><p>该函数指针的赋值在ExtensionModule::SetHALOps中赋值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensionmodule.cpp</span></span><br><span class="line"><span class="keyword">VOID</span> ExtensionModule::SetHALOps(</span><br><span class="line">    uint32_t             logicalCameraId,</span><br><span class="line">    <span class="keyword">const</span> chi_hal_ops_t* pHalOps)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pHalOps)</span><br><span class="line">    &#123;</span><br><span class="line">        m_HALOps[logicalCameraId].process_capture_result = pHalOps-&gt;process_capture_result;                                                                                          m_HALOps[logicalCameraId].notify_result = pHalOps-&gt;notify_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ExtensionModule::InitializeOverrideSession中进行了SetHALOps(logicalCameraId, chiHalOps);</p>
<p>最终发现，为camx callback进行了函数指针赋值。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">callbacks</span>-&gt;</span>chi_initialize_override_session  = chi_initialize_override_session;</span><br></pre></td></tr></table></figure>
<p>在HALDevice::CHIModuleInitialize中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxpipeline.cpp</span></span><br><span class="line">        pCHIAppCallbacks-&gt;chi_initialize_override_session(GetCameraId(),</span><br><span class="line">                                                          <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">camera3_device_t</span>*&gt;(&amp;m_camera3Device),</span><br><span class="line">                                                          &amp;m_HALCallbacks,</span><br><span class="line">                                                          <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">camera3_stream_configuration_t</span>*&gt;(pStreamConfigs),</span><br><span class="line">                                                          &amp;isOverrideEnabled,</span><br><span class="line">                                                          &amp;pPrivateData);</span><br></pre></td></tr></table></figure>
<p>hal和chi的hook之前已经描述过，这里不再详述<br>在HALDevice::Initialize时，将函数指针赋值，然后通过pCHIAppCallbacks-&gt;chi_initialize_override_session将chi_hal_ops回调给到m_HALOps，供ExtensionModule回调</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//camxhaldevice.cpp</span><br><span class="line">        m_HALCallbacks.process_capture_result = ProcessCaptureResult<span class="comment">;</span></span><br><span class="line">        m_HALCallbacks.notify_result          = Notify<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>ProcessCaptureResult时(result最终返回处理)，最终进行以下处理</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhaldevice.cpp</span></span><br><span class="line">        <span class="function"><span class="title">pHALDevice</span>-&gt;</span>UpdateFrameworkRequestBufferResult(pCamera3CaptureResult, pFrameworkRequest);</span><br><span class="line">        <span class="function"><span class="title">pHALDevice</span>-&gt;</span>G<span class="function"><span class="title">etCallbackOps</span>()-&gt;</span><span class="function"><span class="title">process_capture_result</span>(pHALDevice-&gt;</span>GetCallbackOps(), pCamera3_CaptureResult); <span class="comment">//最终为camxhal3.cpp下的process_capture_result调用</span></span><br></pre></td></tr></table></figure>
<p>pHALDevice-&gt;GetCallbackOps()获取到m_pCamera3CbOps，则它是在hal3 initialize是进行pHALDevice-&gt;SetCallbackOps(pCamera3CbOpsAPI) 设置的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhaldevice.h</span></span><br><span class="line">    <span class="function">CAMX_INLINE VOID <span class="title">SetCallbackOps</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">camera3_callback_ops_t</span>* pCamera3CbOps)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pCamera3CbOps = pCamera3CbOps;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而hal3 initialize是通过entry initialize来调用的，调用前设置了参数</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhal3entry.cpp</span></span><br><span class="line">    <span class="keyword">if</span> (NULL != pCamera3CbOps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">pCamera3CbOps</span>-&gt;</span>cbOps.process_capture_result = process_cpature_result;</span><br><span class="line">        <span class="function"><span class="title">pCamera3CbOps</span>-&gt;</span>cbOps.notify = notify;</span><br><span class="line">        <span class="function"><span class="title">pCamera3CbOps</span>-&gt;</span>pCamera3Device = pCamera3DeviceAPI;</span><br><span class="line">        <span class="function"><span class="title">pCamera3CbOps</span>-&gt;</span>pCbOpsAPI = pCamera3CbOpsAPI;</span><br><span class="line">        <span class="function"><span class="title">pCamera3CbOpsAPI</span> = &amp;(pCamera3CbOps-&gt;</span>cbOps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">g_HAL3Entry</span>.m_pCbOpsLock-&gt;</span>Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">return</span> pHAL3-&gt;</span>initialize(pCamera3DeviceAPI, pCamera3CbOpsAPI);</span><br></pre></td></tr></table></figure>

<p>则函数则指向entry下的process_capture_result。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhal3entry.cpp</span></span><br><span class="line"></span><br><span class="line">    pHAL3-&gt;process<span class="constructor">_capture_result(<span class="params">pCamera3CbOps</span>-&gt;<span class="params">pCbOpsAPI</span>, <span class="params">pCaptureResultAPI</span>)</span>; </span><br><span class="line">    <span class="comment">//上面等价于--&gt;     hal3中的process_capture_result(entry initialize时的参数camera3_callback_ops_t*，并非 pCamera3CbOpsAPI = &amp;(pCamera3CbOps-&gt;cbOps)处理过后的)</span></span><br></pre></td></tr></table></figure>

<p>hal3中的process_capture_result实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhal3.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_capture_result</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">struct</span> camera3_callback_ops*  pCamera3CbOpsAPI,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> camera3_capture_result_t*     pCaptureResultAPI</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">pCamera3CbOpsAPI-&gt;process_capture_result(pCamera3CbOpsAPI, pCaptureResultAPI); <span class="comment">//简化代码，方便理解</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>而entry初始化时的参数camera3_callback_ops_t* 则是用来回调framework.</p>
<h3 id="双摄request-camx端处理"><a href="#双摄request-camx端处理" class="headerlink" title="双摄request camx端处理"></a>双摄request camx端处理</h3><p>一个request的处理分为大致两类，一类为result处理，一类为notify处理。</p>
<h4 id="result处理"><a href="#result处理" class="headerlink" title="result处理"></a>result处理</h4><p>result处理中PartialMetadata和Metadata处理类似，一旦node处理Metadata完成调用，将该node对应request的MetadataComplete标记为1，同时CamxAtomicIncU将request对应numNodesMetadataDone的技术+1，当全部完成时，通过pipeline，session依次回调到NotifyResult。</p>
<p>NotifyResult不光处理result，同时还会对Error,Async,SOF等通过DispatchNotify进行 m_chiCallBacks.ChiNotify调用。<br>针对PartialMetadata，通过DispatchPartialMetadata进行m_chiCallBacks.ChiProcessPartialCaptureResult调用。比如双摄情况下就会回调到UsecaseMultiCamera下的SessionCbNotifyMessage和SessionCbPartialCaptureResult;</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxchisession.cpp</span></span><br><span class="line">m_chiCallBacks.<span class="constructor">ChiProcessPartialCaptureResult(<span class="params">pPartialCaptureResult</span>, <span class="params">m_pPrivateCbData</span>)</span>; </span><br></pre></td></tr></table></figure>

<p>而Metadata和buffer的处理都是通过InjectResult来处理的，故回调都是双摄下的SessionCbCaptureResult，不同于PartialMetadata。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxsession.cpp</span></span><br><span class="line"> <span class="constructor">InjectResult(ResultType::MetadataOK, &amp;<span class="params">pPayload</span>-&gt;<span class="params">metaPayload</span>, <span class="params">pPayload</span>-&gt;<span class="params">sequenceId</span>, <span class="params">pPrivData</span>, <span class="params">pipelineIndex</span>)</span>; </span><br></pre></td></tr></table></figure>

<p>在InjectResult处理中，除了MetaBuffer缓冲区的填充，重要的还有为此次的request 触发对应的result.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxsession.cpp</span></span><br><span class="line">        ...</span><br><span class="line">        MetadataPayload* pMetaPayload = <span class="keyword">static_cast</span>&lt;MetadataPayload*&gt;(pPayload);</span><br><span class="line"></span><br><span class="line">        pHolder-&gt;pMetaBuffer[<span class="number">0</span>] = pMetaPayload-&gt;pMetaBuffer[<span class="number">0</span>];</span><br><span class="line">        pHolder-&gt;pMetaBuffer[<span class="number">1</span>] = pMetaPayload-&gt;pMetaBuffer[<span class="number">1</span>];</span><br><span class="line">        ...</span><br><span class="line">        CamxAtomicStore32(&amp;m_aCheckResults, TRUE);<span class="comment">//允许session ProcessResult</span></span><br><span class="line">        ...</span><br><span class="line">        result        = m_pThreadManager-&gt;PostJob(m_hJobFamilyHandle, <span class="literal">NULL</span>, &amp;pData[<span class="number">0</span>], FALSE, FALSE);</span><br></pre></td></tr></table></figure>

<p>正如我们之前讲到的触发线程处理ThreadJobExecute</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxchisession.cpp</span></span><br><span class="line">    <span class="keyword">while</span> (TRUE == <span class="keyword">static_cast</span>&lt;BOOL&gt;(CamxAtomicLoad32(&amp;m_aCheckResults)))&gt;&gt;InjectResult触发设置m_aCheckResults为<span class="literal">true</span>，触发ProcessResults处理调用</span><br><span class="line">    &#123;</span><br><span class="line">        CamxAtomicStore32(&amp;m_aCheckResults, FALSE);</span><br><span class="line">        result = ProcessResults();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在ProcessResults处理中，我们通过DispatchResults调用m_chiCallBacks.ChiProcessCaptureResult将所有的results返回给Framework</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxsession.cpp</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; numResults)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Finally dispatch all the results to the Framework</span></span><br><span class="line">        <span class="constructor">DispatchResults(&amp;<span class="params">m_pCaptureResult</span>[0], <span class="params">numResults</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>PCR</tag>
      </tags>
  </entry>
</search>
