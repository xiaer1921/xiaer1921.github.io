<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Camx-Feature2</title>
    <url>/archives/8a2ade18.html</url>
    <content><![CDATA[<h1 id="Feature2"><a href="#Feature2" class="headerlink" title="Feature2"></a>Feature2</h1><p>当我们想要去实现特定功能的时候，我们需要使用FGM管理实现feature功能的各类组件 并根据feature拓扑创建对应的pipeline去实现，这些组件包括FGS,FPM,线程池，TBM。本篇文章将从feature组件的创建以及各组件的功能组合如何实现特定feature来描述，而关联<a href="https://sholck.top/archives/8a2ade15.html">底层的pipeline建立和node处理</a>，<a href="https://sholck.top/archives/8a2ade14.html">PCR逻辑</a>已经在其他文章详细描述，本文不再重新描述。</p>
<p><a id="0"></a></p>
<ul>
<li><a href="#1">feature2框架介绍</a></li>
<li><a href="#2">configure_stream</a></li>
<li><a href="#3">feature instance连接</a></li>
<li><a href="#4">feature-PCR</a></li>
<li><a href="#5">TBM详解</a></li>
<li><a href="#6">TM详解</a></li>
</ul>
<p><a id="1"></a></p>
<h2 id="feature2框架介绍"><a href="#feature2框架介绍" class="headerlink" title="feature2框架介绍"></a>feature2框架介绍</h2><p>下图feature2大致的组件框架。</p>
<p><img src="/images/feature2/feature2-frame.png" alt="alt"></p>
<a id="more"></a> 

<p><a id="2"></a></p>
<h2 id="configure-stream"><a href="#configure-stream" class="headerlink" title="configure_stream"></a>configure_stream</h2><p>在configure_stream阶段，主要为  </p>
<ol>
<li>Feature2Wrapper的创建  </li>
<li>Feature2GraphManager（FGM）和TargetBufferManager（TBM）的创建</li>
</ol>
<p>大致流程如下，不包括feature instance的initialize到finalized.</p>
<p><img src="/images/feature2/feature2-initialize.png" alt="alt"></p>
<h3 id="Feature2Wrapper的创建"><a href="#Feature2Wrapper的创建" class="headerlink" title="Feature2Wrapper的创建"></a>Feature2Wrapper的创建</h3><ol>
<li>针对部分usecase,根据下发的opMode，选择对应的feature场景，比如快拍支持</li>
</ol>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="function"><span class="params">(StreamConfigModeFastShutter == ExtensionModule::GetInstance()-&gt;GetOpMode(m_cameraId))</span></span></span><br><span class="line"><span class="function">&#123;    </span></span><br><span class="line"><span class="function">    <span class="title">enabledAdvanceFeatures</span> = <span class="title">AdvanceFeatureSWMF</span>|<span class="title">AdvanceFeatureMFNR</span>|<span class="title">AdvanceFeatureAIDE</span>;</span></span><br><span class="line"><span class="function">&#125;    </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>log如下</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">chxadvancedcamerausecase</span><span class="selector-class">.cpp</span><span class="selector-pseudo">:6513</span> <span class="selector-tag">SelectFeatures</span>() <span class="selector-tag">SelectFeatures</span>(), <span class="selector-tag">enabled</span> <span class="selector-tag">feature</span> <span class="selector-tag">mask</span><span class="selector-pseudo">:40</span></span><br><span class="line"><span class="selector-tag">chxadvancedcamerausecase</span><span class="selector-class">.cpp</span><span class="selector-pseudo">:6585</span> <span class="selector-tag">SelectFeatures</span>() <span class="selector-tag">num</span> <span class="selector-tag">features</span> <span class="selector-tag">selected</span><span class="selector-pseudo">:1</span>, <span class="selector-tag">FeatureType</span> <span class="selector-tag">for</span> <span class="selector-tag">preview</span><span class="selector-pseudo">:7</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>针对单双摄设置Fk stream,双摄额外设置主辅摄的internalInputStream，包括RDI和FD，这两个stream已经在mc usecase申请资源CreateMultiCameraResource中空间申请并填充。</li>
<li>Feature2Wrapper初始化<br>a. m_internalInputStreamMap  映射usecase内部的output stream到feature内部external stream,比如双摄的RDI stream<br>b. m_pFrameworkStreams 管理fk stream</li>
</ol>
<h3 id="FGM和TBM的创建"><a href="#FGM和TBM的创建" class="headerlink" title="FGM和TBM的创建"></a>FGM和TBM的创建</h3><ul>
<li><a href="#0">返回主目录</a></li>
</ul>
<h4 id="FGM创建"><a href="#FGM创建" class="headerlink" title="FGM创建"></a>FGM创建</h4><ol>
<li>设置该feature2wrapper的cb，用来处理PCR的处理</li>
<li>feature 的input stream指针空间单独copy，CloneStreamConfig申请空间过大，需check 并告知qcom</li>
<li>设置该FGMd的cb，处理chi的notify和feature的message</li>
<li>依次创建FGS，FPM，线程管理</li>
<li>pGetFGDListForConfig对FGS拿到的FGD和FPM从all feature instance中hook中拿到的cap中match和过滤</li>
<li>CreateVirtualSuperGraph对single feature graph进行过滤并整合为VirtualSuperGraph，同时确定包含的feature instance</li>
<li>对feature instance进行create,configure,Finalized</li>
</ol>
<h5 id="FGS创建"><a href="#FGS创建" class="headerlink" title="FGS创建"></a>FGS创建</h5><ol>
<li><p>通过LoadFeatureGraphSelectorOps和FGS库挂hook，hook为ChiFeature2GraphSelectorOpsEntry<br>，回调对象指针为m_feature2GraphSelectorOps。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chifeature2graphmanager</span>.cpp:<span class="number">345</span> LoadFeatureGraphSelectorOps() No graph selector library files found in the path /vendor/lib<span class="number">64</span>/camera/components/feature<span class="number">2</span>/oem</span><br><span class="line"><span class="attribute">chifeature2graphmanager</span>.cpp:<span class="number">365</span> LoadFeatureGraphSelectorOps() Loading from:/vendor/lib<span class="number">64</span>/com.qti.feature<span class="number">2</span>.gs.mannar.so, size:<span class="number">72</span>, pCreateOps:<span class="number">0</span>x<span class="number">736644</span>f<span class="number">658</span>K</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过pCreate进行FGS的create   </p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">a. BuildCameraIdSet根据全部逻辑id的类型分类，由m_cameraIdMap管理  cameraID<span class="comment">-----type</span></span><br><span class="line"></span><br><span class="line">b. 设置FGD Table的描述GraphDescriptorTables ，主要为三部分构成。 </span><br><span class="line">pCameraIdDescriptorNameSet  camera <span class="keyword">set</span> <span class="keyword">type</span>对应的一个FGDescriptorName集合</span><br><span class="line">pFeatureGraphDescriptorsMap  FGD <span class="keyword">name</span>到FDG 的映射</span><br><span class="line">pFeatureGraphDescKeysMap  包含camera <span class="keyword">set</span> <span class="keyword">type</span>和FDGnam等，用来表示该平台支持的feature <span class="keyword">instance</span>。</span><br><span class="line"></span><br><span class="line">c. rFeatureDescNameSet featureDescName集合的设置，根据<span class="keyword">memory</span>分别设置。  </span><br><span class="line">这三部分都是由两部分组成，OEM赋值和PopulateAllTables插入</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>FGS的initialze 通过AssignStreamIntentPerFwkStream针对FGS的输出流进行stream intent判定。enum ChiStreamIntent</li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chifeature2graphselector</span>.cpp:<span class="number">8565</span> AssignStreamIntentPerFwkStream() Feature<span class="number">2</span>Mapping: Stream Intent CHI_STREAM_INTENT_PREVIEW for <span class="number">0</span>xb<span class="number">400007402</span>c<span class="number">56488</span> format: <span class="number">0</span>x<span class="number">22</span> width: <span class="number">1440</span> height: <span class="number">1080</span> usage: <span class="number">0</span>x<span class="number">900</span></span><br><span class="line"><span class="attribute">chifeature2graphselector</span>.cpp:<span class="number">8565</span> AssignStreamIntentPerFwkStream() Feature<span class="number">2</span>Mapping: Stream Intent CHI_STREAM_INTENT_STILL_CAPTURE for <span class="number">0</span>xb<span class="number">400007402</span>c<span class="number">81</span>c<span class="number">48</span> format: <span class="number">0</span>x<span class="number">21</span> width: <span class="number">4160</span> height: <span class="number">3120</span> usage: <span class="number">0</span>x<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="FPM创建-参数传入FGS设置的m-featureDescNameSet"><a href="#FPM创建-参数传入FGS设置的m-featureDescNameSet" class="headerlink" title="FPM创建 参数传入FGS设置的m_featureDescNameSet"></a>FPM创建 参数传入FGS设置的m_featureDescNameSet</h5><ol>
<li>ProbeChiFeature2Features获取所有feature instance的hook,hook为ChiFeature2OpsEntry，打印并将每一个feature的cap和m_featureDescNameSet进行匹配，那么匹配成功的代表运行功能支持。同时将这个cap和所对应的feature instance 的回调指针ops插入到m_featureVersionToOpsMap.<br>下面是sm4350feature instance支持的cap  </li>
</ol>
<table>
<thead>
<tr>
<th>anchorsync</th>
<th>demux</th>
<th>derivedoffline</th>
<th>frameselect</th>
<th>fusion</th>
<th>mcreprocrt</th>
</tr>
</thead>
<tbody><tr>
<td>AnchorSync</td>
<td>Demux</td>
<td>Yuv2Yuv</td>
<td>FrameSelect</td>
<td>FUSION</td>
<td>MultiCameraReprocessRealtime</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>realtimeserializer</th>
<th>rtmcx</th>
<th>serializer</th>
<th>statsregeneration</th>
<th>rawhdr</th>
</tr>
</thead>
<tbody><tr>
<td>RealTimeSerializer</td>
<td>RealTimeMCX</td>
<td>Serializer</td>
<td>StatsRegeneratio</td>
<td>RawHDR</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>fusion</th>
<th>mfsr</th>
</tr>
</thead>
<tbody><tr>
<td>FUSION</td>
<td>MFSR</td>
</tr>
<tr>
<td>BOKEH</td>
<td>MFNR</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>hdr</th>
<th>rt</th>
</tr>
</thead>
<tbody><tr>
<td>HDR</td>
<td>RealTime</td>
</tr>
<tr>
<td>ThreeFrameMFHDR</td>
<td>RealTimeNZSL</td>
</tr>
<tr>
<td>TwoFrameMFHDR</td>
<td>RealTimeWithSWRemosaic</td>
</tr>
</tbody></table>
<p>下面是 generic 的Cap:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Bayer2Yuv</span> JPEG  FormatConvertor YUVReprocess  RealtimePostProcessor Yuv<span class="number">2</span>Yuv  SWRemosaic  Y<span class="number">2</span>YRTDiffDimen Y<span class="number">2</span>YMultiPreview  PostFusionIPE </span><br></pre></td></tr></table></figure>

<p>对feature具体的描述在<br>chi-cdk/oem/qcom/feature2/chifeature2graphselector/descriptors/generated/features</p>
<h5 id="TM（CHIThreadManage）创建"><a href="#TM（CHIThreadManage）创建" class="headerlink" title="TM（CHIThreadManage）创建"></a>TM（CHIThreadManage）创建</h5><p>通过StartThreads对线程池管理的16个线程进行触发设置，触发WorkerThreadBody</p>
<h5 id="FGD匹配"><a href="#FGD匹配" class="headerlink" title="FGD匹配"></a>FGD匹配</h5><p>pGetFGDListForConfig通过m_featureVersionToOpsMap和FGD Table去进行整合。匹配规则如下</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 该camera逻辑id必须在m_cameraIdMap存在，且cameraType和pCameraIdDescriptorNameSet中一致,这样可以确定到一个FGD <span class="keyword">name</span> set集合，都是该cameraType对应的</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> ((std::find(rCameraIdSet.begin(), rCameraIdSet.end(), cameraId) == rCameraIdSet.end()) || (rPair.first != cameraType))</span><br><span class="line">              &#123;    </span><br><span class="line">                  continue;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line"><span class="number">2</span>. 对FGDname set进行遍历，确定对应的FGD</span><br><span class="line">                  const ChiFeature2GraphDesc&amp; rFeatureGraphDesc =</span><br><span class="line">                      <span class="function"><span class="title">pGraphDescriptorTables</span>-&gt;</span><span class="function"><span class="title">pFeatureGraphDescriptorsMap</span>-&gt;</span><span class="built_in">at</span>(pDescriptorName); </span><br><span class="line">                </span><br><span class="line"><span class="number">3</span>. 针对单双摄FGD 对过滤，规则为IsSkipFeatureGraph，对FGD下的所有feature instance检查，匹配cap,cap所属的Ops,FGD下有多个instance的比如：MultiCameraFusionFeatureGraphFeatureInstanceDescs</span><br><span class="line">    a.低内存设备不走cds graph.</span><br><span class="line">    b.ChiFeature2Type判断，设置在feature instance中，比如SWMFFeatureDescriptor和SWMFAIDenoiserInstanceProps的组成在部分平台不支持</span><br><span class="line">    c.feature2掩码进行过滤的，比如IsSWMFEnabled()和IsAIDEEnabled()</span><br><span class="line">    d.每一个feature instance <span class="keyword">name</span>去和我们从feature动态库中拿到的去匹配</span><br><span class="line">    e.非rawinput的，不处理Bayer2YUVJPEG和Bayer2YUV这两个graph</span><br><span class="line">    </span><br><span class="line">下面是普通预览不开MFNR的过滤</span><br><span class="line">IsSkipFeatureGraph() Skip Raw reprocess graph: Bayer2YUV</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph Bayer2YUV</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph RTBayer2YUVSWMFJPEG</span><br><span class="line">IsSkipFeatureGraph() Skip Raw reprocess graph: Bayer2YUVJPEG</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph Bayer2YUVJPEG</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph RTBayer2YUVSWMFAIDenoiserJPEG</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph RTBayer2YUVSWMF</span><br><span class="line">GetAllFeatureGraphDescriptors() Removing feature graph RTBayer2YUVSWMFAIDenoiser</span><br><span class="line"></span><br><span class="line">用到的single garph有</span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>R<span class="function"><span class="title">ealtimeFG</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTM<span class="function"><span class="title">emcpyYUV</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTB<span class="function"><span class="title">ayer2YUVHDRT1JPEG</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTB<span class="function"><span class="title">ayer2YUVJPEG</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTB<span class="function"><span class="title">ayer2YUV</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTB<span class="function"><span class="title">ayer2YUVCDSJPEG</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTR<span class="function"><span class="title">awHDRBayer2YUVJPEGOEM</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTR<span class="function"><span class="title">awHDRBayer2YUVOEM</span>-&gt;</span><span class="number">0</span></span><br><span class="line">I<span class="function"><span class="title">nsert</span> single graph:cameraID 0-&gt;</span>RTB<span class="function"><span class="title">ayer2YUVCDS</span>-&gt;</span><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. CallCloneGraphDescriptor对匹配成功的graph进行clone并插入到m_clonedFeatureGraphDescriptorsMap和push到m_pFeature2GraphDescs vector中</span><br><span class="line"><span class="number">5</span>. UpdateInstancePropsForGraph 对该graph下的所有feature instance ， ExtSrcLinks, ExtSinkLinks,InternalLinks进行instanceProps设置，默认设置为该逻辑id下的物理id.</span><br><span class="line">针对有input stream为yuv或者预览格式的，且输出为YUV的，增加YUVReprocessFeatureGraphDescriptor，如果输出为JPEG的，增加YUVJPEGReprocessFeatureGraphDescriptor。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Feature-Instance整合"><a href="#Feature-Instance整合" class="headerlink" title="Feature Instance整合"></a>Feature Instance整合</h5><p>该整合为所匹配到的graph下的所有fature instance, extSrcLinks，extSinkLinks,internalLinks的整合</p>
<ol>
<li>CreateVirtualSuperGraph创建，通过MergeFeatureGraphs进行整合，单摄命名为VirtualSuperGraph，双摄命名为MultiCameraVirtualSuperGraph，整合规则即feature instance和links的合并，见feature instance connect小节理解<br>整合完毕的feature instance打印如下：</li>
</ol>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">CreateFeatureInstances</span>() <span class="selector-pseudo">:VirtualSuperGraph</span>, <span class="selector-tag">numFeatureInstances</span><span class="selector-pseudo">:7</span>, <span class="selector-tag">logicalCameraId</span><span class="selector-pseudo">:0</span></span><br></pre></td></tr></table></figure>

<p>到目前为止，我们已经拿到了全部我们需要的feature instance，links规则,之后通过FPM去管理。</p>
<h5 id="feature-instance-create–-gt-Finalized"><a href="#feature-instance-create–-gt-Finalized" class="headerlink" title="feature instance create–&gt;Finalized"></a>feature instance create–&gt;Finalized</h5><ul>
<li><a href="#0">返回主目录</a><br>下面是一份详细的流程处理</li>
</ul>
<p><img src="/images/feature2/feature2-configure-finalize.png" alt="alt"></p>
<h5 id="feature-instace-create"><a href="#feature-instace-create" class="headerlink" title="feature instace create"></a>feature instace create</h5><p>这部分主要由CreateFeatureInstances去实现<br>遍历virtualGraph的成员feature instance,下面以RealTime去描述</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> DoStreamNegotiation 将feature instance name去和m_featureVersionToOpsMap(包含instance对应的hook Ops)match,然后进行stramNegotiation.</span><br><span class="line"></span><br><span class="line">chifeature2featurepool.cpp:<span class="number">217</span> DoStreamNegotiation() feature:RealTime, pStreamNegotiation:<span class="number">0x736685b998</span>K</span><br><span class="line"></span><br><span class="line">假如为ZSL snapshot negotiation,</span><br><span class="line">    a. clone RDI stream，这个RDI stream定义在chifeature2utils.h，</span><br><span class="line">    b. 通过GetSensorOutputDimension去获取RDI stream的witdh,high,bpp，方便设置格式,默认bpp为<span class="number">10</span>,那么格式为RAW10</span><br><span class="line">    c. MapStreamPerFeature对feature input stream(fk stream/RDI+FD)进行流类型判定，并添加对应的ChiFeature2Type映射。</span><br><span class="line">    </span><br><span class="line"> chifeature2utils.cpp:<span class="number">339</span> MapStreamPerFeature() Enter :numStreams:<span class="number">2</span>                                                                                       </span><br><span class="line"> chifeature2utils.cpp:<span class="number">351</span> MapStreamPerFeature() Classify: <span class="number">0xb400007402c56488</span> format: <span class="number">34</span> width: <span class="number">1440</span> height: <span class="number">1080</span> gralloc:<span class="number">0x900</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">357</span> MapStreamPerFeature() Identified Preview</span><br><span class="line"> chifeature2utils.cpp:<span class="number">351</span> MapStreamPerFeature() Classify: <span class="number">0xb400007402c81c48</span> format: <span class="number">33</span> width: <span class="number">4160</span> height: <span class="number">3120</span> gralloc:<span class="number">0x3</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">417</span> MapStreamPerFeature() Identified JPEG</span><br><span class="line"> chifeature2utils.cpp:<span class="number">457</span> MapStreamPerFeature() Map Streams Scan:</span><br><span class="line"> chifeature2utils.cpp:<span class="number">458</span> MapStreamPerFeature()     numPreview: <span class="number">1</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">459</span> MapStreamPerFeature()     numVideo: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">460</span> MapStreamPerFeature()     numAllYUV: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">461</span> MapStreamPerFeature()     num4kYUV: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">462</span> MapStreamPerFeature()     numJPEG: <span class="number">1</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">463</span> MapStreamPerFeature()     numRAW: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">464</span> MapStreamPerFeature()     numZSL: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">465</span> MapStreamPerFeature()     ThumbnailYUV: <span class="number">0</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">466</span> MapStreamPerFeature()     numB2YOut: <span class="number">1</span></span><br><span class="line"> chifeature2utils.cpp:<span class="number">603</span> MapStreamPerFeature() Final classification: Stream:<span class="number">0xb400007402c56488</span> feature:<span class="number">0</span> format: <span class="number">34</span> width: <span class="number">1440</span> height: <span class="number">1080</span> gralloc: <span class="number">0x900</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>通过对流类型判断，根据streamIntent去clone对应类型的stream,如果没有该streamIntent(CHI_STREAM_INTENT_POSTVIEW)的stream，那么按照chifeature2utils.h设置的PostViewStreamsOutput来clone.</span><br><span class="line"></span><br><span class="line">DoStreamNegotiation() <span class="number">0</span></span><br><span class="line">DoStreamNegotiation() Accepting_Streams_REALTIME Stream Stream:<span class="number">0xb400007402c56488</span> Format: <span class="number">34</span> width: <span class="number">1440</span> height: <span class="number">1080</span> gralloc: <span class="number">0x900</span></span><br><span class="line">DoStreamNegotiation() <span class="number">1</span></span><br><span class="line">DoStreamNegotiation() Rejecting_Streams_REALTIME Stream Stream:<span class="number">0xb400007402c81c48</span> Format: <span class="number">33</span> width: <span class="number">4160</span> height: <span class="number">3120</span> gralloc: <span class="number">0x3</span></span><br><span class="line">DoStreamNegotiation() Cloning Video Stream</span><br><span class="line">DoStreamNegotiation() numStream:<span class="number">6</span>    &lt;&lt;可见协商该feature instance 的<span class="keyword">out</span> stream为<span class="number">6</span>条</span><br><span class="line"></span><br><span class="line">这<span class="number">6</span>条应该是preview,postview,RDI,IdeaRaw,video,yuv(部分平台为fd),之后可以通过ClassifyStream 函数log中的streamIntent来判断</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 通过UpdateInstancePropsInGraphDesc更新feature instance和links(针对多摄feature instance ).</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建feature instance</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">DoFeatureCreate最终调用ChiFeature2Base::Initialize进行feature instance父类的初始化</span><br><span class="line"></span><br><span class="line">a.注册线程ProcessAsyncFeatureJobs。</span><br><span class="line"></span><br><span class="line">chithreadmanager.cpp:<span class="number">178</span> RegisterJobFamily() Async Job Registered isSync: <span class="number">1</span>, m_numThreads: <span class="number">16</span></span><br><span class="line">chithreadmanager.cpp:<span class="number">187</span> RegisterJobFamily() Registered Fn. Async_RealTime_Create (<span class="number">0x736b27f618</span>) RegJobHandle <span class="number">4294967296</span>, NumOfRegisteredJob <span class="number">1</span></span><br><span class="line"></span><br><span class="line">b. ClassifyStream 根据流的streamType，决定push到pInputStreams还是pOutputStreams</span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">1440</span> X <span class="number">1080</span> Format = <span class="number">0x22</span> Usage = <span class="number">0x900</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb400007402c56488</span> (<span class="built_in">int</span>ent =<span class="number">1</span> bpp = <span class="number">0</span>) PhyCamId = </span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">320</span> X <span class="number">240</span> Format = <span class="number">0x23</span> Usage = <span class="number">0x0</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb4000073e2c95710</span> (<span class="built_in">int</span>ent = <span class="number">6</span> bpp = <span class="number">0</span>) PhyCamId = (<span class="literal">null</span>)</span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">4208</span> X <span class="number">3120</span> Format = <span class="number">0x25</span> Usage = <span class="number">0x20002</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb4000073e2c96580</span> (<span class="built_in">int</span>ent = <span class="number">8</span> bpp = <span class="number">10</span>) PhyCamId = (<span class="literal">null</span>)</span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">4096</span> X <span class="number">3072</span> Format = <span class="number">0x20</span> Usage = <span class="number">0x20002</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb4000073e2c95780</span> (<span class="built_in">int</span>ent = <span class="number">2</span> bpp = <span class="number">0</span>) PhyCamId = (<span class="literal">null</span>)</span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">1440</span> X <span class="number">1080</span> Format = <span class="number">0x23</span> Usage = <span class="number">0x0</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb4000073e2c95630</span> (<span class="built_in">int</span>ent = <span class="number">3</span> bpp = <span class="number">0</span>) PhyCamId = (<span class="literal">null</span>)</span><br><span class="line">chifeature2base.cpp:<span class="number">4664</span> ClassifyStream() Name = RealTime: Res: <span class="number">640</span> X <span class="number">480</span> Format = <span class="number">0x23</span> Usage = <span class="number">0x0</span> Type = <span class="number">0</span> STREAM = <span class="number">0xb4000073e2c97700</span> (<span class="built_in">int</span>ent = <span class="number">7</span> bpp = <span class="number">0</span>) PhyCamId = (<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">c.设置最大的m_maxFeatureExecutionTime,判断是否超时处理。</span><br><span class="line"></span><br><span class="line">d.创建的全部feature instance如下</span><br><span class="line">CreateFeatureInstances() RealTime(<span class="number">0xb400007472ce27f0</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">CreateFeatureInstances() RawHDR(<span class="number">0xb400007472c52f10</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">CreateFeatureInstances() Bayer2Yuv(<span class="number">0xb400007472c83f70</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; </span><br><span class="line">CreateFeatureInstances() Bayer2Yuv(<span class="number">0xb400007472cd5050</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">16384</span>&#125;</span><br><span class="line">CreateFeatureInstances() HDR(<span class="number">0xb400007472c96530</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; </span><br><span class="line">CreateFeatureInstances() JPEG(<span class="number">0xb400007472c8acd0</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">CreateFeatureInstances() Yuv2Yuv(<span class="number">0xb400007472cb5c50</span>) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;<span class="number">33</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">总共<span class="number">7</span>个instance，对应</span><br><span class="line">CreateFeatureInstances() :VirtualSuperGraph, numFeatureInstances:<span class="number">7</span>, logicalCameraId:<span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>CDS feature enable要求：</p>
<ol>
<li>feature instance type 为B2Y</li>
<li>instanceFlags.isCDSSnapshot 为1</li>
<li>该feature下的output流尺寸必须为4的倍数</li>
<li>针对QCFA，必须为instanceFlags.isCDSSnapshot &amp;&amp; instanceFlags.isNZSLSnapshot</li>
</ol>
<h5 id="feature-instance-configure-amp-finialize"><a href="#feature-instance-configure-amp-finialize" class="headerlink" title="feature instance configure&amp;finialize"></a>feature instance configure&amp;finialize</h5><p>先针对enable feature vector（有自己的排序规则）进行反向遍历处理</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> negotiationsMap对OutputPortRequirement的映射规则<span class="comment">//todo negotiationsMap未满足条件映射</span></span><br><span class="line"><span class="number">2.</span> 通过.ConfigureFeature在feature instance中去初始化pipeline. 一条pipeline是在feature 拓扑中定义的  </span><br><span class="line">    a.从feature instance中获取定义的session number和 pipeline number</span><br><span class="line">    比如我们已经知道一个feature instance的name为RealTime， 那么可以知道对应的cap也为RealTime，</span><br><span class="line">    对应的ChiFeature2Descriptor 类型ChiFeature2Descriptor 定义在feature2/chifeature2graphselector/descriptors/generated/features/g_chifeature2realtimedescriptor.cpp下</span><br><span class="line">    </span><br><span class="line">      CDK_VISIBILITY_PUBLIC extern <span class="keyword">const</span> ChiFeature2Descriptor RealTimeFeatureDescriptor =</span><br><span class="line">  &#123;                                                        </span><br><span class="line">      <span class="number">0</span>,                                                                               <span class="comment">// Feature Id</span></span><br><span class="line">      <span class="string">&quot;RealTime&quot;</span>,                                                                      <span class="comment">// Feature Name</span></span><br><span class="line">      <span class="number">1</span>,                                                                               <span class="comment">// Num Stage Descriptors</span></span><br><span class="line">      &amp;RealTime_StageDescriptors[<span class="number">0</span>],                                                   <span class="comment">// Stage Descriptors</span></span><br><span class="line">      <span class="number">1</span>,                                                                               <span class="comment">// Num Session Descriptors</span></span><br><span class="line">      &amp;RealTime_SessionDescriptors[<span class="number">0</span>],                                                 <span class="comment">// Session Descriptors</span></span><br><span class="line">      <span class="number">5</span>,                                                                               <span class="comment">// Num Internal Links</span></span><br><span class="line">      &amp;RealTime_InternalLinks[<span class="number">0</span>],                                                      <span class="comment">// Internal Link Descriptors</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">    PrepareFeatureData() Feature2Mapping: FeatureName = RealTime, numSessions = <span class="number">1</span>, numPipelines = <span class="number">14</span> numPorts = <span class="number">280</span></span><br><span class="line">    RealTime feature instance下一共有<span class="number">14</span>条pipeline中，定义在RealTime_Session0_PipelineDescs。但这个时候pipeline拓扑我们是不知道的</span><br><span class="line">    </span><br><span class="line">    下面从b到e，将根据session和pipeline desc填充pSessionData和pSessionData-&gt;pPipelineData</span><br><span class="line">    b.针对每一个session，设置对应的session回调，针对session下的每一个pipeline，feature instance 通过OnPipelineSelect判断是否支持。</span><br><span class="line">    </span><br><span class="line">    chifeature2realtime.cpp:<span class="number">2851</span> OnPipelineSelect() featureName:RealTime, pipelineName:ZSLPreviewRaw_LT1080p, instanceFlags &#123;nzsl:<span class="number">0</span>, swremosaic:<span class="number">0</span>, hwremosaic:<span class="number">0</span>, bpscam:<span class="number">0</span>, shdr <span class="number">0</span>, mfhdr <span class="number">0</span>&#125; isPipelineSupported <span class="number">1</span> Screengrab:<span class="number">0</span>, platformSocId <span class="number">454</span></span><br><span class="line">    </span><br><span class="line">    c.拿到m_pChiUsecase，并通过pipeline name确定pipelne index，方便之后CloneUsecase和PruneUsecaseDescriptor确定pipeline拓扑</span><br><span class="line">    </span><br><span class="line">    PrepareFeatureData() session: <span class="number">0</span>, name: RealTime, pipeline: <span class="number">0</span>, name: ZSLPreviewRaw_LT1080p</span><br><span class="line">    </span><br><span class="line">    d.根据pipeline中input和output的描述，在pipeline的pInputPortData和pOutputPortData分别增加对于的描述，针对InternalLinks，将sinkport的描述也增加到对应pipeline的pInputPortData描述中</span><br><span class="line">    </span><br><span class="line">    e.拿到pInternalLinkDesc中的sink port对在的pipeline data,并给pInputPortData添加对应sink port描述的pSinkPortData。</span><br><span class="line">    </span><br><span class="line">    f.通过CloneUsecase和PruneUsecaseDescriptor确定pipeline拓扑</span><br><span class="line">    </span><br><span class="line">    g.通过PopulateDisabledStatus检查pipelineData中的input和output data的targetName是否在usecae拓扑中source Target和 sink Target的targetName match.</span><br><span class="line">    </span><br><span class="line">   *pSinkPortData push_back(pInternalLinkDesc[linkPortIdx].pSinkPort)---&gt; pInputPortData ----- sourceTarget</span><br><span class="line">   </span><br><span class="line">                                                                          pOutputPortData ----- sinkTarget</span><br><span class="line">                                                                          </span><br><span class="line">    PopulateDisabledStatus() RealTime : ZSLPreviewRaw_LT1080p:ZSL_In_Raw : Port Status : <span class="number">1</span> = &gt; <span class="number">0</span> SrcPort : (Raw_Out)</span><br><span class="line">    PopulateDisabledStatus() RealTime : ZSLPreviewRaw_LT1080p:ZSL_In_FD : Port Status : <span class="number">1</span> = &gt; <span class="number">1</span> SrcPort : (Fd_Out)</span><br><span class="line">    PopulateDisabledStatus() RealTime : ZSLPreviewRaw_LT1080p:MFHDR_long_raw_In : Port Status : <span class="number">1</span> = &gt; <span class="number">1</span> SrcPort : (MFHDR_ZSL_In_Long_Raw_out))</span><br><span class="line">    PopulateDisabledStatus() RealTime : ZSLPreviewRaw_LT1080p:MFHDR_short_raw_In : Port Status : <span class="number">1</span> = &gt; <span class="number">1</span> SrcPort : (MFHDR_ZSL_In_Short_Raw_out)</span><br><span class="line">    </span><br><span class="line">    h.针对pSinkTarget和pSrcTarget，进行AssignStreams和AssignTargets，这个时候会有一个对应关系。匹配规则如下</span><br><span class="line">        <span class="number">1.</span>对应关系   pInputPortData ----- sourceTarget</span><br><span class="line">                     pOutputPortData ----- sinkTarget</span><br><span class="line">        <span class="number">2.</span>从PortData中找到和Single Target 中target name一致的port（但是Raw_Out 和 Raw_Callback pTargetName一致，会造成共享一个result stream ），然后针对这个target进行流分配，调用AssignStreams，先申请result stream空间，然后将feature instance 要处理的stream <span class="built_in">int</span>ent和port 支持的stream <span class="built_in">int</span>ent匹配，将匹配成功的stream用pStreamMatched数组标记。将匹配的stream地址赋值给target stream,同时将target stream指向的空间复制到result stream申请的空间</span><br><span class="line">        </span><br><span class="line">        GetTargetStreamWithIntent() MATCHED: CHI_STREAM_INTENT_PREVIEW <span class="keyword">for</span> Target: TARGET_BUFFER_DISPLAY ChiStream: <span class="number">0xb400007402c56488</span> format: <span class="number">34</span> width: <span class="number">1440</span> height: <span class="number">1080</span></span><br><span class="line">        </span><br><span class="line">        GetTargetStreamWithIntent() Feature2Mapping: Target Stream: TARGET_BUFFER_DISPLAY <span class="number">0xb400007402c56488</span> Intent: CHI_STREAM_INTENT_PREVIEW Resolution: <span class="number">1440</span> X <span class="number">1080</span> Format = <span class="number">34</span></span><br><span class="line">        </span><br><span class="line">        GetTargetStreamWithIntent() FeatureStreamMapping: TargetName = TARGET_BUFFER_DISPLAY StreamPtr:<span class="number">0xb4000073e2c91110</span> Intent: CHI_STREAM_INTENT_PREVIEW Resolution = <span class="number">1440</span>X1080 Format = <span class="number">34</span> Direction = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        InitializeTargetStream() Add feature <span class="number">0</span> Target TARGET_BUFFER_DISPLAY instance <span class="number">0</span> stream <span class="number">0xb400007402c56488</span>, cameraId <span class="number">0</span></span><br><span class="line">        InitializeTargetStream() RealTime: Target:TARGET_BUFFER_DISPLAY, PortKey:Display_Out:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">3</span> stream:target:<span class="number">0xb4000073e2c91110</span>:<span class="number">0xb400007402c56488</span>Stream: <span class="number">1440</span> X <span class="number">1080</span>:<span class="number">0x22</span>:<span class="number">0</span>:<span class="number">0x900</span>:<span class="number">1</span></span><br><span class="line">        chifeature2base.cpp:<span class="number">8289</span> AssignStreams() RealTime: Assign Stream (<span class="number">0xb4000073e2c91110</span>): Target = TARGET_BUFFER_DISPLAY resolution <span class="number">1440</span>x1080 format <span class="number">0x22</span> usage <span class="number">900</span> type <span class="number">0</span></span><br><span class="line">        <span class="number">3.</span>AssignTargets针对rDstPortData.pTarget为空且target name相同的，同步pTargetDesc的pTarget和pTarget-&gt;pChiStream（用来buffer回调的result stream）到rDstPortData</span><br><span class="line">        </span><br><span class="line">        RealTime: Output Port: (<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>) : Display_Out : target: TARGET_BUFFER_DISPLAY stream:<span class="number">0xb4000073e2c91110</span> targetStream:<span class="number">0xb4000073e2c91110</span>Res:<span class="number">1440</span>X1080</span><br><span class="line">        </span><br><span class="line">    i. OnInitialize注册feature instance PCR处理函数SubmitRequestJob</span><br><span class="line">    j. OnConfigureOutputPorts <span class="comment">//配置规则todo，未见log打印</span></span><br><span class="line">    k. ConfigurePipelineData <span class="comment">//创建pipeline并OnConfigureInputPorts 配置规则todo，未见配置log打印。</span></span><br><span class="line">    l. 此时feature instance实例 状态机设置为ChiFeature2Status::Configured</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 基于feature input requirement更新 feature output requirement <span class="comment">//规则todo log未见打印</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 调用FinalizeInitialization</span><br><span class="line">   FinalizeInitialization() finalize initialization RealTime</span><br><span class="line">   </span><br><span class="line">   这里通过rFinalizedInputs和finalizedOutputs， InternalLinks来实现不同feature pipeline相连端口的Assgin stream尺寸的一致性。</span><br><span class="line">   </span><br><span class="line">    chifeature2featurepool.cpp:<span class="number">1006</span> FinalizeFeatureInstances() [RealTime:<span class="number">0</span>] Output Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125; influences [Bayer2Yuv:<span class="number">0</span>] Input Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;(Fmt: <span class="number">0x25</span> [<span class="number">4208</span> x <span class="number">3120</span>])</span><br><span class="line">    chifeature2featurepool.cpp:<span class="number">1006</span> FinalizeFeatureInstances() [RealTime:<span class="number">0</span>] Output Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125; influences [Bayer2Yuv:<span class="number">8</span>] Input Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;(Fmt: <span class="number">0x25</span> [<span class="number">4208</span> x <span class="number">3120</span>])</span><br><span class="line">    chifeature2featurepool.cpp:<span class="number">1006</span> FinalizeFeatureInstances() [RealTime:<span class="number">0</span>] Output Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125; influences [RawHDR:<span class="number">0</span>] Input Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;(Fmt: <span class="number">0x25</span> [<span class="number">4208</span> x <span class="number">3120</span>])</span><br><span class="line">    chifeature2featurepool.cpp:<span class="number">1006</span> FinalizeFeatureInstances() [Bayer2Yuv:<span class="number">0</span>] Output Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; influences [JPEG:<span class="number">0</span>] Input Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;(Fmt: <span class="number">0x23</span> [<span class="number">4160</span> x <span class="number">3120</span>])</span><br><span class="line">    chifeature2featurepool.cpp:<span class="number">1006</span> FinalizeFeatureInstances() [Bayer2Yuv:<span class="number">0</span>] Output Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; influences [HDR:<span class="number">0</span>] Input Port &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;(Fmt: <span class="number">0x23</span> [<span class="number">4160</span> x <span class="number">3120</span>])</span><br><span class="line"></span><br><span class="line">   a.通过FinalizeSessionData 创建 非defer session </span><br><span class="line">   camxsession.cpp:<span class="number">2345</span> Initialize() Session (<span class="number">0xb40000732e345040</span>) Initialized ZSLPreviewRaw_L     T1080p</span><br><span class="line">   </span><br><span class="line">   b.给每一条pipeline的OutputMeta和SettingMeta,pipeline上port创建TBM. 正好对应<span class="number">6</span>条stream的<span class="number">6</span>个port</span><br><span class="line">   CreateTargetBufferManagers() metamanagerName:SettingTargetBuffer_ZSLPreviewRaw_LT1080p pSettingMetaTbm:<span class="number">0xb400007472cc78b0</span></span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:Display_Out port idx:<span class="number">0</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c91110</span>, format:<span class="number">34</span>, w x h: <span class="number">1440</span> x <span class="number">1080</span> usage <span class="number">20900</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">0</span> Max:</span><br><span class="line">   CreateTargetBufferManagers() isChiFenceEnabled:<span class="number">0</span>, RealTime: PortTargetBuffer_RealTime:Display_Out_0: Res: <span class="number">1440</span>X1080 Format = <span class="number">0X22</span>, Min Buffer = <span class="number">0</span>, Max Buffer = <span class="number">8</span>, isChiGrallocBufferUsed=<span class="number">0</span></span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:Raw_Out port idx:<span class="number">1</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c926f0</span>, format:<span class="number">37</span>, w x h: <span class="number">4208</span> x <span class="number">3120</span> usage <span class="number">20002</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">9</span> Max:<span class="number">64</span></span><br><span class="line">   CreateTargetBufferManagers() isChiFenceEnabled:<span class="number">0</span>, RealTime: PortTargetBuffer_RealTime:Raw_Out_0: Res: <span class="number">4208</span>X3120 Format = <span class="number">0X25</span>, Min Buffer = <span class="number">9</span>, Max Buffer = <span class="number">64</span>, isChiGrallocBufferUsed=</span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:Video_Out port idx:<span class="number">3</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c92680</span>, format:<span class="number">35</span>, w x h: <span class="number">1440</span> x <span class="number">1080</span> usage <span class="number">20000</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">0</span> Max:<span class="number">8</span></span><br><span class="line">   CreateTargetBufferManagers() isChiFenceEnabled:<span class="number">0</span>, RealTime: PortTargetBuffer_RealTime:Video_Out_0: Res: <span class="number">1440</span>X1080 Format = <span class="number">0X23</span>, Min Buffer = <span class="number">0</span>, Max Buffer = <span class="number">8</span>, isChiGrallocBufferUsed=<span class="number">0</span></span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:Yuv_Out port idx:<span class="number">6</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c91340</span>, format:<span class="number">35</span>, w x h: <span class="number">640</span> x <span class="number">480</span> usage <span class="number">20000</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">0</span> Max:<span class="number">8</span></span><br><span class="line">   CreateTargetBufferManagers() isChiFenceEnabled:<span class="number">0</span>, RealTime: PortTargetBuffer_RealTime:Yuv_Out_0: Res: <span class="number">640</span>X480 Format = <span class="number">0X23</span>, Min Buffer = <span class="number">0</span>, Max Buffer = <span class="number">8</span>, isChiGrallocBufferUsed=<span class="number">0</span></span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:PostView_Out port idx:<span class="number">7</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c95c50</span>, format:<span class="number">35</span>, w x h: <span class="number">320</span> x <span class="number">240</span> usage <span class="number">20000</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">0</span> Max:<span class="number">8</span></span><br><span class="line">   CreateTargetBufferManagers() isChiFenceEnabled:<span class="number">0</span>, RealTime: PortTargetBuffer_RealTime:PostView_Out_0: Res: <span class="number">320</span>X240 Format = <span class="number">0X23</span>, Min Buffer = <span class="number">0</span>, Max Buffer = <span class="number">8</span>, isChiGrallocBufferUsed=<span class="number">0</span></span><br><span class="line">   CreateTargetBufferManagers() Pipeline[ZSLPreviewRaw_LT1080p][<span class="number">0</span>], port:IDEALRaw_Out port idx:<span class="number">14</span>, Create CHI buffers, chistream:<span class="number">0xb4000073e2c93870</span>, format:<span class="number">32</span>, w x h: <span class="number">4096</span> x <span class="number">3072</span> usage <span class="number">20002</span> prd flags <span class="number">20000</span> cons flags <span class="number">40000</span>Min:<span class="number">0</span> Max:<span class="number">8</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   Raw_Out 和 Raw_Callback pTargetName一致，会造成共享一个result stream，一个TBM</span><br><span class="line">   </span><br><span class="line">   FinalizeSessionData() RealTime Raw_Out pushing back output stream(<span class="number">0xb4000073e2c926f0</span>) fmt <span class="number">0x25</span> dims <span class="keyword">from</span> [<span class="number">4208</span> x <span class="number">3120</span>]</span><br><span class="line">   FinalizeSessionData() RealTime Raw_Callback pushing back output stream(<span class="number">0xb4000073e2c926f0</span>) fmt <span class="number">0x25</span> dims <span class="keyword">from</span> [<span class="number">4208</span> x <span class="number">3120</span>]</span><br><span class="line">   CreateTargetBufferManagers() Linking port Raw_Out -&gt; Raw_Callback</span><br><span class="line">   CreateTargetBufferManagers() Feature: RealTime Sharing TBM <span class="keyword">for</span> port Raw_Callback</span><br><span class="line">   BuildLinkedPortListForPort() LinkedPort:pPort_Raw_Out:(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)-&gt;rPort_Raw_Callback[<span class="number">4</span>]:(<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">   BuildLinkedPortListForPort() LinkedPort:pPort_Raw_Callback:(<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>)-&gt;rPort_Raw_Out[<span class="number">1</span>]:(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   c.PrepareStageData<span class="comment">//其实并没有做实际性的工作，根据Feature Instance Desc和Stage Desc，已经建立好的SessionData，PipelineData匹配检查</span></span><br><span class="line">   </span><br><span class="line">   d.PostJob m_hAsyncFeatureJob 建立defer session</span><br><span class="line">   e. m_pStreamData的构建 见图</span><br><span class="line"></span><br><span class="line">   f.创建RequestThread线程 flush wait feature instance.</span><br><span class="line">   g.feature instance 状态机设置为ChiFeature2Status::Finalized</span><br></pre></td></tr></table></figure>


<h4 id="TBM的创建"><a href="#TBM的创建" class="headerlink" title="TBM的创建"></a>TBM的创建</h4><p>对F2W的input stream（双摄的RDI.FD）和 fk stream 和metadata TBM绑定</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">chifeature2wrapper.cpp:1804 CreateTargetBufferManagers() Framework Target Buffer Manager [<span class="string">FWK_34_TBM</span>][<span class="symbol">0xb400007472c8e1f0</span>] created. stream=0xb400007402c56488 type=0 format=34</span><br><span class="line"></span><br><span class="line">chifeature2wrapper.cpp:1804 CreateTargetBufferManagers() Framework Target Buffer Manager [<span class="string">FWK_33_TBM</span>][<span class="symbol">0xb400007472c99730</span>] created. stream=0xb400007402c81c48 type=0 format=33</span><br><span class="line"></span><br><span class="line">chifeature2wrapper.cpp:1842 CreateTargetBufferManagers() Wrapper meta target buffer created 0xb400007472cdaaf0 ,physicalCamIdx:0 </span><br></pre></td></tr></table></figure>

<p><a id="3"></a></p>
<h3 id="feature-instance连接"><a href="#feature-instance连接" class="headerlink" title="feature instance连接"></a>feature instance连接</h3><ul>
<li><a href="#0">返回主目录</a><br><a href="https://sholck.top/archives/8a2ade19.html">feature instance connect</a></li>
</ul>
<p><a id="4"></a></p>
<h3 id="feature-PCR"><a href="#feature-PCR" class="headerlink" title="feature-PCR"></a>feature-PCR</h3><ul>
<li><a href="#0">返回主目录</a><br><a href="https://sholck.top/archives/8a2ade1a.html">feature2-PCR</a></li>
</ul>
<p><a id="5"></a></p>
<h3 id="TBM详解"><a href="#TBM详解" class="headerlink" title="TBM详解"></a>TBM详解</h3><ul>
<li><a href="#0">返回主目录</a></li>
</ul>
<p><a id="6"></a></p>
<h3 id="TM详解"><a href="#TM详解" class="headerlink" title="TM详解"></a>TM详解</h3><ul>
<li><a href="#0">返回主目录</a></li>
</ul>
]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>Feature2</tag>
      </tags>
  </entry>
  <entry>
    <title>Camx-Feature2-featureInstanceConnect</title>
    <url>/archives/8a2ade19.html</url>
    <content><![CDATA[<h1 id="Camx-Feature2-featureInstanceConnect"><a href="#Camx-Feature2-featureInstanceConnect" class="headerlink" title="Camx-Feature2-featureInstanceConnect"></a>Camx-Feature2-featureInstanceConnect</h1><p>在这小节中，我们会对feature graph的整合和feature instance之间的连接有个大致的了解</p>
<p>从之前GetAllFeatureGraphDescriptors中过滤掉一部分的featureGraphDesc，剩下的按照组合规则构成VirtualSuperGraph，那么具体各feature之间的连接顺序和规则是通过什么来确定的?</p>
<p>下面是sm4350当前预览的feature 拓扑详细的描述了之间的连接</p>
<p><img src="/images/feature2/feature2-featureInstanceConnect.png" alt="alt"></p>
<p>整理之前的全部信息，包括整合以后的feature instance下的stream和端口组合。 </p>
<details>
  <summary>确定需要组合的featureGraphDesc</summary>

<pre><code>Insert single graph:cameraID 0-&gt;RealtimeFG-&gt;0 //无 internal link
Insert single graph:cameraID 0-&gt;RTMemcpyYUV-&gt;0 //无feature instance 
Insert single graph:cameraID 0-&gt;RTBayer2YUVHDRT1JPEG-&gt;0
Insert single graph:cameraID 0-&gt;RTBayer2YUVJPEG-&gt;0
Insert single graph:cameraID 0-&gt;RTBayer2YUV-&gt;0
Insert single graph:cameraID 0-&gt;RTBayer2YUVCDSJPEG-&gt;0
Insert single graph:cameraID 0-&gt;RTRawHDRBayer2YUVJPEGOEM-&gt;0
Insert single graph:cameraID 0-&gt;RTRawHDRBayer2YUVOEM-&gt;0
Insert single graph:cameraID 0-&gt;RTBayer2YUVCDS-&gt;0</code></pre>
</details>
根据Internal links和Sink links画出拓扑

<details>
  <summary>确定VirtualSuperGraph下包含的feature instance</summary>

<pre><code>CreateFeatureInstances() :VirtualSuperGraph, numFeatureInstances:7, logicalCameraId:0
CreateFeatureInstances() RealTime(0xb400007472ce27f0) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;0, 0, 0, 0&#125;
CreateFeatureInstances() RawHDR(0xb400007472c52f10) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;10, 0, 0, 0&#125;
CreateFeatureInstances() Bayer2Yuv(0xb400007472c83f70) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;1, 0, 0, 0&#125;
CreateFeatureInstances() Bayer2Yuv(0xb400007472cd5050) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;1, 8, 0, 16384&#125;
CreateFeatureInstances() HDR(0xb400007472c96530) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;6, 0, 0, 0&#125;
CreateFeatureInstances() JPEG(0xb400007472c8acd0) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;5, 0, 0, 0&#125;
CreateFeatureInstances() Yuv2Yuv(0xb400007472cb5c50) &#123;featureId, instanceId, cameraId, flags&#125;: &#123;33, 0, 0, 0&#125;</code></pre>
</details>

<details>
  <summary>确定各feature instance下的stream</summary>

<pre><code>//RealTime
DoStreamNegotiation() numStream:6
ClassifyStream() Name = RealTime: Res: 1440 X 1080 Format = 0x22 Usage = 0x900 Type = 0 STREAM = 0xb400007402c56488 (intent = 1 bpp = 0) PhyCamId =  &gt;&gt;configure_stream预览流
ClassifyStream() Name = RealTime: Res: 320 X 240 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c95710 (intent = 6 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = RealTime: Res: 4208 X 3120 Format = 0x25 Usage = 0x20002 Type = 0 STREAM = 0xb4000073e2c96580 (intent = 8 bpp = 10) PhyCamId = (null)
ClassifyStream() Name = RealTime: Res: 4096 X 3072 Format = 0x20 Usage = 0x20002 Type = 0 STREAM = 0xb4000073e2c95780 (intent = 2 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = RealTime: Res: 1440 X 1080 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c95630 (intent = 3 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = RealTime: Res: 640 X 480 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c97700 (intent = 7 bpp = 0) PhyCamId = (null)
//RawHDR
ClassifyStream() Name = RawHDR: Res: 4208 X 3120 Format = 0x25 Usage = 0x20022 Type = 1 STREAM = 0xb4000073e2c93800 (intent = 5 bpp = 0) PhyCamId = (null) 
ClassifyStream() Name = RawHDR: Res: 4208 X 3120 Format = 0x25 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c979a0 (intent = 2 bpp = 0) PhyCamId = (null)
//Bayer2Yuv
DoStreamNegotiation() numStream:4 screenGrab: 0
ClassifyStream() Name = Bayer2Yuv: Res: 4208 X 3120 Format = 0x25 Usage = 0x20022 Type = 1 STREAM = 0xb4000073e2c95400 (intent = 7 bpp = 10) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c933a0 (intent = 2 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c959b0 (intent = 7 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c97e70 (intent = 7 bpp = 0) PhyCamId = (null)
//Bayer2Yuv CDS
DoStreamNegotiation() numStream:4 screenGrab: 0
ClassifyStream() Name = Bayer2Yuv: Res: 4208 X 3120 Format = 0x25 Usage = 0x20022 Type = 1 STREAM = 0xb4000073e2c96dd0 (intent = 7 bpp = 10) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c8d130 (intent = 2 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c97230 (intent = 7 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = Bayer2Yuv: Res: 4160 X 3120 Format = 0x23 Usage = 0x0 Type = 0 STREAM = 0xb4000073e2c94de0 (intent = 7 bpp = 0) PhyCamId = (null)
//HDR
ClassifyStream() Name = HDR: Res: 4160 X 3120 Format = 0x23 Usage = 0x20022 Type = 0 STREAM = 0xb4000073e2c95160 (intent = 2 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = HDR: Res: 4160 X 3120 Format = 0x23 Usage = 0x20022 Type = 1 STREAM = 0xb4000073e2c951d0 (intent = 2 bpp = 0) PhyCamId = (null)
//JPEG
DoStreamNegotiation() numStream:2 screenGrab: 0 
ClassifyStream() Name = JPEG: Res: 4160 X 3120 Format = 0x23 Usage = 0x20022 Type = 1 STREAM = 0xb4000073e2c932c0 (intent = 7 bpp = 0) PhyCamId = (null)
ClassifyStream() Name = JPEG: Res: 4160 X 3120 Format = 0x21 Usage = 0x3 Type = 0 STREAM = 0xb400007402c81c48 (intent = 2 bpp = 0) PhyCamId = &gt;&gt;configure_stream 拍照流
//Yuv2Yuv
ClassifyStream() Name = Yuv2Yuv: Res: 1440 X 1080 Format = 0x22 Usage = 0x900 Type = 0 STREAM = 0xb400007402c56488 (intent = 1 bpp = 0) PhyCamId  =&gt;&gt;configure_stream预览流
ClassifyStream() Name = Yuv2Yuv: Res: 4160 X 3120 Format = 0x21 Usage = 0x3 Type = 0 STREAM = 0xb400007402c81c48 (intent = 2 bpp = 0) PhyCamId = &gt;&gt;configure_stream 拍照流</code></pre>
</details>

<details>
  <summary>确定各feature instance下的port</summary>

<pre><code>//重复的已经删除
//realtime all links 
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 2&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 5&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 3&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 4&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 6&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 7&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 8&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 14&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RealTime:0) &#123;0, 0, 19&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//RawHDR
operator()() VirtualSuperGraph (RawHDR:0) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RawHDR:0) &#123;0, 0, 4&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RawHDR:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RawHDR:0) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (RawHDR:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//Bayer2Yuv feature 1 instance 0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 1&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 2&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:0) &#123;0, 0, 3&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//Bayer2Yuv feature 1 instance 8
operator()() VirtualSuperGraph (Bayer2Yuv:8) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x4000, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:8) &#123;0, 0, 1&#125; Dir: 1 Flags: 0x4000, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:8) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x4000, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:8) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x4000, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Bayer2Yuv:8) &#123;0, 0, 2&#125; Dir: 3 Flags: 0x4000, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//HDR
operator()() VirtualSuperGraph (HDR:0) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (HDR:0) &#123;0, 0, 4&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (HDR:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (HDR:0) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//JPEG
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 1&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 1&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 2&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (JPEG:0) &#123;0, 0, 3&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
//Yuv2Yuv
operator()() VirtualSuperGraph (Yuv2Yuv:0) &#123;0, 0, 0&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Yuv2Yuv:0) &#123;0, 0, 1&#125; Dir: 1 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0
operator()() VirtualSuperGraph (Yuv2Yuv:0) &#123;0, 0, 0&#125; Dir: 3 Flags: 0x0, CameraId: 0 Original(0) pFeatureGraphDesc=0x7357bf33c0</code></pre>
</details>

<details>
  <summary>获取feature instance的pipeline</summary>

<pre><code>//pipeline的选择：一个session下的pipeline id有很多都是一致的，因此当通过OnPipelineSelect选择一个最基础的成功以后，那么之后的都认为是Session has pipeline
PrepareFeatureData() Feature2Mapping: FeatureName = JPEG, numSessions = 1, numPipelines = 2 numPorts = 12
PrepareFeatureData() session: 0, name: JPEG, pipeline: 0, name: InternalZSLYuv2Jpeg
PrepareFeatureData() Feature2Mapping: FeatureName = HDR, numSessions = 1, numPipelines = 4 numPorts = 28
PrepareFeatureData() session: 0, name: HDRT1, pipeline: 0, name: Merge3YuvCustomTo1Yuv
PrepareFeatureData() Feature2Mapping: FeatureName = Bayer2Yuv, numSessions = 1, numPipelines = 9 numPorts = 54 //CDS instance 8
PrepareFeatureData() session: 0, name: Bayer2Yuv, pipeline: 0, name: ZSLSnapshotYUVHALwithCDS
PrepareFeatureData() Feature2Mapping: FeatureName = Bayer2Yuv, numSessions = 1, numPipelines = 9 numPorts = 54
PrepareFeatureData() session: 0, name: Bayer2Yuv, pipeline: 0, name: ZSLSnapshotYUVHAL
PrepareFeatureData() Feature2Mapping: FeatureName = RawHDR, numSessions = 1, numPipelines = 1 numPorts = 7
PrepareFeatureData() session: 0, name: RawHDR, pipeline: 0, name: SWMFMergeRaw
PrepareFeatureData() Feature2Mapping: FeatureName = RealTime, numSessions = 1, numPipelines = 14 numPorts = 280
PrepareFeatureData() session: 0, name: RealTime, pipeline: 0, name: ZSLPreviewRaw_LT1080p</code></pre>
</details>
针对部分feature instance，在进行pipeline拓扑优化时会有log，我们可以根据log推出大致拓扑prune结构和为什么disable部分portData中的端口，比如InternalZSLYuv2Jpeg,但是图中的HEIC_BLOB是不会配流的，因为和jpeg feature instance 的output stream不匹配

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">PruneUsecaseDescriptor</span>() InternalZSLYuv<span class="number">2</span>Jpeg Pruned Source target srcTargetIdx:<span class="number">0</span>, TARGET_BUFFER_CUSTOM_YUV numOfPort:<span class="number">1</span> portInfo:<span class="number">15</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="attribute">chxusecaseutils</span>.cpp:<span class="number">2216</span> PruneUsecaseDescriptor() InternalZSLYuv<span class="number">2</span>Jpeg, Pruned LinkInfo sourceNode(<span class="number">6</span>,<span class="number">0</span>,<span class="number">2</span>)-&gt;DestNode(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line"><span class="attribute">chxusecaseutils</span>.cpp:<span class="number">2216</span> PruneUsecaseDescriptor() InternalZSLYuv<span class="number">2</span>Jpeg, Pruned LinkInfo sourceNode(<span class="number">15</span>,<span class="number">0</span>,<span class="number">2</span>)-&gt;DestNode(<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="attribute">chxusecaseutils</span>.cpp:<span class="number">2216</span> PruneUsecaseDescriptor() InternalZSLYuv<span class="number">2</span>Jpeg, Pruned LinkInfo sourceNode(<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>)-&gt;DestNode(<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/feature2/pipeline-InternalZSLYuv2Jpeg.png" alt="alt"></p>
<details>
  <summary>给Usecase中的pipeline和PortData匹配以后的Target配流,log中包含result stream和 target stream</summary>

<pre><code>//jpeg feature instance
Jpeg_0 pushing inStream [0xb4000073e2c932c0 4160x3120] outStream [0xb400007402c81c48 4160x3120]

//inStream
InitializeTargetStream() JPEG: Target:TARGET_BUFFER_CUSTOM_YUV, PortKey:YUV_In:0:0:0:1 stream:target:0xb4000073e2c96c80:0xb4000073e2c932c0 Stream: 4160 X 3120:0x23:1:0x20022:7
//outStream
InitializeTargetStream() JPEG: Target:TARGET_BUFFER_SNAPSHOT, PortKey:JPEG_Out:0:0:0:3 stream:target:0xb4000073e2c8d520:0xb400007402c81c48 Stream: 4160 X 3120:0x21:0:0x3:2

//HDR feature instance
InitializeTargetStream() HDR: Target:TARGET_BUFFER_YUV_OUT, PortKey:YUV_Out_External:0:0:0:3 stream:target:0xb4000073e2c8c4f0: 0xb4000073e2c95160 Stream: 4160 X 3120:0x23:0:0x20022:2
InitializeTargetStream() HDR: Target:TARGET_BUFFER_YUV0, PortKey:YUV_In1_Internal:0:0:1:0 stream:target:0xb4000073e2c93cd0:0xb4000073e2c951d0 Stream: 4160 X 3120:0x23:1:0x20022:2
InitializeTargetStream() HDR: Target:TARGET_BUFFER_YUV1, PortKey:YUV_In0_External:0:0:0:1 stream:target:0xb4000073e2c94590:0xb4000073e2c951d0 Stream: 4160 X 3120:0x23:1:0x20022:2
InitializeTargetStream() HDR: Target:TARGET_BUFFER_YUV2, PortKey:YUV_In3_Internal:0:0:3:0 stream:target:0xb4000073e2c942f0:0xb4000073e2c951d0 Stream: 4160 X 3120:0x23:1:0x20022:2

//bayer2yuv CDS
InitializeTargetStream() Bayer2Yuv: Target:TARGET_BUFFER_YUV_HAL, PortKey:YUV_Out:0:0:0:3 stream:target:0xb4000073e2c92840:0xb4000073e2c8d130 Stream: 4160 X 3120:0x23:0:0x0:2
InitializeTargetStream() Bayer2Yuv: Target:TARGET_BUFFER_YUV_HAL2, PortKey:YUV_Out3:0:0:3:3 stream:target:0xb4000073e2c947c0:0xb4000073e2c97230 Stream: 4160 X 3120:0x23:0:0x0:7
InitializeTargetStream() Bayer2Yuv: Target:TARGET_BUFFER_RAW, PortKey:RDI_In:0:0:0:1 stream:target:0xb4000073e2c98260:0xb4000073e2c96dd0 Stream: 4208 X3120:0x25:1:0x20022:7

//bayer2yuv
InitializeTargetStream() Bayer2Yuv: Target:TARGET_BUFFER_YUV_HAL, PortKey:YUV_Out:0:0:0:3 stream:target:0xb4000073e2c967b0:0xb000073e2c933a0 Stream: 4160 X 3120:0x23:0:0x0:2
InitializeTargetStream() Bayer2Yuv: Target:TARGET_BUFFER_YUV_HAL2, PortKey:YUV_Out3:0:0:3:3 stream:target:0xb4000073e2c96f90:0xb4000073e2c959b0 Stream: 4160 X 3120:0x23:0:0x0:7
InitializeTargetStream() Bayer2Yuv: Target:TARGET_BUFFER_YUV_HAL3, PortKey:YUV_Out2:0:0:2:3 stream:target:0xb4000073e2c97460:0xb4000073e2c97e70 Stream: 4160 X 3120:0x23:0:0x0:7
InitializeTargetStream() Bayer2Yuv: Target:TARGET_BUFFER_RAW, PortKey:RDI_In:0:0:0:1 stream:target:0xb4000073e2c950f0:0xb4000073e2c95400 Stream: 4208 X3120:0x25:1:0x20022:7

//RAWHDR feature instance
InitializeTargetStream() RawHDR: Target:TARGET_BUFFER_RAW_OUT, PortKey:RAW_Out_External:0:0:0:3 stream:target:0xb4000073e2c96c10:0xb4000073e2c979a0 Stream: 4208 X 3120:0x25:0:0x0:2
InitializeTargetStream() RawHDR: Target:TARGET_BUFFER_RAW_IN0, PortKey:RAW_In0_External:0:0:0:1  stream:target:0xb4000073e2c920d0:0xb4000073e2c93800 Stream: 4208 X 3120:0x25:1:0x20022:5
InitializeTargetStream() RawHDR: Target:TARGET_BUFFER_RAW_IN1, PortKey:RAW_In2_Internal:0:0:2:0 stream:target:0xb4000073e2c96120:0xb4000073e2c93800 Stream: 4208 X 3120:0x25:1:0x20022:5
InitializeTargetStream() RawHDR: Target:TARGET_BUFFER_RAW_IN2, PortKey:RAW_In3_Internal:0:0:3:0 stream:target:0xb4000073e2c96eb0:0xb4000073e2c93800 Stream: 4208 X 3120:0x25:1:0x20022:5

//RealTime feature instance
InitializeTargetStream() RealTime: Target:TARGET_BUFFER_DISPLAY, PortKey:Display_Out:0:0:0:3 stream:target:0xb4000073e2c91110:0xb400007402c56488 Stream: 1440 X 1080:0x22:0:0x900:1
InitializeTargetStream() RealTime: Target:TARGET_BUFFER_VIDEO, PortKey:Video_Out:0:0:3:3 stream:target:0xb4000073e2c92680:0xb4000073e2c95630 Stream: 1440 X 1080:0x23:0:0x0:3
InitializeTargetStream() RealTime: Target:TARGET_BUFFER_RAW_OUT, PortKey:Raw_Out:0:0:1:3 stream:target:0xb4000073e2c926f0:0xb4000073e2c96580 Stream: 4208 X 3120:0x25:0:0x20002:8 
InitializeTargetStream() RealTime: Target:TARGET_BUFFER_IDEAL_RAW, PortKey:IDEALRaw_Out:0:0:14:3 stream:target:0xb4000073e2c93870:0xb4000073e2c95780 Stream: 4096 X 3072:0x20:0:0x20002:2
InitializeTargetStream() RealTime: Target:TARGET_BUFFER_POSTVIEW_OUT, PortKey:PostView_Out:0:0:7:3 stream:target:0xb4000073e2c95c50:0xb4000073e2c95710 Stream: 320 X 240:0x23:0:0x0:6
InitializeTargetStream() RealTime: Target:TARGET_BUFFER_YUV_OUT, PortKey:Yuv_Out:0:0:6:3 stream:target:0xb4000073e2c91340:0xb4000073e2c97700 Stream: 640 X 480:0x23:0:0x0:7</code></pre>
</details>
]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>Feature2</tag>
      </tags>
  </entry>
  <entry>
    <title>Feature2-PCR</title>
    <url>/archives/8a2ade1a.html</url>
    <content><![CDATA[<h1 id="Feature-PCR"><a href="#Feature-PCR" class="headerlink" title="Feature-PCR"></a>Feature-PCR</h1><p><a id="0"></a></p>
<ul>
<li><a href="#1">需要了解的知识</a></li>
<li><a href="#2">普通预览代码流程追踪</a></li>
<li><a href="#3">状态机</a></li>
</ul>
<p><a id="1"></a></p>
<h2 id="需要了解的知识"><a href="#需要了解的知识" class="headerlink" title="需要了解的知识"></a>需要了解的知识</h2><p>预览和拍照的PCR不同在于：当触发一次拍照时，预览下发的request中的outputBuffer中为2, Capture Intent设置为capture,共用同一个frame_number,一般预览outputBuffer为1.因此拍照可以当作一次特殊的预览。  </p>
<a id="more"></a> 

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chxusecase</span>.cpp:<span class="number">3450</span> EnqueueRequestInStreamBufferInfo() Enqueueing frame:<span class="number">189</span> <span class="literal">on</span> stream:<span class="number">0</span>xb<span class="number">400007</span>c<span class="number">234</span>f<span class="number">42</span>f<span class="number">8</span> at index:<span class="number">189</span></span><br><span class="line"><span class="attribute">chxusecase</span>.cpp:<span class="number">3450</span> EnqueueRequestInStreamBufferInfo() Enqueueing frame:<span class="number">189</span> <span class="literal">on</span> stream:<span class="number">0</span>xb<span class="number">400007</span>c<span class="number">234</span>f<span class="number">4</span>be<span class="number">8</span> at index:<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">chifeature2graphselector</span>.cpp:<span class="number">6863</span> GetCaptureIntentForRequest() Capture Intent value <span class="number">1</span></span><br><span class="line"><span class="attribute">chifeature2graphselector</span>.cpp:<span class="number">6941</span> GetCaptureIntentForRequest() Capture Intent value returned <span class="number">1</span></span><br><span class="line"><span class="attribute">chifeature2graphselector</span>.cpp:<span class="number">6863</span> GetCaptureIntentForRequest() Capture Intent value <span class="number">2</span></span><br><span class="line"><span class="attribute">chifeature2graphselector</span>.cpp:<span class="number">6941</span> GetCaptureIntentForRequest() Capture Intent value returned <span class="number">2</span> &gt;&gt;拍照</span><br></pre></td></tr></table></figure>

<p>普通预览和双摄预览的PCR处理框架不同，双摄的拍照为feature2框架处理，但是预览为usecasemc中处理。//todo</p>
<p>双摄拍照由OfflineRequestProcess进行监控，并进行通过SendOfflineProcessRequest进行feature 的 PCR调用</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">result</span> = m_requestMapInfo[internalFrameNumIndex].pFeature-&gt;ExecuteProcessRequest(&amp;requestForFeature2)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><a id="2"></a></p>
<h2 id="普通预览代码流程追踪"><a href="#普通预览代码流程追踪" class="headerlink" title="普通预览代码流程追踪"></a>普通预览代码流程追踪</h2><ul>
<li><a href="#0">返回主目录</a><br><img src="/images/feature2/feature2-feature2-PCR.png" alt="alt"><br>当拍照时，我们选择feature去处理PCR，因为针对QCFA sensor，我们要根据亮度去进行feature选择。通过SelectFeatureToExecuteCaptureRequest，我们当usecase选择为QuadCFA时，PickAdvanceFeatureByGain根据当前的Gain和设置的阀值去设置实际的feature.</li>
</ul>
<ol>
<li><p>URO的创建，进行一些初始化动作。</p>
</li>
<li><p>创建m_pImportList，m_pProducerList，m_pConsumerList进行将fw buffer导入到TBM中进行管理。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">chitargetbuffermanager.cpp:<span class="number">1319</span> ImportExternalTargetBuffer() [FWK_34_TBM] Import <span class="keyword">external</span> target succeed <span class="keyword">for</span> seqId=<span class="number">0</span>, targetIdx=<span class="number">0</span>, pTarget=<span class="number">0x7357c09800</span></span><br><span class="line">chitargetbuffermanager.cpp:<span class="number">541</span> SetupTargetBuffer() [FWK_34_TBM]_TBM Info: MinCnt:<span class="number">8</span> MaxCnt:<span class="number">32</span> ProdQ:<span class="number">0</span> ConsumerQ:<span class="number">0</span>[FWK_34_TBM]_TargetBuffer Info: seqId:<span class="number">0</span> pTargetBufferInfo:<span class="number">0xb4000074b2d34db0</span> targetIndex:<span class="number">0</span> type:<span class="number">2</span>[FWK_34_TBM]_Buffer Info: metadata:<span class="number">0x0</span> phBuffer:<span class="number">0xb4000073a2e454d8</span> releaseFence:<span class="number">0x0</span>(<span class="number">0</span>) <span class="number">0</span> <span class="built_in">ref</span>Count=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">chifeature2wrapper.cpp:<span class="number">2016</span> CreateUsecaseRequestObject() frame_number=<span class="number">0</span> pUsecaseRequestObject=<span class="number">0xb400007492d33b90</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>在FGS中选择合适的feature single graph desc描述去处理。<br>选择策略如下：单摄</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">a. URO处理的captureIntent，customVendorTag，noiseReductionMode，sceneMode和FGDKeysForTable的一致。</span><br><span class="line">b. 在a的基础上指定pFeatureGraphName</span><br><span class="line">c. 在FGD匹配的feature Desc中去匹配</span><br><span class="line"></span><br><span class="line">chifeature2graphselector.<span class="attr">cpp:</span><span class="number">771</span> SearchFeatureGraphinTable() <span class="attr">MatchFound:</span><span class="attr">isMulti:</span><span class="number">0</span> <span class="attr">physicalCameraId:</span><span class="number">0</span> ---&gt; RealtimeFG, <span class="attr">flags:</span><span class="number">0</span>, <span class="attr">pDesc:</span><span class="number">0xb4000073d2c58510</span>  <span class="comment">//预览</span></span><br><span class="line">chifeature2graphselector.<span class="attr">cpp:</span><span class="number">5626</span> SelectFeatureGraphforRequestFromTable() <span class="attr">Feature2Mapping:</span> Selected feature <span class="attr">graph :</span> Realtime</span><br><span class="line">chifeature2graphselector.<span class="attr">cpp:</span><span class="number">771</span> SearchFeatureGraphinTable() <span class="attr">MatchFound:</span><span class="attr">isMulti:</span><span class="number">0</span> <span class="attr">physicalCameraId:</span><span class="number">0</span> ---&gt; RTBayer2YUVJPEG, <span class="attr">flags:</span><span class="number">0</span>, pDesc                <span class="comment">//拍照</span></span><br><span class="line">chifeature2graphselector.<span class="attr">cpp:</span><span class="number">5626</span> SelectFeatureGraphforRequestFromTable() <span class="attr">Feature2Mapping:</span> Selected feature <span class="attr">graph :</span> RTBayer2YUVJPEG</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对应的feature single graph.</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">a. 设置对应FGMcallback,需要之后作为inputInfo来创建ChiFeature2Graph。</span><br><span class="line">b. 映射inputPort到inputStream,映射outputPort到outputStream.//规则todo</span><br><span class="line">   MapInputPortToInputStream</span><br><span class="line">   MapOutputPortToOutputStreamWithStreamMap</span><br><span class="line">c. 选择对应的feature single包含的已经建立的feature instance,并push到featureInstanceReqInfoList</span><br><span class="line">d. 创建ChiFeature2Graph实例。首先检查端口状态，不能出现一对多和多对一拓扑结构.</span><br><span class="line">   </span><br><span class="line">   打印需要初始化的feature single graph和对应的输入输出port到stream的映射</span><br><span class="line">   chifeature2graph.cpp:1524 Initialize() Graph-URO:0_Graph:RealtimeFG created with srcChiStreams 0, sinkChiStreams 1<span class="built_in"> and </span>features 1:</span><br><span class="line">   </span><br><span class="line">   打印该sinlg graph下包含的feature instance</span><br><span class="line">   chifeature2graph.cpp:1536 Initialize()   featureName = RealTime_0 featureId 0</span><br><span class="line">   </span><br><span class="line">   copy single graph 的link信息到类成员m_linkData,然后在pipelineData中的inputPort和outputPort中拿到全部的externalPort和single graph 的link port做比对，确定实际该sinlg graph的external port在拓扑中的已连接节点，并通过AddInputPortLink和AddInputPortLink将link，port,feature instance联系起来</span><br><span class="line">e. HandlePendingRequests //规则todo</span><br></pre></td></tr></table></figure>
</li>
<li><p>feature2Graph执行PCR</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a. WalkAllExtSinkLinks先将用到的outputPort所在Sinklink状态设置为OutputPending.普通预览为 Display_Out port和rt_metadata.然后ProcessInputDepsForUpstreamFeatureRequest去设置将sinklink下input port对应的stream和stream对应的hBuffer作为该request下的一个requestOutputInfo参数。</span><br><span class="line"></span><br><span class="line">chifeature2graph.cpp:<span class="number">2488</span> ProcessInputDepsForUpstreamFeatureRequest() RealTime_0 Feature:Graph-URO:<span class="number">0</span>_Graph:RealtimeFG: New request <span class="number">0</span> <span class="keyword">for</span> port Display_Out: &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>&#125;, linkType <span class="number">2</span>, hBuffer <span class="number">0xb4000074b2d34db0</span>K, hMetadata <span class="number">0x0</span>K</span><br><span class="line">chifeature2graph.cpp:<span class="number">2488</span> ProcessInputDepsForUpstreamFeatureRequest() RealTime_0 Feature:Graph-URO:<span class="number">0</span>_Graph:RealtimeFG: New request <span class="number">0</span> <span class="keyword">for</span> port rt_metadata_out。: &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;, linkType <span class="number">2</span>, hBuffer <span class="number">0x0</span>K, hMetadata <span class="number">0x0</span>K</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b. WalkBackFromLink检查如果OutputLink上有一个link状态为OutputPending，且不存在状态为NotVisited的Output Links，那么我们去通过ProcessUpstreamFeatureRequest处理PCR。</span><br><span class="line">    先创建ChiFeature2RequestObject对象，普通预览有两个numRequestOutputs，分别是我们之前提到的Display_Out和rt_metadata_out。</span><br><span class="line">    InitializeRequestInfo() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 : Outputs Requested: Request:<span class="number">0</span> Port : (Display_Out:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">3</span>:<span class="number">0</span>)</span><br><span class="line">    InitializeRequestInfo() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 : Outputs Requested: Request:<span class="number">0</span> Port : (rt_metadata_out:<span class="number">0</span>:<span class="number">0</span>:<span class="number">5</span>:<span class="number">3</span>:<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    ProcessRequest进行处理PCR</span><br><span class="line">    chifeature2base.cpp:<span class="number">410</span> ProcessRequest() RealTime: ProcessRequest ChiFeature2RequestCommands:: <span class="number">0</span>, requestState <span class="number">0</span> requestId <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">1.</span> 此时ChiFeature2RequestState::Initialized，HandlePrepareRequest改变状态到<span class="string">&quot;ReadyToExecute&quot;</span></span><br><span class="line">    chifeature2requestobject.cpp:<span class="number">640</span> SetCurRequestState() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0: FeatureRequest State [Initialized]-&gt;[ReadyToExecute] <span class="keyword">for</span> RequestIndex:<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">2.</span> 此时ChiFeature2RequestState::ReadyToExecute，执行OnProcessRequest处理</span><br><span class="line">    <span class="string">&quot;chifeature2base.cpp:566 OnProcessRequest() FRO-URO:0_RealtimeFG:RealTime_0 requestState:ReadyToExecute, requestId:0&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">3.</span>执行HandleExecuteProcessRequest，状态变为<span class="string">&quot;Executing&quot;</span></span><br><span class="line">    chifeature2requestobject.cpp:<span class="number">640</span> SetCurRequestState() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0: FeatureRequest State [ReadyToExecute]-&gt;[Executing] <span class="keyword">for</span> RequestIndex:<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">4.</span> 由feature instance 去执行 OnExecuteProcessRequest</span><br><span class="line">    OnExecuteProcessRequest() Frame: <span class="number">0</span> Request: <span class="number">0</span> StageId: <span class="number">255</span> SeqId: <span class="number">255</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">5.</span>第一次执行stage为无效的，所以需要执行第二次</span><br><span class="line">    MoveToNextProcessSequenceInfo() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 Move to NextProcess SequenceID:<span class="number">0</span> BatchIndex:<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;OnProcessRequest() FRO-URO:0_RealtimeFG:RealTime_0 requestState:Executing, requestId:0&quot;</span></span><br><span class="line">    </span><br><span class="line">    PopulatePortConfiguration来设置feature instance的一些属性，比如：<span class="comment">//规则todo</span></span><br><span class="line">    </span><br><span class="line">    OnSelectSensorMode</span><br><span class="line">    UpdateSensorMode</span><br><span class="line">    ChxUtils::FillDefaultTuningMetadata</span><br><span class="line">    </span><br><span class="line">    chifeature2base.cpp:<span class="number">1489</span> FillDefaultDesiredSensorMode() Current modeIndex  <span class="number">0</span></span><br><span class="line">    chxutils.cpp:<span class="number">2088</span> FillTuningModeData() SensorMode <span class="number">0</span> UC <span class="number">0</span> feature <span class="number">0</span> <span class="number">0</span> scene <span class="number">0</span> effect <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;PopulatePortConfiguration下设置session 下的output port&quot;</span></span><br><span class="line">    chifeature2base.cpp:<span class="number">6596</span> PopulatePortConfiguration() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 Set output port config <span class="keyword">for</span> session:<span class="number">0</span>, pipeline: <span class="number">0</span> port Display_Out numPorts <span class="number">3</span> - Stream: <span class="number">0xb4000073e2c91110</span>K </span><br><span class="line">    chifeature2base.cpp:<span class="number">6596</span> PopulatePortConfiguration() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 Set output port config <span class="keyword">for</span> session:<span class="number">0</span>, pipeline: <span class="number">0</span> port Raw_Out numPorts <span class="number">3</span> - Stream: <span class="number">0xb4000073e2c926f0</span>K</span><br><span class="line">    chifeature2base.cpp:<span class="number">6596</span> PopulatePortConfiguration() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 Set output port config <span class="keyword">for</span> session:<span class="number">0</span>, pipeline: <span class="number">0</span> port rt_metadata_out numPorts <span class="number">3</span> - Stream: <span class="number">0x0</span>K</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;ImportExternalTargetBuffer中Importing ChiStreamBuffer和metadata，规则todo&quot;</span></span><br><span class="line">    chitargetbuffermanager.cpp:<span class="number">1319</span> ImportExternalTargetBuffer() [PortTargetBuffer_RealTime:Display_Out_0] Import <span class="keyword">external</span> target succeed <span class="keyword">for</span> seqId=<span class="number">0</span>, targetIdx=<span class="number">0</span>, pTarget=<span class="number">0xb4000074b2d34e59</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;SetPortDescriptor规则todo&quot;</span></span><br><span class="line">    chifeature2requestobject.cpp:<span class="number">4240</span> MapFeatureIdentifier() Mapping [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>] --&gt; [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">    chifeature2requestobject.cpp:<span class="number">1940</span> SetSequencePortDescriptor() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 OutputConfiguration For PortName:Raw_Out GID[Session:<span class="number">0</span> Pipeline:<span class="number">0</span> Port:<span class="number">1</span> Type:<span class="number">3</span>] BatchIndex:<span class="number">0</span></span><br><span class="line">    chifeature2requestobject.cpp:<span class="number">4376</span> GetLocalFeatureIdentifier() No such mapping, FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 GlobalId[<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">    chifeature2requestobject.cpp:<span class="number">2748</span> GetBufferInfo() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 OutputConfiguration Buffer <span class="keyword">not</span> <span class="keyword">set</span> <span class="keyword">for</span> GID &#123;<span class="number">0</span>, <span class="number">0</span> <span class="number">4</span>&#125;, result:<span class="number">6</span></span><br><span class="line">    hitargetbuffermanager.cpp:<span class="number">541</span> SetupTargetBuffer() [PortTargetBuffer_RealTime:Raw_Out_0]_TBM Info: MinCnt:<span class="number">9</span> MaxCnt:<span class="number">64</span> ProdQ:<span class="number">0</span> ConsumerQ:<span class="number">0</span>[PortTargetBuffer_RealTime:Raw_Out_0]_TargetBuffer Info: seqId:<span class="number">0</span> pTargetBufferInfo:<span class="number">0xb4000074b2d0e7e0</span> targetIndex:<span class="number">0</span> type:<span class="number">1</span>[PortTargetBuffer_RealTime:Raw_Out_0]_Buffer Info: metadata:<span class="number">0x0</span> phBuffer:<span class="number">0xb400007492ca3af0</span> releaseFence:<span class="number">0x0</span>(<span class="number">0</span>) <span class="number">0</span> <span class="built_in">ref</span>Count=<span class="number">1</span></span><br><span class="line">    chifeature2requestobject.cpp:<span class="number">4304</span> SetAndGetLocalFeatureIdentifier() Mapped Feature Identifier [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>] --&gt; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    chifeature2requestobject.cpp:<span class="number">2556</span> SetSequenceBufferInfo() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 OutputConfiguration For GID[Session:<span class="number">0</span> Pipeline:<span class="number">0</span> Port:<span class="number">1</span> Type:<span class="number">0</span>] BatchIndex:<span class="number">0</span>, BufferHandle:<span class="number">0xb4000074b2d0e7e0</span> Key:<span class="number">0xb4000073e2c926f0</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;AcquireResource设置信号量&quot;</span></span><br><span class="line">    chifeature2realtime.cpp:<span class="number">1512</span> AcquireResource() Acquire resource: semaphore count <span class="number">5</span> </span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;SubmitRequestToSession通过GetStreamBuffer，将sinkbuffer的私有数据给到hanle和key映射到的streambuffer的私有数据&quot;</span></span><br><span class="line">    chifeature2base.cpp:<span class="number">1181</span> SubmitRequestToSession() GetStreamBuffer: <span class="number">0xb4000074b2d1a710</span> <span class="number">12970367424553095440</span></span><br><span class="line">    chifeature2base.cpp:<span class="number">130</span> GetStreamBuffer() RealTime: Buffer Private: <span class="number">0x0</span> pSinkStream: <span class="number">0xb4000073e2c91110</span> target buffer stream: <span class="number">0xb400007402c56488</span> sink <span class="keyword">private</span>: <span class="number">0xb400007452d49410</span></span><br><span class="line">    chifeature2base.cpp:<span class="number">1181</span> SubmitRequestToSession() GetStreamBuffer: <span class="number">0xb4000074b2d0e7e0</span> <span class="number">12970367424553101040</span></span><br><span class="line">    chifeature2base.cpp:<span class="number">130</span> GetStreamBuffer() RealTime: Buffer Private: <span class="number">0x0</span> pSinkStream: <span class="number">0xb4000073e2c926f0</span> target buffer stream: <span class="number">0xb4000073e2c926f0</span> sink <span class="keyword">private</span>: <span class="number">0xb400007452d31850</span></span><br><span class="line">    <span class="string">&quot;之后将request传递到pipeline&quot;</span><span class="comment">//但是没有看见OnSubmitRequestToSession log打印</span></span><br><span class="line">    chifeature2base.cpp:<span class="number">1302</span> SubmitRequestToSession() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0 Submitting Request:<span class="number">0</span> with numOutputs:<span class="number">2</span> pPriv <span class="number">0xb400007452d4f558</span> session:<span class="number">0xb40000732e345040</span> pipeline:<span class="number">0xb400007532e83940</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;设置状态为ChiFeature2RequestState::OutputResourcePending&quot;</span></span><br><span class="line">    chifeature2requestobject.cpp:<span class="number">640</span> SetCurRequestState() FRO-URO:<span class="number">0</span>_RealtimeFG:RealTime_0: FeatureRequest State [Executing]-&gt;[OutputResourcePending] <span class="keyword">for</span> RequestIndex:<span class="number">0</span></span><br><span class="line">    <span class="string">&quot;CanRequestContinue停止&quot;</span></span><br><span class="line">    chifeature2base.cpp:<span class="number">8044</span> CanRequestContinue() Feature2RequestState OutputResourcePending continueRequest <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>


</li>
</ol>
<p><a id="3"></a></p>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><ul>
<li><a href="#0">返回主目录</a></li>
</ul>
<h3 id="ChiFeature2RequestState"><a href="#ChiFeature2RequestState" class="headerlink" title="ChiFeature2RequestState"></a>ChiFeature2RequestState</h3><p><img src="/images/feature2/feature2-FeatureRequest-state-machine.png" alt="alt"></p>
<p>feature2Request的处理是多线程并发的，当第7帧状态为OutputResourcePending，第0帧状态设置为OutputNotificationPending，并继续处理到达Complete状态。  </p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;关键字：SetCurRequestState&quot;</span></span><br></pre></td></tr></table></figure>


<p>而request 0 OutputNotificationPending状态处理的线程从以下log开始打印：<br>从这开始  log文件feature-new-3.log</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">camxsensornode.<span class="attr">cpp:</span><span class="number">6883</span> SensorThreadJobCallback() <span class="attr">InitializeSensor:</span> start</span><br><span class="line"></span><br><span class="line">此线程是由<span class="attr">SensorNode:</span>:ProcessingNodeFinalizeInitialization通过<span class="attr">SensorPostJobCommand:</span>:InitializeSensor去PostJob触发线程。</span><br><span class="line"></span><br><span class="line">pSensorPostJob-&gt;sensorJobCommand = <span class="attr">SensorPostJobCommand:</span>:InitializeSensor; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>Feature2</tag>
      </tags>
  </entry>
  <entry>
    <title>内核实践1-linux5.12.0-rc8</title>
    <url>/archives/8a2ade1b.html</url>
    <content><![CDATA[<h1 id="内核实践1-linux5-12-0-rc8"><a href="#内核实践1-linux5-12-0-rc8" class="headerlink" title="内核实践1-linux5.12.0-rc8"></a>内核实践1-linux5.12.0-rc8</h1><p><a id="0"></a></p>
<ul>
<li><a href="#1">环境配置</a></li>
<li><a href="#2">编译</a></li>
<li><a href="#3">qemu-guest-run</a></li>
<li><a href="#4">gdb</a></li>
<li><a href="#5">BusyBox</a></li>
<li><a href="#6">参考</a></li>
</ul>
<a id="more"></a>
<hr>
<p>这篇文章除了回顾，更多的是希望能进一步探索内核，包括gdb和qemu</p>
<p><a id="1"></a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>本地系统为ubuntu14,gcc和g++版本都太老，需要升级到ubuntu16.<br>同时ubuntu16默认的gcc和gcc都是4.9的，也需要升级到5.0以上<br>升级完查看本地环境,已经升级到6.0</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#gcc --version</span></span><br><span class="line"><span class="attribute">gcc</span> (Ubuntu <span class="number">6</span>.<span class="number">5</span>.<span class="number">0</span>-<span class="number">2</span>ubuntu<span class="number">1</span>~<span class="number">16</span>.<span class="number">04</span>) <span class="number">6</span>.<span class="number">5</span>.<span class="number">0</span> <span class="number">20181026</span></span><br><span class="line"><span class="comment">#g++ --version</span></span><br><span class="line"><span class="attribute">g</span>++ (Ubuntu <span class="number">6</span>.<span class="number">5</span>.<span class="number">0</span>-<span class="number">2</span>ubuntu<span class="number">1</span>~<span class="number">16</span>.<span class="number">04</span>) <span class="number">6</span>.<span class="number">5</span>.<span class="number">0</span> <span class="number">20181026</span></span><br></pre></td></tr></table></figure>

<p>升级gcc和g++如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br><span class="line">sudo apt-<span class="keyword">get</span> install gcc<span class="number">-6</span> g++<span class="number">-6</span></span><br><span class="line"><span class="comment">//通过软链接选择高版本</span></span><br><span class="line"># cd /usr/bin</span><br><span class="line"># rm -rf gcc</span><br><span class="line"># ln -s gcc<span class="number">-6</span> gcc</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root      <span class="number">7</span>  <span class="number">4</span>月 <span class="number">15</span> <span class="number">18</span>:<span class="number">50</span> gcc -&gt; gcc<span class="number">-6</span></span><br><span class="line"></span><br><span class="line">#  rm -rf g++</span><br><span class="line"># ln -s g++<span class="number">-6</span> g++</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root      <span class="number">7</span>  <span class="number">4</span>月 <span class="number">15</span> <span class="number">18</span>:<span class="number">51</span> g++ -&gt; g++<span class="number">-6</span></span><br></pre></td></tr></table></figure>

<p><a id="2"></a></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><a href="#0">回到主目录</a></p>
<p>在编译前，先简单介绍一下内核相关文件的存放路径</p>
<ol>
<li>内核源码放置路径 目前我们系统uname -r 为:4.4.0-210-generic ，源代码路径:/usr/src/linux-headers-4.4.0-210-generic</li>
<li>配置文件，内核引导文件，虚拟挂载系统文件 /boot config-4.4.0-210-generic  vmlinuz-4.4.0-210-generic initrd.img-4.4.0-210-generic </li>
<li>模块安装路径: 方便我们动态链接模块 /lib/modules/4.4.0-210-generic</li>
</ol>
<h3 id="编译内核文档"><a href="#编译内核文档" class="headerlink" title="编译内核文档"></a>编译内核文档</h3><p>linux提供了内核帮助文档，这里支持很多种格式，这里我使用html的，使用sphinx编写，需要配置环境</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>安装依赖包</span><br><span class="line">apt-get install graphviz dvipng latexmk librsvg2-bin texlive-xetex</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>window10内核子系统需要额外安装,否则make menuconfig异常</span><br><span class="line">apt-get install python3-pip libncurses-dev flex bison libelf-dev</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>通过pip安装   sphinx_rtd_theme </span><br><span class="line"><span class="comment">#apt-get install python-pip</span></span><br><span class="line"><span class="comment">#pip install sphinx sphinx_rtd_theme</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/bin/pip&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    sys.<span class="keyword">exit</span>(main())</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python2.7/dist-packages/pip/__init__.py&quot;</span>, line <span class="number">16</span>, <span class="keyword">in</span> main</span><br><span class="line">    from pip._internal.utils.entrypoints import _wrapper</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python2.7/dist-packages/pip/_internal/utils/entrypoints.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from pip._internal.cli.main import main</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python2.7/dist-packages/pip/_internal/cli/main.py&quot;</span>, line <span class="number">60</span></span><br><span class="line">    sys.stderr.write(f<span class="string">&quot;ERROR: &#123;exc&#125;&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="regexp">//</span>pipe版本不对，需要升级到pip3.<span class="number">5</span></span><br><span class="line"><span class="comment">#wget https://bootstrap.pypa.io/pip/3.5/get-pip.py </span></span><br><span class="line"><span class="comment">#python3.5 get-pip.py</span></span><br><span class="line"><span class="comment">## whereis pip</span></span><br><span class="line">pip: <span class="regexp">/usr/</span>bin<span class="regexp">/pip /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/pip3.5 /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/pip /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/pip3.4 /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/pip2.7 /u</span>sr<span class="regexp">/share/m</span>an<span class="regexp">/man1/</span>pip.<span class="number">1</span>.gz</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>通过pip3.<span class="number">5</span>重新安装sphinx</span><br><span class="line"><span class="comment">#pip3.5 install sphinx sphinx_rtd_theme</span></span><br><span class="line">Installing collected packages: pytz, sphinxcontrib-serializinghtml, sphinxcontrib-qthelp, sphinxcontrib-jsmath, sphinxcontrib-htmlhelp, sphinxcontrib-devhelp, sphinxcontrib-applehelp, snowballstemmer, Pygments, packaging, imagesize, docutils, babel, alabaster, sphinx, sphinx-rtd-theme</span><br><span class="line">  Attempting uninstall: pytz</span><br><span class="line">    Found existing installation: pytz <span class="number">2014.10</span></span><br><span class="line">    Uninstalling pytz-<span class="number">2014.10</span>:</span><br><span class="line">      Successfully uninstalled pytz-<span class="number">2014.10</span></span><br><span class="line">Successfully installed Pygments-<span class="number">2.8</span>.<span class="number">1</span> alabaster-<span class="number">0.7</span>.<span class="number">12</span> babel-<span class="number">2.9</span>.<span class="number">0</span> docutils-<span class="number">0.16</span> imagesize-<span class="number">1.2</span>.<span class="number">0</span> packaging-<span class="number">20.9</span> pytz-<span class="number">2021.1</span> snowballstemmer-<span class="number">2.1</span>.<span class="number">0</span> sphinx-<span class="number">3.5</span>.<span class="number">4</span> sphinx-rtd-theme-<span class="number">0.5</span>.<span class="number">2</span> sphinxcontrib-applehelp-<span class="number">1.0</span>.<span class="number">2</span> sphinxcontrib-devhelp-<span class="number">1.0</span>.<span class="number">2</span> sphinxcontrib-htmlhelp-<span class="number">1.0</span>.<span class="number">3</span> sphinxcontrib-jsmath-<span class="number">1.0</span>.<span class="number">1</span> sphinxcontrib-qthelp-<span class="number">1.0</span>.<span class="number">3</span> sphinxcontrib-serializinghtml-<span class="number">1.1</span>.<span class="number">4</span></span><br><span class="line"></span><br><span class="line">在Makefile下查看文档生成细节，mandocs已经不再支持</span><br><span class="line"><span class="regexp">//</span>生成内核文档html</span><br><span class="line"><span class="comment">#make htmldocs</span></span><br><span class="line"><span class="regexp">//</span>查看内核文档</span><br><span class="line">浏览器： Documentation<span class="regexp">/output/i</span>ndex.html</span><br></pre></td></tr></table></figure>



<h3 id="内核功能配置文件"><a href="#内核功能配置文件" class="headerlink" title="内核功能配置文件"></a>内核功能配置文件</h3><p>编译前确定清除之前遗留的配置文件</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">make mrproper</span></span><br></pre></td></tr></table></figure>

<p>最好使用本机系统使用的配置文件，从/boot/config-4.4.0-210-generic copy到 编译根目录.config</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cp</span> /boot/config-<span class="number">4</span>.<span class="number">4</span>.<span class="number">0</span>-<span class="number">210</span>-generic  /github/linux/.config</span><br></pre></td></tr></table></figure>

<p>以图形界面的方式选择内核功能</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span> menuconfig  &gt;我们在我们<span class="built_in">copy</span>过来的配置上增加修改，配置完成保存下来的和<span class="built_in">copy</span>过来的不是完全一样的</span><br></pre></td></tr></table></figure>

<p>这里我们针对我们之后需要的调试做配置修改<br>确定增加kdb和kgdb支持</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">确定CONFIG_GDB_SCRIPTS打开</span><br><span class="line">确定架构支持CONFIG_FRAME_POINTER</span><br><span class="line"><span class="comment">//kgdb</span></span><br><span class="line">CONFIG_FRAME_POINTER=<span class="symbol">y</span></span><br><span class="line">CONFIG_KGDB=<span class="symbol">y</span></span><br><span class="line">CONFIG_KGDB_SERIAL_CONSOLE=<span class="symbol">y</span></span><br><span class="line"><span class="comment">//kdb</span></span><br><span class="line">CONFIG_FRAME_POINTER=<span class="symbol">y</span></span><br><span class="line">CONFIG_KGDB=<span class="symbol">y</span></span><br><span class="line">CONFIG_KGDB_SERIAL_CONSOLE=<span class="symbol">y</span></span><br><span class="line">CONFIG_KGDB_KDB=<span class="symbol">y</span></span><br><span class="line">CONFIG_KDB_KEYBOARD=<span class="symbol">y</span></span><br></pre></td></tr></table></figure>

<p>增加initramfs编译到内核文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">CONFIG_BLK_DEV_INITRD</span>=y</span><br><span class="line"><span class="attr">CONFIG_INITRAMFS_SOURCE</span>=<span class="string">&quot;../rootfs&quot;</span>    &gt;&gt;需要在linux git库的上一级目录创建rootfs目录，否则会有编译错误提示</span><br><span class="line"><span class="attr">CONFIG_INITRAMFS_ROOT_UID</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">CONFIG_INITRAMFS_ROOT_GID</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h3><p>完整的内核编译生成</p>
<ol>
<li>符号映射表，我们可以通过这个在内核运行异常时去根据符号找到对应的变量名   编译根目录System.map</li>
<li>压缩引导内核bzImage,属于gzip压缩的vmlinuz,不是ELF的vmlinux</li>
<li>虚拟文件系统，用来引导早期运行的驱动等，比如SCSI硬盘需要模块化，加载模块需要在根目录，但是此时硬盘根本无法使用，目录树不存在，故使用initrd来新建虚拟文件系统，仿真成为根目录，initrd.img-xxxx  需要mkinitrd生成</li>
</ol>
<p>编译引导内核</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">make</span> <span class="selector-tag">bzImage</span>     <span class="selector-tag">path</span><span class="comment">// arch/x86/boot/arch/x86/boot</span></span><br><span class="line"><span class="comment">//非 ELF文件，gzip特殊压缩的引导文件</span></span><br><span class="line"># <span class="selector-tag">file</span> <span class="selector-tag">bzImage</span> </span><br><span class="line"><span class="selector-tag">bzImage</span>: <span class="selector-tag">Linux</span> <span class="selector-tag">kernel</span> <span class="selector-tag">x86</span> <span class="selector-tag">boot</span> <span class="selector-tag">executable</span> <span class="selector-tag">bzImage</span>, <span class="selector-tag">version</span> <span class="selector-tag">5</span><span class="selector-class">.12</span><span class="selector-class">.0-rc8</span>+ (root<span class="variable">@sholck</span>) <span class="selector-id">#1</span> <span class="selector-tag">SMP</span> <span class="selector-tag">Fri</span> <span class="selector-tag">Apr</span> <span class="selector-tag">23</span> <span class="selector-tag">16</span><span class="selector-pseudo">:19</span><span class="selector-pseudo">:21</span> <span class="selector-tag">CST</span> <span class="selector-tag">2021</span>, <span class="selector-tag">RO-rootFS</span>, <span class="selector-tag">swap_dev</span> <span class="selector-tag">0x9</span>, <span class="selector-tag">Normal</span> <span class="selector-tag">VGA</span></span><br></pre></td></tr></table></figure>

<p>编译模块</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">make modules</span></span><br></pre></td></tr></table></figure>

<p>内核模块安装</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">make modules_install  模块copy到 /<span class="class"><span class="keyword">lib</span>/<span class="title">modules</span></span></span><br><span class="line">/<span class="class"><span class="keyword">lib</span>/<span class="title">modules</span>  <span class="comment">#ls</span></span></span><br><span class="line"><span class="number">4.4</span>.<span class="number">0</span>-<span class="number">148</span>-generic  <span class="number">4.4</span>.<span class="number">0</span>-<span class="number">210</span>-generic  <span class="number">5.12</span>.<span class="number">0</span>-rc8+</span><br></pre></td></tr></table></figure>

<p>创建虚拟文件系统</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"># mkinitramfs -o /<span class="keyword">boot</span>/initrd.img-5.12.0-rc8+ 5.12.0-rc8+</span><br><span class="line">#<span class="keyword">file</span> /<span class="keyword">boot</span>/initrd.img-5.12.0-rc8+</span><br><span class="line">/<span class="keyword">boot</span>/initrd.img-5.12.0-rc8+: ASCII cpio archive (SVR4 with <span class="keyword">no</span> <span class="keyword">CRC</span>)    &lt;&lt;实际使用报错</span><br><span class="line"></span><br><span class="line"><span class="comment">//window子系统WSL下执行</span></span><br><span class="line">#mkinitramfs -o /<span class="keyword">boot</span>/initrd.img-5.13.0-rc3+ 5.13.0-rc3+</span><br><span class="line">cryptsetup: <span class="keyword">ERROR</span>: Couldn&#x27;t resolve device rootfs</span><br><span class="line">cryptsetup: WARNING: Couldn&#x27;t determine root device</span><br><span class="line">grep: /proc/swaps: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br><span class="line">W: Couldn&#x27;t identify <span class="keyword">type</span> of root <span class="keyword">file</span> system <span class="keyword">for</span> fsck hook</span><br><span class="line"># <span class="keyword">file</span> /<span class="keyword">boot</span>/initrd.img-5.13.0-rc3+ &gt;&gt;格式不一样</span><br><span class="line">/<span class="keyword">boot</span>/initrd.img-5.13.0-rc3+: LZ4 compressed data (v0.1-v0.9)</span><br></pre></td></tr></table></figure>

<p>copy内核文件到boot</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">#cp arch<span class="regexp">/x86/</span>boot<span class="regexp">/bzImage /</span>boot/vmlinuz-<span class="number">5.12</span>.<span class="number">0</span>-rc8+ </span><br><span class="line">#cp .config <span class="regexp">/boot/</span>config-<span class="number">5.12</span>.<span class="number">0</span>-rc8+</span><br></pre></td></tr></table></figure>

<p>vmlinux 未压缩的内核ELF文件，not stripped，可以供gdb调试使用<br>stripped和 not stripped区别， stripped的程序没有符号表信息，相反no stripped的程序会更方便调试</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file vmlinux</span></span><br><span class="line"><span class="attribute">vmlinux</span>: ELF <span class="number">64</span>-bit LSB executable, x<span class="number">86</span>-<span class="number">64</span>, version <span class="number">1</span> (SYSV), statically linked, BuildID[sha<span class="number">1</span>]=<span class="number">3849</span>f<span class="number">6</span>b<span class="number">6</span>d<span class="number">84719</span>fc<span class="number">749595</span>fef<span class="number">84659843</span>f<span class="number">50</span>bb<span class="number">02</span>, not stripped</span><br></pre></td></tr></table></figure>

<p>压缩过后的vmlinux文件</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd arch/x86/boot/compressed</span></span><br><span class="line"><span class="comment"># file vmlinux.bin  </span></span><br><span class="line"><span class="attribute">vmlinux</span>.bin: ELF <span class="number">64</span>-bit LSB executable, x<span class="number">86</span>-<span class="number">64</span>, version <span class="number">1</span> (SYSV), statically linked, BuildID[sha<span class="number">1</span>]=<span class="number">5</span>c<span class="number">57</span>d<span class="number">3</span>fb<span class="number">9</span>d<span class="number">396</span>d<span class="number">1</span>a<span class="number">98</span>b<span class="number">4</span>a<span class="number">482</span>e<span class="number">5</span>e<span class="number">8</span>d<span class="number">5</span>d<span class="number">26543</span>bdc<span class="number">1</span>, stripped</span><br><span class="line"><span class="comment"># file vmlinux</span></span><br><span class="line"><span class="attribute">vmlinux</span>: ELF <span class="number">64</span>-bit LSB shared object, x<span class="number">86</span>-<span class="number">64</span>, version <span class="number">1</span> (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure>


<p><a id="3"></a></p>
<h2 id="qemu-guest-run"><a href="#qemu-guest-run" class="headerlink" title="qemu-guest-run"></a>qemu-guest-run</h2><p><a href="#0">回到主目录</a></p>
<p>先检查cpu是否支持虚拟化</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"># egrep -c <span class="string">&#x27;(svm|vmx)&#x27;</span> <span class="regexp">/proc/</span>cpuinfo</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>检查本机已经加载的虚拟化模块</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># lsmod |grep -n <span class="string">&quot;kvm&quot;</span></span><br><span class="line"><span class="number">15</span>:kvm_intel             <span class="number">176128</span>  <span class="number">0</span></span><br><span class="line"><span class="number">39</span>:kvm                   <span class="number">561152</span>  <span class="number">1</span> kvm_intel</span><br><span class="line"><span class="number">42</span>:irqbypass              <span class="number">16384</span>  <span class="number">1</span> kvm</span><br><span class="line"><span class="comment">//如果没有，执行modprobe kvm和 modprobe kvm_intel, /dev下会有一个kvm的字符设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//window子系统WSL下执行lsmod异常</span></span><br></pre></td></tr></table></figure>
<p>qemu依赖包安装</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">apt-get <span class="keyword">install </span>qemu qemu-kvm libvirt-<span class="keyword">bin </span>virt-manager <span class="keyword">bridge-utils </span>-y</span><br></pre></td></tr></table></figure>

<p>检查qemu-kvm是否安装成功</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"># virsh -c qemu:///system list</span><br><span class="line"><span class="code"> Id    名称                         状态</span></span><br><span class="line">----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>本次测试使用initramfs来运行<br>我们需要将initramfs加载到内存rootfs，启动init进程</p>
<p>编写init代码，并打包到cpio中</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">cat &gt; hello.c &lt;&lt; EOF</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  printf(<span class="string">&quot;Hello world!\n&quot;</span>)<span class="comment">;</span></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">999999999</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#gcc -static hello.c -o init</span></span><br><span class="line"><span class="meta">#echo init | cpio -o -H newc | gzip &gt; test.cpio.gz</span></span><br><span class="line"><span class="meta">#echo init | cpio -o -H newc  &gt; test.cpio</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># file test.cpio</span></span><br><span class="line">test.cpio: ASCII cpio archive (SVR4 <span class="keyword">with</span> no CRC)</span><br><span class="line"><span class="meta"># file test.cpio.gz </span></span><br><span class="line">test.cpio.gz: gzip compressed data, last modified: Mon Apr <span class="number">26</span> <span class="number">08</span>:<span class="number">21</span>:<span class="number">00</span> <span class="number">2021</span>, from Unix</span><br></pre></td></tr></table></figure>

<p>执行测试</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -m <span class="number">2</span>G -enable-kvm -initrd test.cpio -kernel vmlinuz-<span class="number">5.12</span>.<span class="number">0</span>-rc8+ -s -append <span class="string">&quot;console=ttyS0 rdinit=init loglevel=8&quot;</span>  -nographic  <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee build.log</span><br><span class="line"></span><br><span class="line">//-m 指定guest 运行内存,默认为<span class="number">128</span>M</span><br><span class="line">对应报错</span><br><span class="line"><span class="literal">warning</span>: TCG doesn<span class="symbol">&#x27;t</span> support requested feature: CPUID.<span class="number">01</span>H:ECX.vmx [<span class="built_in">bit</span> <span class="number">5</span>]</span><br><span class="line">qemu: fatal: Trying <span class="keyword">to</span> execute code outside RAM <span class="keyword">or</span> ROM at <span class="number">0</span>x00000000000b17f3</span><br><span class="line"></span><br><span class="line">//-kernel 指定bzImage，不能是ELF的vmlinux</span><br><span class="line">对应报错</span><br><span class="line">qemu: linux kernel too old <span class="keyword">to</span> load a ram disk</span><br><span class="line"></span><br><span class="line">//-initrd 指定cpio包，gzip -d 压缩或者不压缩都行, 我们自己制作</span><br><span class="line">对应报错</span><br><span class="line">Trying <span class="keyword">to</span> unpack rootfs image as initramfs...</span><br><span class="line">Initramfs unpacking failed: write <span class="literal">error</span></span><br><span class="line"></span><br><span class="line">// -s gdbserver端口，gdb可以通过这个端口和guest连接</span><br><span class="line"></span><br><span class="line">//rdinit=init,指定rootfs下init的程序</span><br><span class="line">正确打印：</span><br><span class="line"> Run init as init <span class="keyword">process</span>  init作为init进程</span><br><span class="line">   <span class="keyword">with</span> arguments:</span><br><span class="line">     init  </span><br><span class="line">   <span class="keyword">with</span> environment:</span><br><span class="line">     HOME=/</span><br><span class="line">     TERM=linux</span><br><span class="line">Hello world!</span><br><span class="line"></span><br><span class="line">//如果kernel没有找到init进程，便会去解析参数root=,挂载另一个文件系统，将initrd image写入到 ram disk设备，这个时候需要指定root=作为ram disk</span><br><span class="line">Failed <span class="keyword">to</span> create /dev/root: -<span class="number">2</span></span><br><span class="line">VFS: Cannot <span class="keyword">open</span> root device <span class="string">&quot;(null)&quot;</span> <span class="keyword">or</span> unknown-<span class="keyword">block</span>(<span class="number">0</span>,<span class="number">0</span>): <span class="literal">error</span> -<span class="number">2</span></span><br><span class="line">Kernel panic - <span class="keyword">not</span> syncing: VFS: Unable <span class="keyword">to</span> mount root fs <span class="keyword">on</span> unknown-<span class="keyword">block</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>结果展示，WSL运行，ubuntu主机抄的原主机的config配置，没有Hello world打印<br><img src="/images/linux/init-hello.png" alt="alt"></p>
<p><a id="4"></a></p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p><a href="#0">回到主目录</a></p>
<p>针对gdb调试，需要导入其包含符号表的vmlinux<br>符号表单独保存在一个文件System.map</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#gdb</span></span><br><span class="line">file vmlinux</span><br><span class="line">或者</span><br><span class="line"><span class="meta">#gdb vmlinux</span></span><br></pre></td></tr></table></figure>

<p>连接guest的gdb server</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(gdb) target remote:<span class="number">1234</span></span><br><span class="line">Remote debugging using :<span class="number">1234</span></span><br><span class="line"><span class="number">0xffffffffb9a7ce6e</span> <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure>

<p>设置断点</p>
<blockquote>
<p>符号表对应 ffffffff82ce4bdb T start_kernel</p>
</blockquote>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">b</span> start_kernel</span><br><span class="line"><span class="attribute">Note</span>: breakpoint <span class="number">2</span> also set at pc <span class="number">0</span>xffffffff<span class="number">82</span>ce<span class="number">4</span>bdb. </span><br><span class="line"><span class="attribute">Breakpoint</span> <span class="number">3</span> at <span class="number">0</span>xffffffff<span class="number">82</span>ce<span class="number">4</span>bdb: file init/main.c, line <span class="number">853</span></span><br></pre></td></tr></table></figure>

<p><a id="5"></a></p>
<h2 id="BusyBox"><a href="#BusyBox" class="headerlink" title="BusyBox"></a>BusyBox</h2><p><a href="#0">回到主目录</a></p>
<p><a href="https://busybox.net/">busybox下载地址</a><br>下载完成tar -jxvf解压到/github/busybox</p>
<p>同kernel,配置文件为.config  </p>
<h3 id="配置安装"><a href="#配置安装" class="headerlink" title="配置安装"></a>配置安装</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">清除配置：<span class="keyword">make</span> mrproper</span><br><span class="line">配置confi<span class="variable">g:</span> <span class="keyword">make</span> menuconfig</span><br><span class="line">编译：<span class="keyword">make</span> -j12</span><br><span class="line">安装: <span class="keyword">make</span> install  </span><br><span class="line">安装成功提示：</span><br><span class="line">You will probably need <span class="keyword">to</span> <span class="keyword">make</span> your busybox binary</span><br><span class="line">setuid root <span class="keyword">to</span> ensure <span class="keyword">all</span> configured applets will</span><br><span class="line">work properly.</span><br></pre></td></tr></table></figure>

<h3 id="制作initramfs"><a href="#制作initramfs" class="headerlink" title="制作initramfs"></a>制作initramfs</h3><p>制作步骤：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mkdir -p initramfs/x86-busybox</span></span><br><span class="line"><span class="comment">#cd initramfs/x86-busybox</span></span><br><span class="line"><span class="comment">#mkdir -p &#123;bin,sbin,etc,proc,sys,usr/&#123;bin,sbin&#125;&#125;  创建一下文件夹</span></span><br><span class="line"></span><br><span class="line">//补充以下，若无会导致本地ubuntu16的qemu启动的内核无echo日志输出，并直接进入 因为init退出触发的Kernel panic:  not syncing: Attempted to kill init</span><br><span class="line">//WSL没有以下内核启动依旧可以进入虚拟文件系统</span><br><span class="line"><span class="comment">#mkdir dev</span></span><br><span class="line"><span class="comment">#cp -a /dev/&#123;null,console,tty,tty1,tty2,tty3,tty4&#125; dev/.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cp -a ~/busybox/busybox-1.33.1/_install/* .  // -a等价于 -pdr  递归赋值文件，保留文件属性，软连接文件复制</span></span><br><span class="line"><span class="comment">#find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; initramfs-busybox-x86.cpio.gz  //打包</span></span><br><span class="line"></span><br><span class="line">//创建init进程 sh脚本解释器使用sh，非bash,否则允许报错Failed to execute init (<span class="keyword">error</span> <span class="number">-2</span>)</span><br><span class="line"><span class="comment">#cat &gt; init&lt;&lt; EOF</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">mount -t <span class="keyword">proc</span><span class="title"> none</span> /<span class="keyword">proc</span></span><br><span class="line">mount -t<span class="title"> sysfs</span> none /sys</span><br><span class="line">echo -e &quot;\nBoot<span class="title"> took</span> $(cut -d&#x27; &#x27; -f1 /<span class="keyword">proc</span>/uptime)<span class="title"> seconds\n&quot;</span></span><br><span class="line"><span class="title">exec</span> /bin/sh</span><br><span class="line">EOF</span><br><span class="line">#chmod<span class="title"> u+x</span> init</span><br><span class="line">//运行</span><br><span class="line">#qemu-system-x86_64 -m 2G  -initrd<span class="title"> initramfs-busybox-x86.cpio.gz</span> -kernel ../vmlinuz-5.13.0-rc3+ -s -append &quot;console=ttyS0<span class="title"> rdinit=init</span> loglevel=8&quot;  -nographic  2&gt;&amp;1 |<span class="title"> tee</span> build.log </span><br></pre></td></tr></table></figure>
<p>使用busybox编译出来的initramfs报错，因为没有把init文件放置在initramfs/x86-busybox，导致打包时没有打包进去</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[    <span class="number">3.464451</span>] <span class="attr">md:</span> <span class="string">Waiting</span> <span class="string">for</span> <span class="string">all</span> <span class="string">devices</span> <span class="string">to</span> <span class="string">be</span> <span class="string">available</span> <span class="string">before</span> <span class="string">autodetect</span></span><br><span class="line">[    <span class="number">3.465100</span>] <span class="attr">md:</span> <span class="string">If</span> <span class="string">you</span> <span class="string">don&#x27;t</span> <span class="string">use</span> <span class="string">raid,</span> <span class="string">use</span> <span class="string">raid=noautodetect</span></span><br><span class="line">[    <span class="number">3.465719</span>] <span class="attr">md:</span> <span class="string">Autodetecting</span> <span class="string">RAID</span> <span class="string">arrays.</span></span><br><span class="line">[    <span class="number">3.466213</span>] <span class="attr">md:</span> <span class="string">autorun</span> <span class="string">...</span></span><br><span class="line">[    <span class="number">3.466446</span>] <span class="attr">md:</span> <span class="string">...</span> <span class="string">autorun</span> <span class="string">DONE.</span></span><br><span class="line">[    <span class="number">3.477954</span>] <span class="string">modprobe</span> <span class="string">(67)</span> <span class="attr">used greatest stack depth:</span> <span class="number">14688</span> <span class="string">bytes</span> <span class="string">left</span></span><br><span class="line">[    <span class="number">3.479263</span>] <span class="attr">VFS:</span> <span class="string">Cannot</span> <span class="string">open</span> <span class="string">root</span> <span class="string">device</span> <span class="string">&quot;(null)&quot;</span> <span class="string">or</span> <span class="string">unknown-block(0,0):</span> <span class="string">error</span> <span class="number">-6</span></span><br><span class="line">[    <span class="number">3.480054</span>] <span class="string">Please</span> <span class="string">append</span> <span class="string">a</span> <span class="string">correct</span> <span class="string">&quot;root=&quot;</span> <span class="string">boot</span> <span class="string">option;</span> <span class="attr">here are the available partitions:</span></span><br><span class="line">[    <span class="number">3.481083</span>] <span class="string">0b00</span>         <span class="number">1048575</span> <span class="string">sr0</span></span><br><span class="line">[    <span class="number">3.481213</span>]  <span class="attr">driver:</span> <span class="string">sr</span></span><br><span class="line">[    <span class="number">3.481794</span>] <span class="attr">Kernel panic - not syncing: VFS:</span> <span class="string">Unable</span> <span class="string">to</span> <span class="string">mount</span> <span class="string">root</span> <span class="string">fs</span> <span class="string">on</span> <span class="string">unknown-block(0,0)</span></span><br><span class="line"></span><br><span class="line"><span class="string">以上错误是因为kernel没有找到init进程，便会去解析参数root=,挂载另一个文件系统，将initrd</span> <span class="string">image写入到</span> <span class="string">ram</span> <span class="string">disk设备，这个时候需要指定root=作为ram</span> <span class="string">disk</span></span><br></pre></td></tr></table></figure>
<p>正确打包再执行一次<br><img src="/images/linux/busybox-enter-console.png" alt="alt"><br>控制台执行exit以后会进入kernel crash，trace如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[  137.134655]</span> Kernel panic - <span class="keyword">not</span> syncing: Attempted to kill init! exitcode=<span class="number">0x00000000</span></span><br><span class="line"><span class="string">[  137.135538]</span> CPU: <span class="number">0</span> PID: <span class="number">1</span> Comm: sh Not tainted <span class="number">5.13</span><span class="number">.0</span>-rc3+ #<span class="number">1</span></span><br><span class="line"><span class="string">[  137.136020]</span> Hardware name: QEMU Standard PC (i440FX + PIIX, <span class="number">1996</span>), BIOS <span class="number">1.13</span><span class="number">.0</span><span class="number">-1</span>ubuntu1<span class="number">.1</span> <span class="number">04</span>/<span class="number">01</span>/<span class="number">2014</span></span><br><span class="line"><span class="string">[  137.136867]</span> Call Trace:</span><br><span class="line"><span class="string">[  137.138242]</span>  dump_stack+<span class="number">0x64</span>/<span class="number">0x7c</span></span><br><span class="line"><span class="string">[  137.138576]</span>  panic+<span class="number">0xf6</span>/<span class="number">0x2b7</span></span><br><span class="line"><span class="string">[  137.138765]</span>  ? set_next_entity+<span class="number">0x98</span>/<span class="number">0x160</span></span><br><span class="line"><span class="string">[  137.139003]</span>  do_exit.cold+<span class="number">0xa0</span>/<span class="number">0xe3</span></span><br><span class="line"><span class="string">[  137.139205]</span>  do_group_exit+<span class="number">0x35</span>/<span class="number">0x90</span></span><br><span class="line"><span class="string">[  137.139412]</span>  __x64_sys_exit_group+<span class="number">0xf</span>/<span class="number">0x10</span></span><br><span class="line"><span class="string">[  137.139682]</span>  do_syscall_64+<span class="number">0x40</span>/<span class="number">0x80</span></span><br><span class="line"><span class="string">[  137.139896]</span>  entry_SYSCALL_64_after_hwframe+<span class="number">0x44</span>/<span class="number">0xae</span></span><br><span class="line"><span class="string">[  137.140384]</span> RIP: <span class="number">0033</span>:<span class="number">0x495f96</span></span><br><span class="line"><span class="string">[  137.140834]</span> Code: fa <span class="number">41</span> b8 e7 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> be <span class="number">3</span>c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> eb <span class="number">15</span> <span class="number">66</span> <span class="number">0f</span> <span class="number">1f</span> <span class="number">44</span> <span class="number">00</span> <span class="number">00</span> <span class="number">89</span> d7 <span class="number">89</span> f0 <span class="number">0f</span> <span class="number">05</span> <span class="number">48</span> <span class="number">3</span>d <span class="number">00</span> f0 ff ff <span class="number">77</span> <span class="number">22</span> f4 <span class="number">89</span> d7 <span class="number">44</span> <span class="number">89</span> c0 <span class="number">0f</span> <span class="number">05</span> &lt;<span class="number">48</span>&gt; <span class="number">3</span>d <span class="number">00</span> f0</span><br><span class="line"><span class="string">[  137.142124]</span> RSP: <span class="number">002</span>b:<span class="number">00007f</span>ff3d497458 EFLAGS: <span class="number">00000202</span> ORIG_RAX: <span class="number">00000000000000e7</span></span><br><span class="line"><span class="string">[  137.142598]</span> RAX: ffffffffffffffda RBX: <span class="number">0000000001</span>a4a004 RCX: <span class="number">0000000000495f</span>96</span><br><span class="line"><span class="string">[  137.142986]</span> RDX: <span class="number">0000000000000000</span> RSI: <span class="number">000000000000003</span>c RDI: <span class="number">0000000000000000</span></span><br><span class="line"><span class="string">[  137.143379]</span> RBP: <span class="number">0000000000000004</span> R08: <span class="number">00000000000000e7</span> R09: ffffffffffffffe0</span><br><span class="line"><span class="string">[  137.143764]</span> R10: <span class="number">0000000001</span>a4bf10 R11: <span class="number">0000000000000202</span> R12: <span class="number">00007f</span>ff3d497828</span><br><span class="line"><span class="string">[  137.144145]</span> R13: <span class="number">0000000000000000</span> R14: <span class="number">0000000000000001</span> R15: <span class="number">0000000000000000</span></span><br><span class="line"><span class="string">[  137.145227]</span> Kernel Offset: <span class="number">0x24600000</span> <span class="keyword">from</span> <span class="number">0xffffffff81000000</span> (relocation range: <span class="number">0xffffffff80000000</span><span class="number">-0xffffffffbfffffff</span>)</span><br><span class="line"><span class="string">[  137.146167]</span> ---[ end Kernel panic - <span class="keyword">not</span> syncing: Attempted to kill init! exitcode=<span class="number">0x00000000</span> ]---</span><br></pre></td></tr></table></figure>
<p>当init进程退出时，触发panic<br><img src="/images/linux/init-process-exit-trigger-panic.png" alt="alt"></p>
<p><a id="6"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wipan/p/9272255.html">在qemu上运行BusyBox</a><br><a href="https://consen.github.io/2018/01/17/debug-linux-kernel-with-qemu-and-gdb/">使用QEMU和GDB调试Linux内核</a></p>
<p><a href="#0">回到主目录</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-kernel-make</tag>
        <tag>busybox</tag>
        <tag>QEMU</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>生产力工具记录</title>
    <url>/archives/8a2ade17.html</url>
    <content><![CDATA[<h1 id="生产力工具记录"><a href="#生产力工具记录" class="headerlink" title="生产力工具记录"></a>生产力工具记录</h1><p><a id="0"></a></p>
<p>下面是一些生产力工具</p>
<ul>
<li><a href="#1">Hexo</a></li>
<li><a href="#2">draw.io</a></li>
<li><a href="#3">vim/tmux/cscope/ctags/fzf/taglist/ag</a></li>
<li><a href="#4">HHKB types</a></li>
<li><a href="#5">git</a></li>
<li><a href="#6">meld&amp;diffuse</a></li>
</ul>
<a id="more"></a> 
<hr>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p><a id="1"></a><br>hexo官网链接：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<p>本地主要维护两个仓库： </p>
<blockquote>
<p>1.hexo-blog维护 博客hexo源代码 私有库<br>2.xiaer1921.github.io  维护博客hexo 生产代码</p>
</blockquote>
<h3 id="本地实践记录："><a href="#本地实践记录：" class="headerlink" title="本地实践记录："></a>本地实践记录：</h3><ol>
<li>在执行hexo g之后，如果需要将代码部署到github，需要额外在public文件夹中新加文件CNAME，内容为你的域名，比如sholck.top.或者在source文件中增加CNAME文件，这样在hexo g时会自动复制到public文件下。  </li>
<li>需要将配置的md文件配置为644权限  </li>
<li>本地安装配置</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">npm config set registry https:<span class="regexp">//</span>registry.npm.taobao.org  <span class="regexp">//</span>增加淘宝源</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">hexo -v </span><br><span class="line">报错 <span class="regexp">/usr/</span>bin/env: node: 没有那个文件或目录</span><br><span class="line">解决：为node增加软链接 sudo ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/nodejs /u</span>sr<span class="regexp">/bin/</span>node</span><br><span class="line"></span><br><span class="line">报错 SyntaxError: Use of const <span class="keyword">in</span> strict mode. </span><br><span class="line">原因: node版本过低 node -v 查看版本</span><br><span class="line">解决：升级nodejs </span><br><span class="line">npm cache clean -f</span><br><span class="line">sudo npm install -g n</span><br><span class="line">sudo n stable</span><br><span class="line"></span><br><span class="line">重新安装hexo-cli</span><br><span class="line"><span class="comment">#hexo -v 正确打印各插件版本信息</span></span><br></pre></td></tr></table></figure>

<h3 id="功能学习"><a href="#功能学习" class="headerlink" title="功能学习"></a>功能学习</h3><ol>
<li>当前文本无法高亮,使用==text==无效，使用以下第三种方法</li>
</ol>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. hexo支持，但是有道云不支持</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;红色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:green&quot;</span>&gt;绿色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:yellow&quot;</span>&gt;黄色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line">&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">&quot;color:blue&quot;</span>&gt;蓝色&lt;/<span class="built_in">label</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. ==text== 有道云支持，但是hexo不支持</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. &lt;<span class="built_in">font</span> <span class="built_in">color</span>=#2196F3 &gt;text&lt;/<span class="built_in">font</span>&gt; 兼容</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>代码高亮配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">在_config.yml中增加如下配置：</span><br><span class="line"><span class="attr">highlight_theme:</span> night eightie <span class="comment">//主题</span></span><br><span class="line">auto_detect 设置为<span class="literal">true</span></span><br><span class="line">themes<span class="regexp">/next/</span>source/lib </span><br><span class="line">路径下下载主题git clone git<span class="meta">@github</span>.<span class="attr">com:</span>chriskempson/tomorrow-theme.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用命令</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">clean 清理生成文件</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g 生成文件</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">s 启动hexo服务</span></span><br><span class="line"><span class="attr">http</span>:<span class="string">//localhost:4000/  可查看hexo启动运行的hexo服务界面</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>图片加载</p>
</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">先把图片放在<span class="keyword">source</span><span class="regexp">/images/</span></span><br><span class="line">eg：<span class="keyword">source</span><span class="regexp">/images/</span>CR-hal-chi-camx.png</span><br><span class="line">    </span><br><span class="line">在md中加入:</span><br><span class="line">    ![alt](<span class="regexp">/images/</span>PCR-hal-chi-camx.png)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>置顶+标签</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">置顶+标签：</span><br><span class="line"><span class="keyword">tags:</span> Camx</span><br><span class="line">top: true</span><br><span class="line">多tags配置：</span><br><span class="line"><span class="keyword">tags:</span> </span><br><span class="line">    - Camera-Camx</span><br><span class="line">    - PCR</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加分类页</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>categories 创建分类页</span><br><span class="line">在文章增加如下部分：</span><br><span class="line"></span><br><span class="line">categories: Hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>折叠</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>代码与文本对齐<br>需要三个反单引号和前面的文本对齐</p>
</li>
<li><p>跳转</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在需要跳转的前面增加</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用跳转</span><br><span class="line"><span class="bullet">-</span> [<span class="string">前言 基本概念的简介</span>](<span class="link">#1</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>折叠</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  文本和标题空一行，且文本前最好多一个table</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h2><p><a id="2"></a><br><a href="#0">返回主目录</a><br>制图神器，与github相关联，通过XML来描述图片元素之间关系，每次修改都会push到github，制图相关的还有XMind,StarUML,但是StarUML界面不太友好<br>目前使用到的是时序图，实现比较简单，但是发现想要在完成的时序图中间增加流程比较困难。</p>
<hr>
<h2 id="vim-neovim-zsh-tmux-cscope-ctags-fzf-taglist"><a href="#vim-neovim-zsh-tmux-cscope-ctags-fzf-taglist" class="headerlink" title="vim/neovim/zsh/tmux/cscope/ctags/fzf/taglist"></a>vim/neovim/zsh/tmux/cscope/ctags/fzf/taglist</h2><p><a id="3"></a><br><a href="#0">返回主目录</a><br>用了vim已经有5年了，一路上磕磕巴巴，插件也试了不少，tmux，fzf都是慢慢中间开始学过来的，终究没有从vim脱坑，配置文件改了又改，可惜一直没有记录，现在像一个大杂烩。故重新复习，总结，修炼。</p>
<h3 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h3><p>因为vim上配置markdown-preview不生效，所以改为使用neovim<br><a href="https://github.com/neovim/neovim/wiki/Installing-Neovim">neovim-github</a><br><a href="https://neovim.io/">neovim-home</a></p>
<h4 id="neovim安装配置"><a href="#neovim安装配置" class="headerlink" title="neovim安装配置"></a>neovim安装配置</h4><p><a href="https://github.com/neovim/neovim/wiki/Installing-Neovim#ubuntu">neovim-github-ubuntu安装</a></p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">//pip install neovim 不推荐</span><br><span class="line">//本地采用稳定源找不到neovim安装包，故采用unstable安装</span><br><span class="line">sudo<span class="built_in"> add-apt-repository </span>ppa:neovim-ppa/unstable</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install neovim</span><br><span class="line">在~/.zshrc中增加alias vim=&#x27;nvim&#x27;</span><br></pre></td></tr></table></figure>
<p><a href="https://neovim.io/doc/user/nvim.html#nvim-from-vim">nvim复用vim的配置</a></p>
<h3 id="zsh学习"><a href="#zsh学习" class="headerlink" title="zsh学习"></a>zsh学习</h3><p>zsh配置到一半发现ubuntu子系统运行命令卡顿，也没有专门去处理。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">bash切到zsh,一般ubuntu会自带zsh.</span><br><span class="line"></span><br><span class="line">https:<span class="regexp">//</span>ohmyz.sh/<span class="comment">#install提示的命令无法下载，故选择github下载安装</span></span><br><span class="line"></span><br><span class="line">执行sh install.sh会进行安装，配置完成会提示配置文件为~/.zshrc.</span><br><span class="line">我们需要将一些~<span class="regexp">/.bashrc下的客制化移动到~/</span>.zshrc.</span><br><span class="line"></span><br><span class="line">安装完成界面命令提示符已经发生改变，不在是之前的一大长串的当前路径，仅仅提示当前所在的文件名。</span><br><span class="line"></span><br><span class="line">发现两个问题：</span><br><span class="line"><span class="number">1</span>.bash和zsh 按键绑定不一样，fzf 配置文件运行报错。</span><br><span class="line"><span class="number">2</span>.zsh 运行卡顿，不知道是不是我window下ubuntu子系统的缘故。</span><br></pre></td></tr></table></figure>

<p>更新：之前在WSL上简单配置zsh，因zsh运行卡顿且比较忙就停了，今重新修炼zsh.<br>目的是使用zsh插件来加快开发效率</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">新建lynx用户</span><br><span class="line"><span class="section">#useradd -m lynx</span></span><br><span class="line">修改默认shell</span><br><span class="line"><span class="section">#chsh -s /bin/zsh</span></span><br><span class="line"></span><br><span class="line">[<span class="string">github-Zsh</span>](<span class="link">https://github.com/ohmyzsh/ohmyzsh</span>)</span><br><span class="line">安装：</span><br><span class="line">/github/ohmyzsh/tools#./install.sh</span><br><span class="line">安装过程中会提示是否配置zsh为用户默认shell</span><br></pre></td></tr></table></figure>

<h4 id="插件管理vim-plug"><a href="#插件管理vim-plug" class="headerlink" title="插件管理vim-plug"></a>插件管理vim-plug</h4><p><a href="https://github.com/junegunn/vim-plug">vim-plug-github</a></p>
<p><a href="https://github.com/junegunn/vim-plug#usage/">插件安装使用</a></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&#x27;curl -fLo &quot;$&#123;XDG_DATA_HOME:-$HOME/.local/share&#125;&quot;/nvim/site/autoload/plug.vim --create-dirs \</span></span><br><span class="line"><span class="string">       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&#x27;</span></span><br><span class="line"></span><br><span class="line">将库中的plug.vim <span class="keyword">copy</span>到nvim安装路径</span><br><span class="line">➜  tools git:(main) ✗ nvim --version</span><br><span class="line">   system vimrc <span class="keyword">file</span>: <span class="string">&quot;$VIM/sysinit.vim&quot;</span>   </span><br><span class="line">  fall-back <span class="keyword">for</span> $VIM: <span class="string">&quot;/usr/share/nvim&quot;</span> &gt;&gt;系统安装路径</span><br><span class="line">#cp plug.vim  <span class="regexp">/usr/</span>share<span class="regexp">/nvim/</span><span class="keyword">runtime</span><span class="regexp">/autoload/</span>.</span><br><span class="line"><span class="comment">//插件安装:PlugInstall</span></span><br></pre></td></tr></table></figure>

<h4 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h4><p>插件配置：默认放置于$ZSH/plugins中，路径和source的位置相关联</p>
<h5 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a>fzf</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">作用: 文件跳转</span><br><span class="line">[<span class="string">github-fzf</span>](<span class="link">https://github.com/junegunn/fzf</span>)</span><br><span class="line">将fzf库copy到ohmyzsh/plugins/fzf并安装./install.sh</span><br><span class="line">增加fzf到plugin list中</span><br><span class="line">验证：ctrl+t</span><br><span class="line"></span><br><span class="line">export FZF<span class="emphasis">_BASE=$ZSH/plugins/fzf应该放置于source $ZSH/oh-my-zsh.sh前</span></span><br></pre></td></tr></table></figure>
<h5 id="Autosuggestion"><a href="#Autosuggestion" class="headerlink" title="Autosuggestion"></a>Autosuggestion</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">作用: 根据历史命令进行提示</span><br><span class="line">按照插件说明安装</span><br><span class="line"><span class="meta">#</span><span class="bash">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span></span><br><span class="line">增加zsh-autosuggestions到plugin list中</span><br></pre></td></tr></table></figure>

<h5 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h5><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">验证未生效</span><br><span class="line">作用：文件跳转，类似fzf</span><br><span class="line">#git clone git:<span class="comment">//github.com/joelthelion/autojump.git</span></span><br><span class="line">将autojump库<span class="keyword">copy</span>到ohmyzsh<span class="regexp">/plugins/</span>autojump并安装./install.py</span><br><span class="line">在.zshrc中增加[[ -s <span class="regexp">/root/</span>.autojump<span class="regexp">/etc/</span>profile.d<span class="regexp">/autojump.sh ]] &amp;&amp; source /</span>root<span class="regexp">/.autojump/</span>etc<span class="regexp">/profile.d/</span>autojump.sh</span><br></pre></td></tr></table></figure>

<h5 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h5><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">按照INSTALL.md配置</span><br><span class="line">#git clone https:<span class="comment">//github.com/zsh-users/zsh-syntax-highlighting.git</span></span><br><span class="line">将库下载到ohmyzsh<span class="regexp">/plugins/</span></span><br><span class="line">#make install</span><br><span class="line">#增加<span class="keyword">source</span> <span class="regexp">/usr/</span>local<span class="regexp">/share/</span>zsh-syntax-highlighting/zsh-syntax-highlighting.zsh到.zshrc</span><br><span class="line">现象：会发现命令正确是绿色的，而不正确的是红色的</span><br></pre></td></tr></table></figure>

<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><blockquote>
<ol>
<li>目录浏览和跳转：d查看目录历史和通过序号跳转  </li>
<li>直接使用..和…</li>
</ol>
</blockquote>
<h3 id="vim-markdown配置"><a href="#vim-markdown配置" class="headerlink" title="vim-markdown配置"></a>vim-markdown配置</h3><h4 id="Tabular"><a href="#Tabular" class="headerlink" title="Tabular"></a>Tabular</h4><p><a href="https://github.com/godlygeek/tabular">基于正则的文本对齐-github</a></p>
<p>作用:文本对齐，对注释对齐非常有用<br>:help tabular</p>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="type">Vundle</span>管理安装：<span class="type">Plugin</span> <span class="symbol">&#x27;godlygeek</span>/tabular&#x27;</span><br></pre></td></tr></table></figure>
<p>注释对齐eg:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//txt</span></span><br><span class="line">text1     <span class="comment">// comment1</span></span><br><span class="line">text2           <span class="comment">//comment2</span></span><br><span class="line">执行:Tabularize  <span class="regexp">/\/\/</span>   进行<span class="comment">//对其</span></span><br><span class="line">text1 <span class="comment">// comment1</span></span><br><span class="line">text2 <span class="comment">// comment2</span></span><br></pre></td></tr></table></figure>
<h4 id="vim-markdown"><a href="#vim-markdown" class="headerlink" title="vim-markdown"></a>vim-markdown</h4><p><a href="https://github.com/plasticboy/vim-markdown">vim-markdown插件-github</a><br>根据github描述，需要在vim-markdown插件前安装Tabular</p>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="type">Vundle</span>管理安装 <span class="type">Plugin</span> <span class="symbol">&#x27;plasticboy</span>/vim-markdown&#x27;</span><br></pre></td></tr></table></figure>
<p>发现打开markdown文件有折叠，可以在.vimrc中增加如下来取消折叠</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">set</span> <span class="attribute">foldlevel</span>=9999</span><br><span class="line">autocmd BufNewFile,BufRead *.md <span class="builtin-name">set</span> nofoldenable</span><br></pre></td></tr></table></figure>

<h4 id="vim-markdown-toc"><a href="#vim-markdown-toc" class="headerlink" title="vim-markdown-toc"></a>vim-markdown-toc</h4><p>为markdown自动生成目录<br><a href="https://github.com/mzlogin/vim-markdown-toc">vim-markdown-toc-github</a><br><a href="https://mazhuang.org/2015/12/19/vim-markdown-toc/">中文说明</a></p>
<h4 id="instant-markdown-d"><a href="#instant-markdown-d" class="headerlink" title="instant-markdown-d"></a>instant-markdown-d</h4><p><a href="https://github.com/instant-markdown/instant-markdown-d">instant-markdown-d github</a></p>
<p>安装以后打开md文件WSL可以自动打开页面实时预览，但是本地Ubuntu需要打开网页<code>http://localhost:8090/</code>预览</p>
<p>安装如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">//安装依赖包</span><br><span class="line">sudo <span class="built_in">add</span>-apt-repository <span class="keyword">pp</span><span class="variable">a:chris</span>-lea/node.js</span><br><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install nodejs</span><br><span class="line">npm -g install instant-markdown-d</span><br><span class="line"></span><br><span class="line">//配置init.<span class="keyword">vim</span>,通过PlugInstall安装</span><br><span class="line">Plug <span class="string">&#x27;instant-markdown/vim-instant-markdown&#x27;</span>, &#123;<span class="string">&#x27;for&#x27;</span>: <span class="string">&#x27;markdown&#x27;</span>, <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;yarn install&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>打开.md文件预览即可</p>
<h4 id="markdown-preview"><a href="#markdown-preview" class="headerlink" title="markdown-preview"></a>markdown-preview</h4><p>本地vim无法实时预览markdown文件，故迁移使用neovim, 暂时依旧无法预览</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span>-markdown gi<span class="variable">t:</span>(master) <span class="keyword">vim</span> --<span class="keyword">version</span> | <span class="keyword">grep</span> +<span class="keyword">python</span></span><br><span class="line">+conceal           +linebreak         +<span class="keyword">python3</span>           +visualextra</span><br><span class="line"></span><br><span class="line"><span class="keyword">im</span>-markdown gi<span class="variable">t:</span>(master) <span class="keyword">vim</span> --<span class="keyword">version</span>              </span><br><span class="line">VIM - Vi IMproved <span class="number">8.2</span> (<span class="number">2019</span> Dec <span class="number">12</span>, compiled Sep <span class="number">22</span> <span class="number">2020</span> <span class="number">12</span>:<span class="number">05</span>:<span class="number">44</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/iamcco/markdown-preview.nvim#install--usage">插件安装</a></p>
<h3 id="fzf记录"><a href="#fzf记录" class="headerlink" title="fzf记录"></a>fzf记录</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install highlight</span><br><span class="line"><span class="comment">#vim ~/.bashrc</span></span><br><span class="line"><span class="comment"># 搜索时高亮显示文件内容</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">FZF_DEFAULT_OPTS</span>=<span class="string">&quot;--height 40% --layout=reverse --preview &#x27;(highlight -O ansi &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500&#x27;&quot;</span></span><br><span class="line"><span class="comment"># 指定索引目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">FZF_DEFAULT_COMMAND</span>=<span class="string">&#x27;find code_pathXX&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#vim ~/.vimrc</span></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class="string">&#x27;dir&#x27;</span>: <span class="string">&#x27;~/.fzf&#x27;</span>, <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;./install --all&#x27;</span>  &#125;</span><br><span class="line">Plugin <span class="string">&#x27;junegunn/fzf.vim&#x27;</span></span><br><span class="line"><span class="builtin-name">set</span> runtimepath^=~/.vim/bundle/fzf</span><br><span class="line"><span class="builtin-name">set</span> rtp+=/root/.vim/bundle/fzf/bin/fzf</span><br><span class="line">nmap &lt;C-p&gt; :Files&lt;CR&gt;</span><br><span class="line">nmap &lt;C-e&gt; :Buffers&lt;CR&gt;</span><br><span class="line">nmap &lt;C-h&gt; :History&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;let g:fzf_action = &#123; &#x27;ctrl-e&#x27;: &#x27;edit&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="tmux记录"><a href="#tmux记录" class="headerlink" title="tmux记录"></a>tmux记录</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">当前绘画面板panel最大化 bind+z 在当前窗口有多panel时，如果需要当前panel最大化，这个方法是很方便的</span><br><span class="line">新建<span class="keyword">session</span>   tmux <span class="built_in">new</span> -s SESSION_NAME</span><br><span class="line">删除指定的<span class="keyword">session</span>           tmux kill-<span class="keyword">session</span> -t SESSION_NAME</span><br><span class="line">连接上某个已存在的<span class="keyword">session</span>   tmux a -t SESSION_NAME;</span><br><span class="line"><span class="keyword">session</span> 重命名   bind,:   输入 <span class="keyword">rename</span>-<span class="keyword">session</span> <span class="built_in">new</span>-<span class="type">name</span></span><br><span class="line">当安装neovim后，发现tmux的窗口名在<span class="keyword">rename</span>之后也会跟着当前路径改变，需要在配置中增加<span class="keyword">set</span>-<span class="keyword">option</span> -g allow-<span class="keyword">rename</span> <span class="keyword">off</span>，重载配置 tmux source ~/.tmux.conf</span><br></pre></td></tr></table></figure>

<h3 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a>cscope</h3><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alias</span> cdcope-<span class="literal">note</span>=<span class="symbol">&#x27;cscope</span> -Rbkq&#x27;  cscope更新索引</span><br></pre></td></tr></table></figure>

<h3 id="taglist"><a href="#taglist" class="headerlink" title="taglist"></a>taglist</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">map &lt;silent&gt; &lt;leader&gt;w <span class="symbol">:WMToggle&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="winmanager"><a href="#winmanager" class="headerlink" title="winmanager"></a>winmanager</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">//<span class="keyword">vim</span>的操作内部是用<span class="keyword">wincmd</span>去控制的</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span> :WMToggle<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">let</span> WManager_Close_On_Select=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> WManager_GainFocus_On_ToggleOpen = <span class="number">1</span></span><br><span class="line">WManager_Close_On_Select 客制化函数，用来选择文件以后退出</span><br><span class="line">WManager_GainFocus_On_ToggleOpen 客制化函数，用来快捷键显示winmanager菜单</span><br></pre></td></tr></table></figure>

<h3 id="gnome终端配置"><a href="#gnome终端配置" class="headerlink" title="gnome终端配置"></a>gnome终端配置</h3><pre><code>内置方案：深色
文件颜色：#839496
背景颜色：#002B36</code></pre>
<h2 id="HHKB"><a href="#HHKB" class="headerlink" title="HHKB"></a>HHKB</h2><p><a id="4"></a><br><a href="#0">返回主目录</a><br>HHKB使用手册<br><img src="/images/tool/HHKB.png" alt="alt"></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">DIP开关说明：</span><br><span class="line">开关下为off，上为<span class="keyword">on</span></span><br><span class="line"><span class="number">1</span>和<span class="number">2</span> 设置为off, windows键盘设置模式</span><br><span class="line"><span class="number">3</span> <span class="keyword">on</span>为backspace, off为delete, 设置为<span class="keyword">on</span></span><br><span class="line"><span class="number">4</span>和<span class="number">5</span>搭配使用， <span class="number">5</span> <span class="keyword">on</span>， 会互换 al和◇功能</span><br><span class="line"><span class="number">4</span> <span class="keyword">on</span> ,◇功能设置为Fn</span><br><span class="line"><span class="number">6</span> <span class="keyword">on</span>启用唤醒</span><br></pre></td></tr></table></figure>

<p>上下左右跳转：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">将功能4设置为on</span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ [</span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ ;  </span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ &#x27; </span></span><br><span class="line"><span class="attr">Fn</span> <span class="string">+ /</span></span><br></pre></td></tr></table></figure>

<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p><a id="5"></a><br><a href="#0">返回主目录</a>  </p>
<h3 id="删除敏感信息提交"><a href="#删除敏感信息提交" class="headerlink" title="删除敏感信息提交"></a>删除敏感信息提交</h3><p>当提交敏感信息入库需要包括提交记录删除处理<br>目前git bebase中的drop实操未规，貌似git已经不再支持</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>切换到新的分支</span><br><span class="line">git checkout --orphan latest_branch</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>缓存所有文件（除了.gitignore中声名排除的）</span><br><span class="line">git add -A</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>提交跟踪过的文件（Commit the changes）</span><br><span class="line">git commit -am <span class="string">&quot;commit message&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>删除master分支（Delete the branch）</span><br><span class="line">git branch -D main</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>重命名当前分支为master</span><br><span class="line">git branch -m main</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>提交到远程master分支 （Finally, force update your repository）</span><br><span class="line">git push -f origin main</span><br></pre></td></tr></table></figure>

<h3 id="git-lfs"><a href="#git-lfs" class="headerlink" title="git lfs"></a>git lfs</h3><p>本地需要将vim设置提交到github，但是bundle下又有子git仓，提交失败，因为bundle下不修改，直接打包提交，但是文件太大，无法提交，采用git lfs管理。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. curl -s http<span class="variable">s:</span>//packagecloud.io/install/repositories/github/git-lfs/script.<span class="keyword">deb</span>.<span class="keyword">sh</span> | sudo bash</span><br><span class="line"><span class="number">2</span>. sudo apt-<span class="built_in">get</span> install git-lfs</span><br><span class="line"><span class="number">3</span>. git lfs install</span><br><span class="line"><span class="number">4</span>. git lfs track <span class="keyword">vim</span>/bundle.tar.gz  可以在当前目录下发现.gitattributes文件记录track配置, 该文件需要提交入库</span><br><span class="line"><span class="number">5</span>. # git lfs track  &gt;&gt;查看当前配置</span><br><span class="line">Listing tracked patterns</span><br><span class="line">    <span class="keyword">vim</span>/bundle.tar.gz (.gitattributes)</span><br><span class="line">Listing excluded patterns</span><br><span class="line"><span class="number">6</span>. # git lfs <span class="keyword">ls</span>-<span class="keyword">files</span> &gt;&gt;当前跟踪的文件</span><br><span class="line">aa849f2b24 * <span class="keyword">vim</span>/bundle.tar.gz</span><br></pre></td></tr></table></figure>
<p>提交以后，github上有<code>Stored with Git LFS</code> 来标记此文件，见下图<br><img src="/images/tool/store-with-git-lfs.png" alt="alt"></p>
<p>之后使用<code>git lfs clone</code>，因为git-lfs只提供1G的空间和每月1G的流量，查看path:setting&gt;&gt;Billing<br><img src="/images/tool/git-lfs.png" alt="alt"></p>
<p>超过会报如下错：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">batch response: This repository <span class="keyword">is</span> <span class="keyword">over</span> <span class="keyword">its</span> data quota. Account responsible <span class="keyword">for</span> LFS bandwidth should purchase more data packs <span class="keyword">to</span> restore access</span><br></pre></td></tr></table></figure>
<p>如下方法在流量超过以后依旧无法拉取或者下载</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> fork这个库</span><br><span class="line"><span class="number">2.</span> 在仓库setting&gt;&gt;Archives 打开Include Git LFS objects <span class="keyword">in</span> archives.</span><br><span class="line"><span class="number">3.</span> Danger Zone&gt;&gt;Archive <span class="keyword">this</span> repository,之后在clone或者下载zip包依旧无法成功拉取lfs文件</span><br></pre></td></tr></table></figure>
<h2 id="meld-amp-diffuse"><a href="#meld-amp-diffuse" class="headerlink" title="meld&amp;diffuse"></a>meld&amp;diffuse</h2><p><a id="6"></a><br><a href="#0">返回主目录</a><br>linux环境代码比较集成工具</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install</span> meld diffuse</span><br><span class="line">由于meld需要使用python2环境，当提示<span class="keyword">import</span> meld失败时，需要<span class="keyword">check</span> /usr/<span class="keyword">bin</span>/python的指向是不是python2,如果不是,修改meld，使用python2处理</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/84773275">高效做笔记:vim + markdown</a><br><a href="https://www.jianshu.com/p/24aefcd4ca93">vim安装markdown插件</a></p>
]]></content>
      <categories>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>hexo</tag>
        <tag>draw.io</tag>
        <tag>fzf</tag>
      </tags>
  </entry>
  <entry>
    <title>session flush timeout学习</title>
    <url>/archives/8a2ade16.html</url>
    <content><![CDATA[<h1 id="session-flush-timeout学习"><a href="#session-flush-timeout学习" class="headerlink" title="session flush timeout学习"></a>session flush timeout学习</h1><ul>
<li>背景</li>
<li>超时处理流程</li>
<li>Condition处理</li>
<li>扩展</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前做过的mtkcam或者camx,都有对timeout进行调整的处理。当前碰到一个拍照没有图片返回的案例，故对这个案例进行分析。</p>
<a id="more"></a>

<p>异常log如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">RuninT:CameraTest2( 4357): take piture time out(TIMEOUT<span class="emphasis">_LIMIT/1000s) and quit test</span></span><br><span class="line"><span class="emphasis">RuninT:Utility( 4357): upfail:pref_</span>cameratake<span class="emphasis">_piture_</span>time<span class="emphasis">_out</span></span><br><span class="line"><span class="emphasis">RuninT:CameraTest2( 4357): onPause()</span></span><br><span class="line"><span class="emphasis">RuninT:CameraTest2( 4357): close Camera...</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"> camxhal3.cpp:1488 flush() HalOp: Begin FLUSH: 0xb4000070d3e2d040, logicalCameraId: 1, cameraId: 1</span></span><br><span class="line"><span class="emphasis"> CamX    (  834): [<span class="string">ERROR</span>][<span class="symbol">CORE   </span>] camxsession.cpp:125 WaitTillAllResultsAvailable() TimedWait for results timed out at 350 ms with error CamxResultETimeout! Pending results:</span></span><br><span class="line"><span class="emphasis"> CamX    (  834): [<span class="string">ERROR</span>][<span class="symbol">CORE   </span>] camxsession.cpp:138 WaitTillAllResultsAvailable() Flush Timedout</span></span><br><span class="line"><span class="emphasis"> CamX    (  834): [<span class="string">ERROR</span>][<span class="symbol">CORE   </span>] camxsession.cpp:284 FallbackFlush() Fallback TimedWait for results timed out at 100 ms with error CamxResultETimeout!</span></span><br><span class="line"><span class="emphasis"> CamX    (  834): [<span class="string">CORE_CFG</span>][<span class="symbol">CORE   </span>] camxnode.cpp:10938 Flush() Flushing Node JPEG_</span>SW:0 for requestId 1 on pipeline InternalZSLYuv2Jpeg:0</span><br><span class="line"> CamX    (  834): [<span class="string"> WARN</span>][<span class="symbol">JPEG   </span>] camxjpegswencnode.cpp:1577 CancelRequest() Flush called on requestId: 1, m<span class="emphasis">_currRequestId: 1, Main img engine ref: 0xb4000070d461c828</span></span><br><span class="line"><span class="emphasis"> CamX    (  834): [<span class="string"> WARN</span>][<span class="symbol">JPEG   </span>] camxjpegswencnode.cpp:1584 CancelRequest() Calling abort on main img encode, m_</span>bAbortCalledOnMain: 1</span><br></pre></td></tr></table></figure>

<p>当PCR处理时，如果一个node处理超时或者异常，这会直接影响与其有依赖关系的node, 则会对所处pipeline的处理造成延迟甚至堵塞。之后flush处理，需要对在PCR处理的session进行结果等待，这种情况属于isSessionFlush，如果在设置的时间阀值处理超时后，则需要对还在运行的pipeline进行处理。但无论是何种方面造成的延迟，通过时间阀数timeout来进行判定，理论上我们不允许等待时间太长。</p>
<hr>
<h2 id="超时处理流程"><a href="#超时处理流程" class="headerlink" title="超时处理流程"></a>超时处理流程</h2><p>下图是一个大体的超时处理流程，基于SessionFlush</p>
<p><img src="/images/Camx-Control-Stream/flush-sessionWaittime.png" alt="alt"></p>
<p>camx的事务处理都是通过session来进行管理的，无论是session， pipeline， node都有一个timeout来进行判定是否处理超时。</p>
<h3 id="session-pipeline处理"><a href="#session-pipeline处理" class="headerlink" title="session-pipeline处理"></a>session-pipeline处理</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">//Func(<span class="name">selfWaitTillAllResultsAvailablecall</span>)</span><br><span class="line">sessionWaittime =Min( <span class="name">Max</span>(<span class="name">pipeline1Waittime</span>, pipeline2Waittime)+paddingtime, maxWaitTime )</span><br></pre></td></tr></table></figure>

<p>maxWaitTime 为camxsetting.xml中配置，为sessionMaxFlushWaitTime，默认设置为500ms<br>paddingtime    为camxsetting.xml中配置，为sessionResponseTimePadding，默认设置为50ms，用来描述pipeline除了PCR处理之外的其他动作用时。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">paddingTime = Utils::<span class="constructor">MaxUINT64(<span class="params">paddingTime</span>, <span class="params">paddingTime</span><span class="operator">*</span><span class="params">m_livePendingRequests</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><font color=#2196F3 >pipeline waittime为这条pipeline上 正在运行的node的最大reposeTime</font></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">result</span> = m_pWaitAllResultsAvailable-&gt;</span>T<span class="function"><span class="title">imedWait</span>(m_pWaitForResultsLock-&gt;</span>GetNativeHandle(), waitTime);</span><br></pre></td></tr></table></figure>

<p>下面是一些node的等待时间设置</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">Jpeg <span class="keyword">node</span><span class="title">为</span></span><br><span class="line"><span class="title">static</span> const UINT32 MaxDefaultFlushResponseTime     = <span class="number">450</span>; //default = <span class="number">300</span>           ///Default flush repsonse time (<span class="keyword">in</span> milliseconds)</span><br><span class="line"></span><br><span class="line">custom <span class="keyword">node</span><span class="title">为通过以下方式获取</span></span><br><span class="line"><span class="title">m_nodeCallbacks</span>.pGetFlushResponse(&amp;nodeResponse<span class="literal">Inf</span>o);</span><br><span class="line">在camxchinodeswmfnr.cpp节点中设置为：</span><br><span class="line">static const UINT32 MaxDefaultFlushResponseTime   = <span class="number">2000</span>;        ///<span class="tag">&lt; Default flush</span></span><br><span class="line"><span class="tag">repsonse time (in milliseconds)</span></span><br></pre></td></tr></table></figure>

<p>高通对其他节点有默认值为5ms<br>custom node中并出了关于responseTimeInMillisec的详细描述：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">// Each node needs <span class="built_in">to</span> publish <span class="keyword">a</span> response <span class="built_in">time</span> (<span class="built_in">milliseconds</span>) <span class="keyword">for</span> how <span class="keyword">long</span> <span class="keyword">it</span> takes <span class="built_in">to</span></span><br><span class="line">     <span class="comment"> // stop processing requests after flush call.</span></span><br><span class="line">     <span class="comment"> // During flush, session will consider this reponse time and will wait for nodes to flush gracefully.</span></span><br><span class="line">     <span class="comment"> // This response time can be computed dynamically based on the type of the node,</span></span><br><span class="line">     <span class="comment"> // otherwise default reponse time can be used.</span></span><br></pre></td></tr></table></figure>

<p>如果在sessionWaittime 之后还是没有获取到AllResult,则实际上还设置了100ms的额外等待时间sessionFallbackWaitTimemcamxsetting.xml中配置,为100ms。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">//Func(<span class="name">FallbackFlush</span>)</span><br><span class="line">result = waitCondition-&gt;TimedWait(<span class="name">m_pWaitForResultsLock-&gt;GetNativeHandle</span>(), fallbackWaitTime)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>如果这种情况下，还是没有处理完成（即存在pipeline的状态为STREAM_ON）,针对这种状态情况下的pipeline进行FlushPendingNodes操作</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (<span class="attribute">PipelineStatus</span>::STREAM_ON == m_pipelineData[pipelineIndex].pPipeline-&gt;GetPipelineStatus())</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="selector-tag">m_pipelineData</span><span class="selector-attr">[pipelineIndex]</span><span class="selector-class">.pPipeline-</span>&gt;<span class="selector-tag">FlushPendingNodes</span>();                                                                                                                                      </span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>

<p>这个时候已经认为超出了平台的忍耐，需要进行node flush处理。针对全部未处理完毕的request下的node，如果当前node处于Setup和Runing状态下的node进行flush。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">else</span> <span class="selector-tag">if</span> (<span class="attribute">PerRequestNodeStatus</span>::Setup == requestStatus || <span class="attribute">PerRequestNodeStatus</span>::Running == requestStatus)</span><br><span class="line">              &#123;    </span><br><span class="line">                  <span class="selector-tag">m_ppNodes</span><span class="selector-attr">[index]</span><span class="selector-tag">-</span>&gt;<span class="selector-tag">Flush</span>(requestId);                                                                                                                                                                </span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
<p>在node处理完毕，如果还有未处理完的pipeline,再通过100ms的超时来继续检查。</p>
<h3 id="node处理"><a href="#node处理" class="headerlink" title="node处理"></a>node处理</h3><p>node的flush包含如下处理：</p>
<ul>
<li>CancelRequest(requestId); 针对实现该操作的node, 比如<font color=#2196F3 >jpeg</font>， 有jpegswencnode(不同于custom node,继承于node类)，会对算法jpeg engine进行abort处理。没有实现的,比如<font color=#2196F3 >eis</font>，继续执行ChiNodeWrapper的实现，即等待RequestWaitTime，默认为5s，如果在这5s内，该node节点的ExecuteProcessRequest流程执行完毕，则允许m_pRequestProgress-&gt;<font color=#2196F3 >Broadcast</font>()来唤醒线程。如果超时，在raiserecoverysigabrt（camxsettings.xml ）配置为true的情况下，则会主动触发Abort信号。</li>
<li>.CSLFenceSignal通知fences失败处理。</li>
</ul>
<h2 id="Condition处理"><a href="#Condition处理" class="headerlink" title="Condition处理"></a>Condition处理</h2><p>关于相关的Condition处理： </p>
<ol>
<li>m_pWaitAllResultsAvailable   在NotifyProcessingDone通过m_pWaitAllResultsAvailable-&gt;Signal()唤醒，此时应该所有node都处理完毕，live pending requests为0。当然这要求有新的inject触发<br>线程ProcessResults处理，并在AdvanceMinExpectedResult处理中所有的result都返回的情况下使得canAdvance 为TRUE，从而进入NotifyProcessingDone流程。<font color=#2196F3 >这里发现一个相当有用的点，camxsettings.xml开启enableFPSLog能探测平均帧率CalculateResultFPS</font>。<br>这里的唤醒为<font color=#2196F3 >Signal</font>，使用pthread_cond_signal(&amp;m_conditionVar)来唤醒阻塞的指定线程。</li>
<li>FallbackFlush 因为isSessionFlush为TRUE，其实等待的唤醒同1.即为m_pWaitAllResultsAvailable，这里其实return是正常返回的。100ms超时</li>
<li>CancelRequest custom node处理。m_pRequestProgress-&gt;TimedWait 超时5s,需要ExecuteProcessRequest处理完毕之后进行<font color=#2196F3 >Broadcast</font>唤醒。通过pthread_cond_broadcast(&amp;m_conditionVar)来唤醒相关的阻塞线程，为啥需要唤醒多个线程，原因未知。5s超时</li>
<li>同2.</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>feature也存在timeout超时</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">m_maxFeatureExecutionTime</span> = CalculateMaxFeatureExecutionTime()<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>flush</tag>
      </tags>
  </entry>
  <entry>
    <title>单&amp;双摄configure stream流程</title>
    <url>/archives/8a2ade15.html</url>
    <content><![CDATA[<h1 id="单-amp-双摄configure-stream流程"><a href="#单-amp-双摄configure-stream流程" class="headerlink" title="单&amp;双摄configure stream流程"></a>单&amp;双摄configure stream流程</h1><ul>
<li>advance/feature2</li>
<li>hal3 callback chi</li>
<li>单摄usecase初始化处理</li>
<li>双摄usecase初始化处理</li>
</ul>
<h2 id="advance-feature2"><a href="#advance-feature2" class="headerlink" title="advance/feature2"></a>advance/feature2</h2><p>为什么起名为advance(提前)，代码架构直观可以发现一部分pipeline和node在FGM的pipeline和node之前创建。因此整个configure_stream大体上其实可以分为两个流程。<br>1.在SelectUsecaseConfig之后直接通过CameraUsecaseBase::Initialize去CreatePipeline的部分，这部分属于advance<br>2.PostUsecaseCreation去创建FGM,FGS,拿到FGD map,创建FPM，拿到全部feature instance的cap.之后对需要的每一个feature instance去initizlize,configure，最终创建pipeline，状态机成为Finalized.  </p>
<p>因此，把advance/feature2这部分放在首节，本文只针对advance 和 usecasemc部分描述，尽量不涉及feature部分</p>
<h2 id="hal3-callback-chi"><a href="#hal3-callback-chi" class="headerlink" title="hal3 callback chi"></a>hal3 callback chi</h2><p>configure_stream 和process_capture_request 都是framework下发，通过hal3处理，callback chi。process_capture_results则是由camx node 在PCR处理中主动callback.<br>process_capture_request 和 process_capture_result见双摄预览控制流程详解。</p>
<p>configure_stream入口为camxhal3entry.cpp,通过pHAL3-&gt;configure_streams进入hal3处理，hal3中调用pHALDevice-&gt;ConfigureStreams，在HALDevice::ConfigureStreams中主要进行三个处理.</p>
<a id="more"></a> 

<p>1.CheckValidStreamConfig 来判断framework下发的stream size和格式是否合规，在VTS测试中，就有测试size = MAX_INT这种情况测试。</p>
<p>2.chi_teardown_override_session  在CHIModuleInitialize前，应该释chi control 控制。</p>
<p>3.CHIModuleInitializ e进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pCHIAppCallbacks-&gt;chi_initialize_override_session(GetCameraId(),</span><br><span class="line">                                                  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">camera3_device_t</span>*&gt;(&amp;m_camera3Device),</span><br><span class="line">                                                  &amp;m_HALCallbacks,</span><br><span class="line">                                                  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">camera3_stream_configuration_t</span>*&gt;(pStreamConfigs),</span><br><span class="line">                                                  &amp;isOverrideEnabled,</span><br><span class="line">                                                  &amp;pPrivateData);</span><br></pre></td></tr></table></figure>

<p>chi_initialize_override_session则是通过调用com.qti.override.so中的chi_hal_override_entry函数赋值，此处不再赘述。详见双摄预览控制流程详解</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensioninterface.cpps</span></span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_initialize_override_session  = chi_initialize_override_session;</span><br></pre></td></tr></table></figure>

<p>故camx callback chi_initialize_override_session.通过pExtensionModule-&gt;InitializeOverrideSession进入ExtensionModule::InitializeOverrideSession。</p>
<p>在InitializeOverrideSession主要进行以下处理：</p>
<p>1.GetMatchingUsecase（）判断numPhysicalCameras&amp;&amp;num_streams获取到对应UsecaseId::MultiCamera.</p>
<p>2.通过CreateUsecaseObject来进行usecase的创建.通过pUsecaseMultiCamera-&gt;Initialize进行初始化,至此，才开始双摄usecase的处理</p>
<h3 id="单摄usecase初始化处理"><a href="#单摄usecase初始化处理" class="headerlink" title="单摄usecase初始化处理"></a>单摄usecase初始化处理</h3><p><img src="/images/Camx-Control-Stream/configure_stream.png" alt="alt"></p>
<ol>
<li>初始化处理，包括target stream的判定和sensorIndexMode的获取， feature的初始化</li>
<li>针对每一条pipeline，设置对应的notify和result callback，方便pipeline对应的PCR处理完毕之后回调metadata/result和notify消息</li>
<li>CameraUsecaseBase::Initialize  通过ExtensionModules调用CreatePipelineDescriptor在camx通过Pipeline::Create创建pipeline,之后通过CreateNodes创建各node并进行初始化</li>
</ol>
<hr>
<h3 id="双摄usecase初始化处理"><a href="#双摄usecase初始化处理" class="headerlink" title="双摄usecase初始化处理"></a>双摄usecase初始化处理</h3><p>UsecaseMultiCamera::Initialize中</p>
<p>1.ClassifyTargetStream 针对下发的stream,根据流格式进行不同类型的流空间申请。</p>
<p>2.通过SelectUsecaseXML匹配到usecaseMap中的usecase XML，通过PruneUsecaseByStreamConfig对对应的pipeline 拓扑进行处理</p>
<p>3.CreateMultiCameraResource对每个摄像头的OutputSnapshotStream 和CreateMultiCameraResource等资源进行空间申请</p>
<p>4.CreateRDIResources 调用FindBestSensorMode获取对应的modeIndex等和CreateBufferManagers对MultiCameraResource的管理</p>
<p>5.CreatePipelines创建pipeline,CreateMetadataManager创建metadata</p>
<p>6.InitializeAdvanceFeatures 进行父类AdvanceCameraUsecase的初始化。双摄的feature设置为feature2 wrapper 0x40（单摄流程在CreateUsecaseObject会直接执行AdvanceCameraUsecase的初始化）</p>
<p>7.CreateSession 创建 REALTIME_SESSION session,针对拍照数据流，进行OfflineRequestThread线程处理</p>
<p>8.CreateMultiController来管理设备（比如在MultiRTBController::Create 中获取双摄参数配置等）</p>
<hr>
]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>configure_stream</tag>
      </tags>
  </entry>
  <entry>
    <title>单&amp;双摄预览控制流详解</title>
    <url>/archives/8a2ade14.html</url>
    <content><![CDATA[<h1 id="单-amp-双摄预览控制流详解"><a href="#单-amp-双摄预览控制流详解" class="headerlink" title="单&amp;双摄预览控制流详解"></a>单&amp;双摄预览控制流详解</h1><ul>
<li> Request从hal3到chi</li>
<li> chi端request双摄处理流程</li>
<li> camx端request双摄处理流程</li>
<li> Result返回</li>
</ul>
<hr>
<p>下图是PCR下发在hal3，chi，camx之间的简单流程(需要重新check双摄usecase和advance,Feature的关系，图中并不包括文中描述的Result返回部分)<br><img src="/images/Camx-Control-Stream/PCR-hal-chi-camx.png" alt="alt"></p>
<hr>
<h2 id="Request从hal3到chi"><a href="#Request从hal3到chi" class="headerlink" title="Request从hal3到chi"></a>Request从hal3到chi</h2><html>
camxhal3.cpp中的g_jumpTableHAL3是framework与hal3的接口，对函数指针接口进行赋值，其中的configure_streams和process_capture_request分别是进行配流和预览时进行调用的。

<a id="more"></a> 

<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">//camxhal3.cpp </span><br><span class="line">JumpTableHAL3 g_jumpTableHAL3 =</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">    open,</span></span><br><span class="line"><span class="built_in">    get_number_of_cameras,</span></span><br><span class="line"><span class="built_in">    get_camera_info,</span></span><br><span class="line"><span class="built_in">    set_callbacks,</span></span><br><span class="line"><span class="built_in">    get_vendor_tag_ops,</span></span><br><span class="line"><span class="built_in">    open_legacy,</span></span><br><span class="line"><span class="built_in">    set_torch_mode,</span></span><br><span class="line"><span class="built_in">    init,</span></span><br><span class="line"><span class="built_in">    get_tag_count,</span></span><br><span class="line"><span class="built_in">    get_all_tags,</span></span><br><span class="line"><span class="built_in">    get_section_name,</span></span><br><span class="line"><span class="built_in">    get_tag_name,</span></span><br><span class="line"><span class="built_in">    get_tag_type,</span></span><br><span class="line"><span class="built_in">    close,</span></span><br><span class="line"><span class="built_in">    initialize,</span></span><br><span class="line"><span class="built_in">    configure_streams,</span>//配流</span><br><span class="line"><span class="built_in">    construct_default_request_settings,</span></span><br><span class="line"><span class="built_in">    process_capture_request,</span>//预览request中使用</span><br><span class="line"><span class="built_in">    dump,</span></span><br><span class="line"><span class="built_in">    flush,</span></span><br><span class="line"><span class="built_in">    camera_device_status_change,</span></span><br><span class="line"><span class="built_in">    torch_mode_status_change,</span></span><br><span class="line"><span class="built_in">    process_capture_result,</span></span><br><span class="line">    notify</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>目前针对process_capture_request流程进行分析。entry调用pHAL3-&gt;process_capture_request， 然后hal3中process_capture_request中调用pHALDevice-&gt;ProcessCaptureRequest(pRequest)，进入camxhaldevice.cpp。<br>在ProcessCaptureRequest中进行chi callback</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhaldevice.cpp  </span></span><br><span class="line">CamxResult HALDevice<span class="type">::ProcessCaptureRequest</span>(  </span><br><span class="line"><span class="params">...</span></span><br><span class="line">    result = GetCHIAppCallbacks()-&gt;chi_override_process_request  <span class="comment">//</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里获取到一个chi_hal_callback_ops_t实例，这是一个chi callback的结构体，对其函数指针chi_override_process_request进行调用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhaldevice.cpp </span></span><br><span class="line">CAMX_INLINE chi_hal_callback_ops_t* HALDevice::GetCHIAppCallbacks() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (HAL3Module::GetInstance()-&gt;GetCHIAppCallbacks());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而实例中chi_override_process_request函数指针的赋值为读取chi库中的chi_hal_override_entry指针地址来进行调用赋值。这里LibMap和LibGetAddr是我们之后经常会见到的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhal3module.cpp</span></span><br><span class="line">...</span><br><span class="line">                CAMX_LOG_INFO(CamxLogGroupHAL, <span class="string">&quot;opening CHI Module - %s&quot;</span>, &amp;moduleFileName[fileIndex]);</span><br><span class="line">                m_hChiOverrideModuleHandle = OsUtils::LibMap(&amp;moduleFileName[fileIndex]);<span class="comment">//打开com.qti.override.so库</span></span><br><span class="line">...</span><br><span class="line">           <span class="keyword">if</span> (<span class="literal">NULL</span> != m_hChiOverrideModuleHandle)</span><br><span class="line">            &#123;</span><br><span class="line">                CHIHALOverrideEntry funcCHIHALOverrideEntry =</span><br><span class="line">                    <span class="keyword">reinterpret_cast</span>&lt;CHIHALOverrideEntry&gt;(</span><br><span class="line">                        CamX::OsUtils::LibGetAddr(m_hChiOverrideModuleHandle, <span class="string">&quot;chi_hal_override_entry&quot;</span>));<span class="comment">//获取chi_hal_override_entry地址</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != funcCHIHALOverrideEntry)</span><br><span class="line">                &#123;</span><br><span class="line">                    funcCHIHALOverrideEntry(&amp;m_ChiAppCallbacks);<span class="comment">//chi这边调用进行函数指针赋值</span></span><br></pre></td></tr></table></figure>

<p>chi 端通过chi_hal_override_entry 进行函数指针赋值</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensioninterface.cpp</span></span><br><span class="line">void chi_hal_override_entry(</span><br><span class="line">    chi_hal_callback_ops_t* callbacks)</span><br><span class="line">&#123;</span><br><span class="line">    ExtensionModule* pExtensionModule = ExtensionModule::GetInstance();</span><br><span class="line"></span><br><span class="line">    CHX_ASSERT(NULL != callbacks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NULL != pExtensionModule)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_get_num_cameras              = chi_get_num_cameras;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_get_camera_info              = chi_get_camera_info;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_get_info                     = chi_get_info;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_initialize_override_session  = chi_initialize_override_session;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_finalize_override_session    = chi_finalize_override_session;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_override_process_request     = chi_override_process_request;<span class="comment">//Request callback 赋值</span></span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_teardown_override_session    = chi_teardown_override_session;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_extend_open                  = chi_extend_open;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_extend_close                 = chi_extend_close;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_remap_camera_id              = chi_remap_camera_id;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_modify_settings              = chi_modify_settings;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_get_default_request_settings = chi_get_default_request_settings;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_override_flush               = chi_override_flush;</span><br><span class="line">        <span class="function"><span class="title">callbacks</span>-&gt;</span>chi_override_dump                = chi_override_dump;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，hal3端对request的callback调用其实是调用chi端的chi_override_process_request<br>以下为chi端的Request处理流程</p>
</html>

<hr>
<h2 id="chi端request双摄处理流程"><a href="#chi端request双摄处理流程" class="headerlink" title="chi端request双摄处理流程"></a>chi端request双摄处理流程</h2><html>
在OverrideProcessRequest处理中，通过双摄cameraid对应的usecase实例指针，进行ProcessCaptureRequest方法调用。

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensionmodule.cpp</span></span><br><span class="line">result = m_pSelectedUsecase<span class="literal">[<span class="identifier">logicalCameraId</span>]</span>-&gt;<span class="constructor">ProcessCaptureRequest(<span class="params">pCaptureRequest</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>而双摄usecase实例指针在CreateUsecaseObject中获取，这个在之前双摄configure_stream中创建。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">m_pSelectedUsecase<span class="literal">[<span class="identifier">logicalCameraId</span>]</span> = m_pUsecaseFactory-&gt;<span class="constructor">CreateUsecaseObject(&amp;<span class="params">m_logicalCameraInfo</span>[<span class="params">logicalCameraId</span>],<span class="params">selectedUsecaseId</span>，StreamConfig)</span>;</span><br></pre></td></tr></table></figure>

<p>这里将一个UsecaseMultiCamera* 赋值给Usecase* </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxusecaseutils.cpp</span></span><br><span class="line">pUsecase = UsecaseMultiCamera::<span class="constructor">Create(<span class="params">pLogicalCameraInfo</span>, <span class="params">pStreamConfig</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>要注意，UsecaseMultiCamera其实是Usecase的子类，所以这里可以赋值。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">U<span class="function"><span class="title">secase</span> --&gt;</span>CameraUsecaseBase</span><br><span class="line">C<span class="function"><span class="title">ameraUsecaseBase</span>--&gt;</span>AdvancedCameraUsecase</span><br><span class="line">A<span class="function"><span class="title">dvancedCameraUsecase</span>--&gt;</span> UsecaseMultiCamera</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxadvancedcamerausecase.h </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraUsecaseBase</span> :</span> <span class="keyword">public</span> Usecase  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdvancedCameraUsecase</span> :</span> <span class="keyword">public</span> CameraUsecaseBase</span><br><span class="line"><span class="comment">//chxusecasemc.h </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsecaseMultiCamera</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> AdvancedCameraUsecase</span><br></pre></td></tr></table></figure>

<p>之后在ProcessCaptureRequest 中进行ExecuteCaptureRequest调用时，其实是UsecaseMultiCamera下的方法调用，单摄是在AdvancedCameraUsecase中处理。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>chxusecase.cpp </span><br><span class="line">  result = ExecuteCaptureRequest(pRequest);<span class="regexp">//</span> 这里详细讲述控制流，不针对 ProcessCaptureRequest下的buffer和pRequest-&gt;settings（Metadata）做处理解释。</span><br></pre></td></tr></table></figure>

<p>在ExecuteCaptureRequest便是针对不同情况，进行buffer copy和GenerateRealtimeRequest调用</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxusecasemc.cpp</span></span><br><span class="line"> result = <span class="constructor">GenerateRealtimeRequest(&amp;<span class="params">request</span>, NULL)</span>; </span><br></pre></td></tr></table></figure>

<p>GenerateRealtimeRequest主要做了两件事，第一件进行processSessionRequest，第二件为ActivatePendingPipeline。在<br>processSessionRequest进行submitRequest，在ActivatePendingPipeline中进行activepipeline.</p>
<ul>
<li>submitRequeste</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxusecase.cpp</span></span><br><span class="line">    <span class="keyword">if</span> (IsFlushing != GetFlushStatus())</span><br><span class="line">    &#123;</span><br><span class="line">        result = ExtensionModule::GetInstance()-&gt;SubmitRequest(pSubmitRequestData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//chxextensionmodule.cpp</span></span><br><span class="line">CDKResult ExtensionModule::SubmitRequest(</span><br><span class="line">    CHIPIPELINEREQUEST* pSubmitRequest)</span><br><span class="line">&#123;</span><br><span class="line">    CDKResult result = CDKResultSuccess;</span><br><span class="line"></span><br><span class="line">    result = g_chiContextOps.pSubmitPipelineRequest(m_hCHIContext, pSubmitRequest);<span class="comment">//camx调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>activepipeline</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensionmodule.cpp</span></span><br><span class="line"><span class="function">CDKResult <span class="title">ExtensionModule::ActivatePipeline</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">    CHIHANDLE             sessionHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">    CHIPIPELINEDESCRIPTOR pipelineHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_chiContextOps.pActivatePipeline(m_hCHIContext, sessionHandle, pipelineHandle, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而g_chiContextOps函数指针的的赋值，则全部来自于camera.qcom.so中ChiEntry函数的调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OSLIBRARYHANDLE handle  = ChxUtils::LibMap(pChiDriver);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != handle)</span><br><span class="line">&#123;</span><br><span class="line">    m_libraryHandle = handle;</span><br><span class="line">    CHX_LOG(<span class="string">&quot;CHI Opened driver library&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PCHIENTRY funcPChiEntry = <span class="keyword">reinterpret_cast</span>&lt;PCHIENTRY&gt;(ChxUtils::LibGetAddr(handle, <span class="string">&quot;ChiEntry&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != funcPChiEntry)</span><br><span class="line">    &#123;</span><br><span class="line">        CHX_LOG(<span class="string">&quot;CHI obtained ChiEntry point function&quot;</span>);</span><br><span class="line"></span><br><span class="line">        funcPChiEntry(&amp;g_chiContextOps);</span><br></pre></td></tr></table></figure>

<p>在camxchi.cpp中赋值如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxchi.cpp</span></span><br><span class="line">    pChiContextOps-&gt;pSubmitPipelineRequest     = CamX::ChiSubmitPipelineRequest;</span><br><span class="line">    pChiContextOps-&gt;pActivatePipeline          = CamX::ChiActivatePipeline;</span><br></pre></td></tr></table></figure>
</html>

<p>其实SubmitRequest和ActivatePipeline主要做了两件事session streamon 和 session ProcessCaptureRequest处理</p>
<hr>
<h2 id="camx端request双摄处理流程"><a href="#camx端request双摄处理流程" class="headerlink" title="camx端request双摄处理流程"></a>camx端request双摄处理流程</h2><html>
在ChiContext::SubmitRequest中，首先通过CheckValidInputRequest检查各个request的input ChiStreamBuffer， Validate output ChiStreamBuffer，InputMetadata，OutputMetadata是否有效。之后通过pSession->StreamOn和pSession->ProcessCaptureRequest进行pipeline初始化处理和PCR处理。

<p>在ChiContext::ActivatePipeline中，  其实也是进行session streamon。</p>
<h3 id="Session-streamon处理（FinalizeDeferPipeline-pipeline-streamon）"><a href="#Session-streamon处理（FinalizeDeferPipeline-pipeline-streamon）" class="headerlink" title="Session streamon处理（FinalizeDeferPipeline+ pipeline streamon）"></a>Session streamon处理（FinalizeDeferPipeline+ pipeline streamon）</h3><h4 id="session-streamon"><a href="#session-streamon" class="headerlink" title="session streamon"></a>session streamon</h4><p>主要处理如下：如果pipeline没有初始化完成，调用FinalizeDeferPipeline去完成初始化，之后再进行pipeline streamon.</p>
<p>FinalizeDeferPipeline主要包括以下处理：</p>
<ul>
<li>FinalizeInitialization完成node的初始化</li>
<li>CreateBufferManagers调用ImageBufferManager来完成node相关port buffer的创建。</li>
<li>NotifyPipelineCreated调用<font color=#2196F3 >PostPipelineCreate</font> 来进行node的延迟处理。比如eis node会完成eis lib的初始化。</li>
<li>WaitForDeferPipelineCreate等待PostPipelineCreate单线程处理完毕再FilterAndUpdatePublishSet来进行，通过GetMetadataPublishList来获取<font color=#2196F3 >custom node的metadata list</font> .比如nodeWrapper.</li>
</ul>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">CamxResult ChiNodeWrapper::QueryMetadataPublishList(</span><br><span class="line">    NodeMetadataList* pPublistTagList)</span><br><span class="line">&#123;</span><br><span class="line">    CamxResult <span class="attr">result</span> = CamxResultSuccess;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">NULL</span> == pPublistTagList)</span><br><span class="line">    &#123;</span><br><span class="line">        CAMX_LOG_ERROR(CamxLogGroupMeta, <span class="string">&quot;Node::%s pPublistTagList NULL&quot;</span>, NodeIdentifierString());</span><br><span class="line">        <span class="attr">result</span> = CamxResultEInvalidArg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">NULL</span> == m_nodeCallbacks.pQueryMetadataPublishList)</span><br><span class="line">    &#123;</span><br><span class="line">        pPublistTagList-&gt;<span class="attr">tagCount</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ChiNodeMetadataList chiMetadataList;</span><br><span class="line"></span><br><span class="line">        chiMetadataList.<span class="attr">hNodeSession</span> = m_hNodeSession;</span><br><span class="line">        chiMetadataList.<span class="attr">size</span>         = sizeof(ChiNodeMetadataList);</span><br><span class="line"></span><br><span class="line">        <span class="attr">result</span> = m_nodeCallbacks.pQueryMetadataPublishList(&amp;chiMetadataList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="attr">CamxResultSuccess</span> == result) &amp;&amp; (<span class="number">0</span> &lt; chiMetadataList.tagCount))</span><br><span class="line">        &#123;</span><br><span class="line">            pPublistTagList-&gt;<span class="attr">tagCount</span>        = chiMetadataList.tagCount;</span><br><span class="line">            pPublistTagList-&gt;<span class="attr">partialTagCount</span> = chiMetadataList.partialTagCount;</span><br><span class="line">            Utils::Memcpy(pPublistTagList-&gt;tagArray, chiMetadataList.tagArray,</span><br><span class="line">                          chiMetadataList.tagCount * sizeof(UINT32));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PrepareStreamOn 进行node streamon之前的相关配置，比如IFE node，完成IFEdsp的相关配置。比如sensor node 通过PrepareSensorUpdate完成参数曝光配置。<font color=#2196F3 >pipeline状态设置为FINALIZED</font>。</li>
</ul>
<h4 id="pipeline-streamon"><a href="#pipeline-streamon" class="headerlink" title="pipeline streamon"></a>pipeline streamon</h4><p>主要进行如下处理：</p>
<ul>
<li>CallNodeAcquireResources 调用AcquireResources进一步完成streamon前的配置，比如在sensor node中，完成当前sensor resolution setting的sensor寄存器写入和CSI的相关配置。全部node处理完毕，<font color=#2196F3 >pipeline状态设置为RESOURCES_ACQUIRED</font>。</li>
<li>通过StreamOn调用CSLStreamOn，CSLHwStreamOnKMDHardwares进一步调用deviceOp.StreamOn来完成node对应设备的启动。pipeline状态设置为<font color=#2196F3 >PipelineStatus::STREAM_ON</font></li>
<li>各node通过nNodeStreamOn调用AllocateBuffers完成buffer的申请和custom node callback的 pOnStreamOn调用。</li>
</ul>
</html>


<h3 id="pSession-gt-ProcessCaptureRequest处理"><a href="#pSession-gt-ProcessCaptureRequest处理" class="headerlink" title="pSession-&gt;ProcessCaptureRequest处理"></a>pSession-&gt;ProcessCaptureRequest处理</h3><p>在Session::ProcessCaptureRequest中，最重要的便是通过PostJob方法将capture request加入到线程中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//camxsession.cpp</span></span><br><span class="line">                <span class="string">VOID*</span> <span class="string">pData[]</span> <span class="string">=</span> &#123;<span class="string">this</span>, <span class="literal">NULL</span>&#125;<span class="string">;</span></span><br><span class="line">                <span class="string">result</span>        <span class="string">=</span> <span class="string">m_pThreadManager-&gt;PostJob(m_hJobFamilyHandle,</span></span><br><span class="line">                                                          <span class="literal">NULL</span><span class="string">,</span></span><br><span class="line">                                                          <span class="string">&amp;pData[0],</span></span><br><span class="line">                                                          <span class="literal">FALSE</span><span class="string">,</span></span><br><span class="line">                                                          <span class="literal">FALSE</span><span class="string">);</span></span><br></pre></td></tr></table></figure>

<p>在configure_stream早期，已经CHISession::Initialize队列中通过m_pThreadManager-&gt;RegisterJobFamily注册了该线程对应的处理函数。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxchisession.cpp</span></span><br><span class="line">        result = m_pThreadManager-&gt;RegisterJobFamily(ThreadJobCallback,</span><br><span class="line">                                                     wrapperName,</span><br><span class="line">                                                     <span class="built_in">NULL</span>,</span><br><span class="line">                                                     JobPriority<span class="type">::Normal</span>,</span><br><span class="line">                                                     <span class="literal">TRUE</span>,</span><br><span class="line">                                                     &amp;m_hJobFamilyHandle);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JobRegistry::RegisterNewJob过程中，将m_hJobFamilyHandle赋值并与TheadJobCallback绑定。</span></span><br><span class="line"><span class="comment">//camxthreadjobregistry.cpp</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line">        pRegisteredJob-&gt;funcAddr        = jobFuncAddr;</span><br><span class="line"><span class="params">...</span></span><br><span class="line">        *phJob = PackJobHandleFromRegisteredJob(pRegisteredJob);</span><br><span class="line">        pRegisteredJob-&gt;hRegister = *phJob;</span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure>

<p>线程触发ThreadJobCallback去处理此次的job.ThreadJobCallback调用ThreadJobExecute，进行ProcessResults和ProcessRequest处理，在第一帧request处理时，由于没有NotifyResult处理过CbType,类似Buffer,EarlyMetadata,Metadata，故直接进行ProcessRequest处理。</p>
<p>ProcessRequest处理逻辑是依次session, pipeline, node处理。</p>
<h4 id="Session-ProcessRequest处理"><a href="#Session-ProcessRequest处理" class="headerlink" title="Session::ProcessRequest处理"></a>Session::ProcessRequest处理</h4><p>在Session::ProcessRequest()处理中，调用OpenRequest去进行预期曝光时间下发，但是如果第一帧(request0)PCR不是在pipeline streamon的状态下,则不进行CSLOpenRequest 下发预期曝光时间处理。通过对SessionRequest素组遍历来处理对应CaptureRequest对应pipeline的PCR. SetupRequestData获取到需要的pipelineProcessRequestData数据后，进行ProcessRequest(&amp;pipelineProcessRequestData)处理。</p>
<h4 id="Pipeline-ProcessRequest处理"><a href="#Pipeline-ProcessRequest处理" class="headerlink" title="Pipeline::ProcessRequest处理"></a>Pipeline::ProcessRequest处理</h4><ul>
<li>首先调用CallNodeAcquireResources()将一个不是acquired状态的pipeline设置为acquired状态，<font color=#2196F3 >在之前pipeline streamon()已经调用过此接口函数，并将pipeline置为RESOURCES_ACQUIRED</font></li>
<li>之后对此次request中的stream里用到的node的进行SetupRequest处理，SetupRequestOutputPorts &amp;&amp; SetupRequestInputPorts 设置input 和 output端口。//todo </li>
</ul>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxnode.cpp</span></span><br><span class="line">    <span class="variable"><span class="keyword">if</span></span> (<span class="variable"><span class="literal">TRUE</span></span> == <span class="function"><span class="title">IsNodeEnabled</span>())</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable"><span class="class">result</span></span> = <span class="function"><span class="title">SetupRequestOutputPorts</span>(<span class="variable">pPerBatchedFrameInfo</span>);<span class="comment">//之后调用CSLFenceCallback去更新依赖性（NonSinkPort）或者调用m_pSession-&gt;NotifyResult(SinkPort/pipeline上的最后一个node)</span></span></span><br><span class="line"><span class="function">        <span class="variable"><span class="class">result</span></span> = <span class="title">SetupRequestInputPorts</span>(<span class="variable">pPerBatchedFrameInfo</span>);</span></span><br><span class="line"><span class="function">        *<span class="variable">pIsNodeEnabled</span> = <span class="variable"><span class="literal">TRUE</span></span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>AddDeferredNode </li>
</ul>
<ol>
<li>将所有非pipeline flush状态的node加入到DeferredRequestQueue管理的m_readyNodes队列。因为刚开始此时 全部的node其实未经过PCR处理，Property &amp;&amp; buffer &amp;&amp; chiFence dependency等依赖性未检查&amp;&amp;pDependencyUnit 为NULL</li>
<li>对node property &amp;&amp; buffer &amp;&amp; chi fence 进行依赖检查并添加</li>
</ol>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span> ((0 == pDependency-&gt;</span>propertyCount) &amp;&amp;</span><br><span class="line">    (<span class="number">0</span> == <span class="function"><span class="title">pDependency</span>-&gt;</span>fenceCount)    &amp;&amp;</span><br><span class="line">    (<span class="number">0</span> == <span class="function"><span class="title">pDependency</span>-&gt;</span>chiFenceCount))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Node doesn&#x27;t have any dependencies so it should be ready.</span></span><br><span class="line">    <span class="function"><span class="title">m_pReadyQueueLock</span>-&gt;</span>Lock();</span><br><span class="line">    m_readyNodes.InsertToTail(pNode);</span><br><span class="line">    <span class="function"><span class="title">m_pReadyQueueLock</span>-&gt;</span>Unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    m_deferredNodes.InsertToTail(pNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>DispatchReadyNodes</li>
</ul>
<ol>
<li>延迟node链表处理。对于满足要求的deferredNode list中的node，进行依赖dependency移除并通过UpdateOrRemoveDependency将property &amp;&amp;fence(buffer)&amp;&amp;chi fence 都满足的node从deferredNode list移动到readyNodes.如果不满足移动要求，则继续deferredNode list的下一个node dependency更新处理</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// Move the node to the ready queue</span></span><br><span class="line">    LightweightDoublyLinkedListNode* pDeferred = m_deferredNodes.<span class="constructor">FindByValue(<span class="params">pDependency</span>)</span>;</span><br><span class="line">    m_deferredNodes.<span class="constructor">RemoveNode(<span class="params">pDeferred</span>)</span>;</span><br><span class="line"></span><br><span class="line">    m_pReadyQueueLock-&gt;<span class="constructor">Lock()</span>;</span><br><span class="line">    m_readyNodes.<span class="constructor">InsertToTail(<span class="params">pDeferred</span>)</span>;</span><br><span class="line">    m_pReadyQueueLock-&gt;<span class="constructor">Unlock()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>对所有readyNodes中的结点通过PostJob进行DeferredWorkerWrapper处理，并移除readyNodes链表。PostJob会触发线程管理函数DeferredWorkerWrapper，注册在 DeferredRequestQueue::Initialize初始化阶段。</li>
</ol>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxdeferredrequestqueue.cpp</span></span><br><span class="line">CamxResult DeferredRequestQueue<span class="type">::Initialize</span>（</span><br><span class="line"><span class="params">...</span></span><br><span class="line"></span><br><span class="line">    result = m_pThreadManager-&gt;RegisterJobFamily(DeferredWorkerWrapper,</span><br><span class="line">                                                 wrapperName,</span><br><span class="line">                                                 <span class="built_in">NULL</span>,</span><br><span class="line">                                                 JobPriority<span class="type">::Normal</span>,</span><br><span class="line">                                                 <span class="literal">FALSE</span>,</span><br><span class="line">                                                 &amp;m_hDeferredWorker);     </span><br></pre></td></tr></table></figure>

<p>而DeferredWorkerWrapper调用DeferredWorkerCore，进行node的ProcessRequest处理。</p>
<p>在Node::ProcessRequest处理中，通过BindInputOutputBuffers将backing buffer与node的 input , output buffer绑定.</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//camxnode.cpp</span><br><span class="line">        // <span class="keyword">If</span> LateBinding <span class="keyword">is</span> enabled, <span class="keyword">input</span> <span class="keyword">and</span> output ImageBuffers may <span class="keyword">not</span> have backing <span class="keyword">buffers</span> yet.</span><br><span class="line">        // <span class="keyword">If</span> derived nodes <span class="keyword">set</span> needBuffersOnDependencyMet <span class="keyword">for</span> this sequenceId, that means, derived</span><br><span class="line">        // node <span class="keyword">is</span> going <span class="keyword">to</span> <span class="keyword">access</span> <span class="keyword">input</span>, output <span class="keyword">buffers</span> now. Lets bind <span class="keyword">buffers</span> <span class="keyword">to</span> ImageBuffers <span class="keyword">if</span> <span class="keyword">not</span> yet.</span><br><span class="line">            result = BindInputOutputBuffers(executeProcessData.pEnabledPortsInfo, <span class="keyword">TRUE</span>, <span class="keyword">TRUE</span>);</span><br></pre></td></tr></table></figure>

<p>之后再执行各个node实例中的ExecuteProcessRequest，在ChiNodeWrapper::ExecuteProcessRequest中进行buffer传递到chibuffer之后，进行m_nodeCallbacks.pProcessRequest(&amp;info)调用获取结果(custom node 调用不再详述)，并更新metadata.</p>
<p>node处理结束之后，PostJob调用进行ProcessFenceCallback处理.分为NonSink和Sink两种处理。NonSink（NonSinkPortFenceSignaled）调用UpdateDependency更新依赖，然后通过DisPatchReadyNodes继续处理。而sinkPort（SinkPortFenceSignaled）则通过m_pSission-&gt;NotifyResult向framework返回处理结果。</p>
<hr>
<h2 id="Result返回"><a href="#Result返回" class="headerlink" title="Result返回"></a>Result返回</h2><h3 id="camx-callback-return-chi-（ChiProcessPartialCaptureResult-callback）"><a href="#camx-callback-return-chi-（ChiProcessPartialCaptureResult-callback）" class="headerlink" title="camx callback return chi （ChiProcessPartialCaptureResult callback）"></a>camx callback return chi （ChiProcessPartialCaptureResult callback）</h3><p>在全部的node 的metadata或者sink Port的buffer处理完毕，我们就需要从node回调，经pipeline，session回调，最终将需要的数据capture result通过m_chiCallBacks(ChiProcessPartialCaptureResult/ChiProcessCaptureResult)返回给chi.</p>
<p>camx也需要通过m_chiCallBacks.ChiNotify进行SOF或者SHUTTER,ERROR通知。(ChiNotify)</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chi-cdk/api/common/chi.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ChiCallBacks</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/// @brief CHI app callback method to send back the capture results</span></span><br><span class="line">    <span class="keyword">void</span> (*ChiProcessCaptureResult)(</span><br><span class="line">        CHICAPTURERESULT*   pCaptureResult,</span><br><span class="line">        VOID*               pPrivateCallbackData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief Asynchronous notification callback method</span></span><br><span class="line">    <span class="keyword">void</span> (*ChiNotify)(</span><br><span class="line">        <span class="keyword">const</span> CHIMESSAGEDESCRIPTOR* pMessageDescriptor,</span><br><span class="line">        VOID*                       pPrivateCallbackData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief CHI app callback method to send back the partial capture results</span></span><br><span class="line">    <span class="keyword">void</span> (*ChiProcessPartialCaptureResult)(</span><br><span class="line">         CHIPARTIALCAPTURERESULT*   pCaptureResult,</span><br><span class="line">         VOID*                      pPrivateCallbackData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; CHICALLBACKS;</span><br></pre></td></tr></table></figure>
<p>回调实例m_chiCallBacks赋值在Session::Initialize。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxsession.cpp</span></span><br><span class="line">Utils::<span class="constructor">Memcpy(&amp;<span class="params">m_chiCallBacks</span>, <span class="params">pCreateData</span>-&gt;<span class="params">pChiAppCallBacks</span>, <span class="params">sizeof</span>(ChiCallBacks)</span>);</span><br></pre></td></tr></table></figure>

<p>pChiAppCallBacks为ChiContext::CreateSession中的ChiCallBacks*    pCallbacks参数，通过CHISession::Create传递到Session::Initialize中。</p>
<p>此时可以发现（ChiCreateSession）CreateSession为chi callback camx时使用的，同之前提到过得ChiActivatePipeline.</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">pChiContextOps-&gt;pCreateSession             = CamX::ChiCreateSession;</span><br></pre></td></tr></table></figure>

<p>在chi端为ExtensionModule::CreateSession调用进行callback, 在configure stream流程中已经研究过，Session::Create调用pSession-&gt;Initialize，进一步CreateSession。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">m_hSession</span> = ExtensionModule::GetInstance()-&gt;CreateSession(&amp;sessionCreateData)<span class="comment">; </span></span><br></pre></td></tr></table></figure>

<p>在双摄usecase初始化时，会进行预览session的创建。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>chxusecasemc.cpp</span><br><span class="line">CreateSession(REALTIME_SESSION);</span><br></pre></td></tr></table></figure>

<p>在这里，才是真正m_chiCallBacks赋值的参数，在camx ChiProcessPartialCaptureResult回调时，其实调用的是上层的SessionCbPartialCaptureResult</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">CDKResult UsecaseMultiCamera::CreateSession(</span><br><span class="line">    UINT32 sessionId)&#123;</span><br><span class="line">    <span class="comment">//camx真正的回调</span></span><br><span class="line">    callbacks.ChiNotify                       = SessionCbNotifyMessage;</span><br><span class="line">    callbacks.ChiProcessCaptureResult         = SessionCbCaptureResult;</span><br><span class="line">    callbacks.ChiProcessPartialCaptureResult  = SessionCbPartialCaptureResult;</span><br><span class="line">            m_sessionInfo[sessionId].m_pSession = Session::Create(pPipelines,</span><br><span class="line">                                                              numOfPipelines,</span><br><span class="line">                                                              <span class="variable">&amp;callbacks</span>,</span><br><span class="line">                                                              <span class="variable">&amp;</span>m_sessionInfo[sessionId].m_privateData); </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在SessionCbPartialCaptureResult处理中，针对双摄预览REALTIME_SESSION，进行ProcessDriverPartialCaptureResult处理，通过ProcessAndReturnPartialMetadataFinishedResults中的Usecase::ReturnFrameworkResult调用，ExtensionModule::GetInstance()-&gt;ReturnFrameworkResult(pResult, cameraID);返回到hal3中处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensionmodule.cpp</span></span><br><span class="line"><span class="function">VOID <span class="title">ExtensionModule::ReturnFrameworkResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">camera3_capture_result_t</span>* pResult,</span></span></span><br><span class="line"><span class="function"><span class="params">    UINT32 cameraID)</span></span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     m_HALOps[cameraID].process_capture_result(m_logicalCameraInfo[cameraID].m_pCamera3Device, pResult);</span><br><span class="line">     ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="process-capture-result-amp-amp-notify-chi-hal3-hook"><a href="#process-capture-result-amp-amp-notify-chi-hal3-hook" class="headerlink" title="process_capture_result &amp;&amp; notify   chi-hal3 hook"></a>process_capture_result &amp;&amp; notify   chi-hal3 hook</h3><p>该函数指针的赋值在ExtensionModule::SetHALOps中赋值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chxextensionmodule.cpp</span></span><br><span class="line"><span class="keyword">VOID</span> ExtensionModule::SetHALOps(</span><br><span class="line">    uint32_t             logicalCameraId,</span><br><span class="line">    <span class="keyword">const</span> chi_hal_ops_t* pHalOps)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pHalOps)</span><br><span class="line">    &#123;</span><br><span class="line">        m_HALOps[logicalCameraId].process_capture_result = pHalOps-&gt;process_capture_result;                                                                                          m_HALOps[logicalCameraId].notify_result = pHalOps-&gt;notify_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ExtensionModule::InitializeOverrideSession中进行了SetHALOps(logicalCameraId, chiHalOps);</p>
<p>最终发现，为camx callback进行了函数指针赋值。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">callbacks</span>-&gt;</span>chi_initialize_override_session  = chi_initialize_override_session;</span><br></pre></td></tr></table></figure>
<p>在HALDevice::CHIModuleInitialize中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxpipeline.cpp</span></span><br><span class="line">        pCHIAppCallbacks-&gt;chi_initialize_override_session(GetCameraId(),</span><br><span class="line">                                                          <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">camera3_device_t</span>*&gt;(&amp;m_camera3Device),</span><br><span class="line">                                                          &amp;m_HALCallbacks,</span><br><span class="line">                                                          <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">camera3_stream_configuration_t</span>*&gt;(pStreamConfigs),</span><br><span class="line">                                                          &amp;isOverrideEnabled,</span><br><span class="line">                                                          &amp;pPrivateData);</span><br></pre></td></tr></table></figure>
<p>hal和chi的hook之前已经描述过，这里不再详述<br>在HALDevice::Initialize时，将函数指针赋值，然后通过pCHIAppCallbacks-&gt;chi_initialize_override_session将chi_hal_ops回调给到m_HALOps，供ExtensionModule回调</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//camxhaldevice.cpp</span><br><span class="line">        m_HALCallbacks.process_capture_result = ProcessCaptureResult<span class="comment">;</span></span><br><span class="line">        m_HALCallbacks.notify_result          = Notify<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>ProcessCaptureResult时(result最终返回处理)，最终进行以下处理</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhaldevice.cpp</span></span><br><span class="line">        <span class="function"><span class="title">pHALDevice</span>-&gt;</span>UpdateFrameworkRequestBufferResult(pCamera3CaptureResult, pFrameworkRequest);</span><br><span class="line">        <span class="function"><span class="title">pHALDevice</span>-&gt;</span>G<span class="function"><span class="title">etCallbackOps</span>()-&gt;</span><span class="function"><span class="title">process_capture_result</span>(pHALDevice-&gt;</span>GetCallbackOps(), pCamera3_CaptureResult); <span class="comment">//最终为camxhal3.cpp下的process_capture_result调用</span></span><br></pre></td></tr></table></figure>
<p>pHALDevice-&gt;GetCallbackOps()获取到m_pCamera3CbOps，则它是在hal3 initialize是进行pHALDevice-&gt;SetCallbackOps(pCamera3CbOpsAPI) 设置的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhaldevice.h</span></span><br><span class="line">    <span class="function">CAMX_INLINE VOID <span class="title">SetCallbackOps</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">camera3_callback_ops_t</span>* pCamera3CbOps)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pCamera3CbOps = pCamera3CbOps;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而hal3 initialize是通过entry initialize来调用的，调用前设置了参数</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhal3entry.cpp</span></span><br><span class="line">    <span class="keyword">if</span> (NULL != pCamera3CbOps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">pCamera3CbOps</span>-&gt;</span>cbOps.process_capture_result = process_cpature_result;</span><br><span class="line">        <span class="function"><span class="title">pCamera3CbOps</span>-&gt;</span>cbOps.notify = notify;</span><br><span class="line">        <span class="function"><span class="title">pCamera3CbOps</span>-&gt;</span>pCamera3Device = pCamera3DeviceAPI;</span><br><span class="line">        <span class="function"><span class="title">pCamera3CbOps</span>-&gt;</span>pCbOpsAPI = pCamera3CbOpsAPI;</span><br><span class="line">        <span class="function"><span class="title">pCamera3CbOpsAPI</span> = &amp;(pCamera3CbOps-&gt;</span>cbOps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">g_HAL3Entry</span>.m_pCbOpsLock-&gt;</span>Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">return</span> pHAL3-&gt;</span>initialize(pCamera3DeviceAPI, pCamera3CbOpsAPI);</span><br></pre></td></tr></table></figure>

<p>则函数则指向entry下的process_capture_result。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhal3entry.cpp</span></span><br><span class="line"></span><br><span class="line">    pHAL3-&gt;process<span class="constructor">_capture_result(<span class="params">pCamera3CbOps</span>-&gt;<span class="params">pCbOpsAPI</span>, <span class="params">pCaptureResultAPI</span>)</span>; </span><br><span class="line">    <span class="comment">//上面等价于--&gt;     hal3中的process_capture_result(entry initialize时的参数camera3_callback_ops_t*，并非 pCamera3CbOpsAPI = &amp;(pCamera3CbOps-&gt;cbOps)处理过后的)</span></span><br></pre></td></tr></table></figure>

<p>hal3中的process_capture_result实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxhal3.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_capture_result</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">struct</span> camera3_callback_ops*  pCamera3CbOpsAPI,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> camera3_capture_result_t*     pCaptureResultAPI</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">pCamera3CbOpsAPI-&gt;process_capture_result(pCamera3CbOpsAPI, pCaptureResultAPI); <span class="comment">//简化代码，方便理解</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>而entry初始化时的参数camera3_callback_ops_t* 则是用来回调framework.</p>
<h3 id="双摄request-camx端处理"><a href="#双摄request-camx端处理" class="headerlink" title="双摄request camx端处理"></a>双摄request camx端处理</h3><p>一个request的处理分为大致两类，一类为result处理，一类为notify处理。</p>
<h4 id="result处理"><a href="#result处理" class="headerlink" title="result处理"></a>result处理</h4><p>result处理中PartialMetadata和Metadata处理类似，一旦node处理Metadata完成调用，将该node对应request的MetadataComplete标记为1，同时CamxAtomicIncU将request对应numNodesMetadataDone的技术+1，当全部完成时，通过pipeline，session依次回调到NotifyResult。</p>
<p>NotifyResult不光处理result，同时还会对Error,Async,SOF等通过DispatchNotify进行 m_chiCallBacks.ChiNotify调用。<br>针对PartialMetadata，通过DispatchPartialMetadata进行m_chiCallBacks.ChiProcessPartialCaptureResult调用。比如双摄情况下就会回调到UsecaseMultiCamera下的SessionCbNotifyMessage和SessionCbPartialCaptureResult;</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxchisession.cpp</span></span><br><span class="line">m_chiCallBacks.<span class="constructor">ChiProcessPartialCaptureResult(<span class="params">pPartialCaptureResult</span>, <span class="params">m_pPrivateCbData</span>)</span>; </span><br></pre></td></tr></table></figure>

<p>而Metadata和buffer的处理都是通过InjectResult来处理的，故回调都是双摄下的SessionCbCaptureResult，不同于PartialMetadata。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxsession.cpp</span></span><br><span class="line"> <span class="constructor">InjectResult(ResultType::MetadataOK, &amp;<span class="params">pPayload</span>-&gt;<span class="params">metaPayload</span>, <span class="params">pPayload</span>-&gt;<span class="params">sequenceId</span>, <span class="params">pPrivData</span>, <span class="params">pipelineIndex</span>)</span>; </span><br></pre></td></tr></table></figure>

<p>在InjectResult处理中，除了MetaBuffer缓冲区的填充，重要的还有为此次的request 触发对应的result.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxsession.cpp</span></span><br><span class="line">        ...</span><br><span class="line">        MetadataPayload* pMetaPayload = <span class="keyword">static_cast</span>&lt;MetadataPayload*&gt;(pPayload);</span><br><span class="line"></span><br><span class="line">        pHolder-&gt;pMetaBuffer[<span class="number">0</span>] = pMetaPayload-&gt;pMetaBuffer[<span class="number">0</span>];</span><br><span class="line">        pHolder-&gt;pMetaBuffer[<span class="number">1</span>] = pMetaPayload-&gt;pMetaBuffer[<span class="number">1</span>];</span><br><span class="line">        ...</span><br><span class="line">        CamxAtomicStore32(&amp;m_aCheckResults, TRUE);<span class="comment">//允许session ProcessResult</span></span><br><span class="line">        ...</span><br><span class="line">        result        = m_pThreadManager-&gt;PostJob(m_hJobFamilyHandle, <span class="literal">NULL</span>, &amp;pData[<span class="number">0</span>], FALSE, FALSE);</span><br></pre></td></tr></table></figure>

<p>正如我们之前讲到的触发线程处理ThreadJobExecute</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxchisession.cpp</span></span><br><span class="line">    <span class="keyword">while</span> (TRUE == <span class="keyword">static_cast</span>&lt;BOOL&gt;(CamxAtomicLoad32(&amp;m_aCheckResults)))&gt;&gt;InjectResult触发设置m_aCheckResults为<span class="literal">true</span>，触发ProcessResults处理调用</span><br><span class="line">    &#123;</span><br><span class="line">        CamxAtomicStore32(&amp;m_aCheckResults, FALSE);</span><br><span class="line">        result = ProcessResults();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在ProcessResults处理中，我们通过DispatchResults调用m_chiCallBacks.ChiProcessCaptureResult将所有的results返回给Framework</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camxsession.cpp</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; numResults)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Finally dispatch all the results to the Framework</span></span><br><span class="line">        <span class="constructor">DispatchResults(&amp;<span class="params">m_pCaptureResult</span>[0], <span class="params">numResults</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Camera-Driver</category>
      </categories>
      <tags>
        <tag>Camera-Camx</tag>
        <tag>PCR</tag>
      </tags>
  </entry>
</search>
