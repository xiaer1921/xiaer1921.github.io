<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/sholck2.jfif"><link rel="icon" type="image/png" sizes="32x32" href="/images/sholck2.jfif"><link rel="icon" type="image/png" sizes="16x16" href="/images/sholck2.jfif"><link rel="mask-icon" href="/images/sholck2.jfif" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"sholck.top",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"right",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="模块接口分析模块编译在代码编译前宏展开时，需要进行条件编译，这需要gcc指定参数，而指定什么参数由Makefile来控制.trace.c在编译时gcc中的参数中会带有 -D__KERNEL__, -DMODULE， -D__KBUILD_MODNAME&#x3D;kmod_trace， 可以参考linux-likely学习，这用在之后的宏展开。"><meta property="og:type" content="article"><meta property="og:title" content="linux模块初始化分析"><meta property="og:url" content="http://sholck.top/archives/17.html"><meta property="og:site_name" content="Sholck"><meta property="og:description" content="模块接口分析模块编译在代码编译前宏展开时，需要进行条件编译，这需要gcc指定参数，而指定什么参数由Makefile来控制.trace.c在编译时gcc中的参数中会带有 -D__KERNEL__, -DMODULE， -D__KBUILD_MODNAME&#x3D;kmod_trace， 可以参考linux-likely学习，这用在之后的宏展开。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-04-26T16:00:00.000Z"><meta property="article:modified_time" content="2022-04-29T09:47:56.797Z"><meta property="article:author" content="Sholck"><meta property="article:tag" content="gdb"><meta property="article:tag" content="objcopy"><meta property="article:tag" content="内核编译"><meta property="article:tag" content="__used__"><meta property="article:tag" content="__section__"><meta property="article:tag" content="链接脚本"><meta property="article:tag" content="vmlinux.lds"><meta property="article:tag" content="宏扩展"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://sholck.top/archives/17.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>linux模块初始化分析 | Sholck</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Sholck" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Sholck</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">不积跬步,无以至千里.不积小流,无以成江海</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">59</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a></li><li class="menu-item menu-item-project"><a href="/project/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>项目</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://sholck.top/archives/17.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Sholck"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sholck"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">linux模块初始化分析</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-04-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-27T00:00:00+08:00">2022-04-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-04-29 17:47:56" itemprop="dateModified" datetime="2022-04-29T17:47:56+08:00">2022-04-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>27k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>25 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="模块接口分析"><a href="#模块接口分析" class="headerlink" title="模块接口分析"></a>模块接口分析</h2><h3 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h3><p>在代码编译前宏展开时，需要进行条件编译，这需要gcc指定参数，而指定什么参数由Makefile来控制.<br>trace.c在编译时gcc中的参数中会带有 -D__KERNEL__, -DMODULE， -D__KBUILD_MODNAME=kmod_trace， 可以参考<a href="https://sholck.top/archives/13.html">linux-likely学习</a>，这用在之后的宏展开。</p><a id="more"></a><h3 id="模块入口"><a href="#模块入口" class="headerlink" title="模块入口"></a>模块入口</h3><p>不同的模块根据要求和实现有着不同的初始化顺序，内核模块的入口在<code>include/linux/init.h</code>中定义</p><details><summary>内核模块入口</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pure_initcall(fn)               __define_initcall(fn, 0)    </span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall(fn)               __define_initcall(fn, 1)    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall_sync(fn)          __define_initcall(fn, 1s)                                                                                                                                                   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall(fn)           __define_initcall(fn, 2)    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall_sync(fn)      __define_initcall(fn, 2s)    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall(fn)               __define_initcall(fn, 3)     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall_sync(fn)          __define_initcall(fn, 3s)    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall(fn)             __define_initcall(fn, 4)     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall_sync(fn)        __define_initcall(fn, 4s)    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall(fn)                 __define_initcall(fn, 5)     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall_sync(fn)            __define_initcall(fn, 5s)    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rootfs_initcall(fn)             __define_initcall(fn, rootfs)    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall(fn)             __define_initcall(fn, 6)         </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall_sync(fn)        __define_initcall(fn, 6s)    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall(fn)               __define_initcall(fn, 7)     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall_sync(fn)          __define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure></details><p>动态模块的入口为<code>include/linux/module.h</code>中定义，因为在编译模块时会使用gcc指令，其中会包含-DMODULE，因此相当于走<code>#ifdef MODULE</code></p><details><summary>动态模块入口</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> early_initcall(fn)              module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall(fn)               module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall_sync(fn)          module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall(fn)           module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall_sync(fn)      module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall(fn)               module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall(fn)             module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall_sync(fn)        module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall(fn)                 module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall_sync(fn)            module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rootfs_initcall(fn)             module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall(fn)             module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall_sync(fn)        module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall(fn)               module_init(fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall_sync(fn)          module_init(fn)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> console_initcall(fn)            module_init(fn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each module must use one module_init(). */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_init(initfn)                                     \</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">initcall_t</span> __maybe_unused __inittest(<span class="keyword">void</span>)                \</span><br><span class="line">        &#123; <span class="keyword">return</span> initfn; &#125;                                      \</span><br><span class="line">        int init_module(void) __copy(initfn)                    \</span><br><span class="line">                __attribute__((alias(<span class="meta">#initfn)));                \</span></span><br><span class="line">        __CFI_ADDRESSABLE(init_module, __initdata);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is only required if you want to be unloadable. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_exit(exitfn)                                     \</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">exitcall_t</span> __maybe_unused __exittest(<span class="keyword">void</span>)                \</span><br><span class="line">        &#123; <span class="keyword">return</span> exitfn; &#125;                                      \</span><br><span class="line">        <span class="keyword">void</span> cleanup_module(<span class="keyword">void</span>) __copy(exitfn)                \</span><br><span class="line">                __attribute__((alias(<span class="meta">#exitfn)));                \</span></span><br><span class="line">        __CFI_ADDRESSABLE(cleanup_module, __exitdata);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="入口扩展"><a href="#入口扩展" class="headerlink" title="入口扩展"></a>入口扩展</h3><p>内核模块入口扩展开是什么样的，比如<code>fs_initcall(fn)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall(fn)                 __define_initcall(fn, 5)</span></span><br></pre></td></tr></table></figure><p>fs_initcall(tracer_init_tracefs)最后通过宏扩展为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">initcall_t</span>   __initcall__kmod_trace__397_9768_tracer_init_tracefs5  __attribute__((__used__))  __attribute__((__section__(<span class="string">&quot;.initcall5.init&quot;</span>))) = tracer_init_tracefs; </span><br></pre></td></tr></table></figure><p>扩展过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">fs_initcall(tracer_init_tracefs);</span><br><span class="line">__define_initcall(tracer_init_tracefs, <span class="number">5</span>)</span><br><span class="line">___define_initcall(tracer_init_tracefs, <span class="number">5</span>, .initcal5)</span><br><span class="line">__unique_initcall(tracer_init_tracefs, <span class="number">5</span>, .initcal5, __initcall_id(fn))</span><br><span class="line"><span class="comment">//-D__KBUILD_MODNAME=kmod_trace在编译时指定  </span></span><br><span class="line"><span class="comment">//__COUNTER__ 为预定义宏 调用计数器，每次调用都会+1</span></span><br><span class="line"><span class="comment">// ___LINE__ 为预定义宏 ,代码在文件多少行</span></span><br><span class="line"></span><br><span class="line">因为_unique_initcall的定义还有宏，那么此时的__unique_initcall 参数进行一次扩展再替换</span><br><span class="line">__unique_initcall(tracer_init_tracefs, <span class="number">5</span>, .initcal5, __kmod_trace__397_9768_tracer_init_tracefs)</span><br><span class="line"></span><br><span class="line">继续扩展</span><br><span class="line">____define_initcall(tracer_init_tracefs，                                                           \</span><br><span class="line">         __initcall_stub(tracer_init_tracefs, __kmod_trace__397_9768_tracer_init_tracefs, <span class="number">5</span>),       \</span><br><span class="line">         __initcall_name(initcall, __kmod_trace__397_9768_tracer_init_tracefs, <span class="number">5</span>),                  \</span><br><span class="line">         __initcall_section(.initcall5.init,  __kmod_trace__397_9768_tracer_init_tracefs))</span><br><span class="line"></span><br><span class="line">因为____define_initcall的定义还有宏，那么此时的____define_initcall 参数进行一次扩展再替换</span><br><span class="line"></span><br><span class="line">____define_initcall(tracer_init_tracefs，                                                           \</span><br><span class="line">         tracer_init_tracefs,                                     \</span><br><span class="line">         __initcall__kmod_trace__397_9768_tracer_init_tracefs5,                                     \</span><br><span class="line">         .initcall5.init</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为init.h包含#include &lt;linux/compiler.h&gt;， 而compiler.h包含 #include &lt;linux/compiler_types.h&gt;,gcc编译中包含了-D__KERNEL__,因此包含#include &lt;linux/compiler_attributes.h&gt;，故__used被定义为如下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __used                          __attribute__((__used__))</span></span><br><span class="line"></span><br><span class="line">则最后扩展为</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">initcall_t</span>   __initcall__kmod_trace__397_9768_tracer_init_tracefs5  __attribute__((__used__))  __attribute__((__section__(<span class="string">&quot;.initcall5.init&quot;</span>))) = tracer_init_tracefs; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>宏扩展规则：</p><ol><li>如果宏定义中有宏，则会先进行一次扩展，即参数的宏进行展开，之后进行替换 比如 #define Tag test; #define EXP(a, b) _EXP(a,b); 则EXP(Tag, First)首先扩展为_EXP(test, First)</li><li>如果宏定义中没有宏，则直接替换 #define _EXP(a,b) a##b, 则_EXP(test, First) 扩展为testFirst</li></ol><p>注意如下, 扩展出来类似为<code>.initcall5.init</code>, 不是<code>.initcall5 .init</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __initcall_section(__sec, __iid)                        \    </span></span><br><span class="line">        #__sec <span class="string">&quot;.init&quot;</span>  </span><br></pre></td></tr></table></figure><p>关于<strong>COUNTER</strong> ,见<a target="_blank" rel="noopener external nofollow noreferrer" href="https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html">Common Predefined Macros</a>，相当于计数器<br>关于<strong>attribute</strong>((<strong>used</strong>))，见 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#index-used-variable-attribute">gcc 对used变量描述</a>和<a target="_blank" rel="noopener external nofollow noreferrer" href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-used-function-attribute">gcc 对used函数描述</a></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unused &gt;&gt;可能不使用，不用警告</span><br><span class="line">This attribute, attached <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">variable</span> <span class="keyword">or</span> structure field, means that <span class="keyword">the</span> <span class="built_in">variable</span> <span class="keyword">or</span> field is meant <span class="built_in">to</span> be possibly unused. GCC does <span class="keyword">not</span> produce <span class="keyword">a</span> warning <span class="keyword">for</span> this <span class="built_in">variable</span> <span class="keyword">or</span> field.</span><br><span class="line"></span><br><span class="line">used &gt;&gt;作用与静态变量</span><br><span class="line">This attribute, attached <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">variable</span> <span class="keyword">with</span> static storage, means that <span class="keyword">the</span> <span class="built_in">variable</span> must be emitted even <span class="keyword">if</span> <span class="keyword">it</span> appears that <span class="keyword">the</span> <span class="built_in">variable</span> is <span class="keyword">not</span> referenced.</span><br><span class="line"></span><br><span class="line">When applied <span class="built_in">to</span> <span class="keyword">a</span> static data member <span class="keyword">of</span> <span class="keyword">a</span> C++ class template, <span class="keyword">the</span> attribute also means that <span class="keyword">the</span> member is instantiated <span class="keyword">if</span> <span class="keyword">the</span> class itself is instantiated.</span><br></pre></td></tr></table></figure><p>unused: 实践发现在静态变量中，如果一个变量没有使用，会进行未使用提示，但是普通的全局变量则不会，可以通过<strong>attribute</strong>((<strong>unused</strong>))来消除警告，_attribute__((<strong>used</strong>))也可以消除<br>used：如果静态变量如果没有使用，但是目标文件依旧做保留，可以通过section查看</p><details><summary>unused测试</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>  test_var = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">make编译提示：</span><br><span class="line">/github/linux-driver/<span class="number">2</span>-likely/likely.c:<span class="number">12</span>:<span class="number">15</span>: 警告：‘test_var’ defined but <span class="keyword">not</span> used [-Wunused-variable]</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span>   test_var = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Makefile中增加EXTRA_CFLAGS = -Wall -g -W，开启警告提示更多</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __attribute__((__unused__))  test_var;则无任何test_var 的提示</span><br></pre></td></tr></table></figure></details><details><summary>used测试</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>  test_var = <span class="number">1</span>; &gt;&gt;正常为data section下的，但是因为没有被使用过，所以目标文件中不存在</span><br><span class="line"></span><br><span class="line">objdump -t likely.o | grep -n <span class="string">&quot;test_var&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __attribute__((__used__))  test_var = <span class="number">1</span>; &gt;&gt;目标文件保留</span><br><span class="line"></span><br><span class="line">➜  <span class="number">2</span>-likely git:(master) ✗ objdump -t likely.o | grep -n <span class="string">&quot;test_var&quot;</span></span><br><span class="line"><span class="number">32</span>:<span class="number">0000000000000000</span> l     O .data       <span class="number">0000000000000004</span> test_var  &gt;&gt;目标文件保留test_var<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">指定所在section</span></span><br><span class="line"><span class="string">static int  test_var __used __section(&quot;</span>.section_test<span class="string">&quot;) = 1;或者</span></span><br><span class="line"><span class="string">static int  test_var __attribute__((__used__)) __attribute__((__section__(&quot;</span>.section_test<span class="string">&quot;))) = 1;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">➜  2-likely git:(master) ✗ objdump -t likely.o | grep -n &quot;</span>test_var<span class="string">&quot;</span></span><br><span class="line"><span class="string">33:0000000000000000 l     O .section_test       0000000000000004 test_var  &gt;&gt;可以看到test_var保留在.section_test</span></span><br></pre></td></tr></table></figure></details><details><summary>__COUNTER__测试</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_count(fn) \</span></span><br><span class="line">        <span class="keyword">int</span> fn = __COUNTER__</span><br><span class="line"></span><br><span class="line">test_count(a);</span><br><span class="line">test_count(b);</span><br><span class="line">test_count(c);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test is %d\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test is %d\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test is %d\n&quot;</span>, c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test is <span class="number">0</span></span><br><span class="line">test is <span class="number">1</span></span><br><span class="line">test is <span class="number">2</span></span><br></pre></td></tr></table></figure></details><h3 id="扩展分析"><a href="#扩展分析" class="headerlink" title="扩展分析"></a>扩展分析</h3><p>扩展结果为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">initcall_t</span>   __initcall__kmod_trace__397_9768_tracer_init_tracefs5  __attribute__((__used__))  __attribute__((__section__(<span class="string">&quot;.initcall5.init&quot;</span>))) = tracer_init_tracefs; </span><br></pre></td></tr></table></figure><p>initcall_t 定义为一个普通的函数指针类型，这里申明了<br><code>__initcall__kmod_trace__397_9768_tracer_init_tracefs5</code>这个函数指针变量，指向函数tracer_init_tracefs，section为.initcall5.init， 即使没有被引用过，也在目标文件做保留</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  linux git:(master) ✗ objdump -t kernel/trace/trace.o | grep -n <span class="string">&quot;tracer_init_tracefs&quot;</span></span><br><span class="line"><span class="number">120</span>:<span class="number">0000000000000000</span> l       .initcall5.init    <span class="number">0000000000000000</span> __initcall__kmod_trace__397_9768_tracer_init_tracefs5</span><br><span class="line"><span class="number">121</span>:<span class="number">0000000000000581</span> l     F .init.text <span class="number">00000000000002b</span>4 tracer_init_tracefs    &gt;&gt;__init导致  <span class="meta">#<span class="meta-keyword">define</span> __init          __section(<span class="meta-string">&quot;.init.text&quot;</span>) __cold  __latent_entropy __noinitretpoline __nocfi</span></span><br><span class="line"><span class="number">426</span>:<span class="number">0000000000000010</span> l     O .discard.addressable       <span class="number">0000000000000008</span> __UNIQUE_ID___addressable_tracer_init_tracefs398</span><br></pre></td></tr></table></figure><p>section可以理解为内存中一块连续的区域，因此section 为.initcall5.init中的函数在内核中地址是连续的，可以查看symbol，比如System.map</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ffffffff82ebb71c T __initcall5_start         &gt;&gt;section  .initcall5 内存开始</span><br><span class="line">ffffffff82ebb71c t __initcall__kmod_nmi__312_102_nmi_warning_debugfs5       </span><br><span class="line">ffffffff82ebb720 t __initcall__kmod_microcode__275_891_save_microcode_in_initrd5       </span><br><span class="line">ffffffff82ebb724 t __initcall__kmod_hpet__211_1165_hpet_late_init5       </span><br><span class="line">ffffffff82ebb728 t __initcall__kmod_amd_nb__276_507_init_amd_nbs5       </span><br><span class="line">ffffffff82ebb72c t __initcall__kmod_resource__294_1914_iomem_init_inode5       </span><br><span class="line">ffffffff82ebb730 t __initcall__kmod_clocksource__211_1038_clocksource_done_booting5       </span><br><span class="line">ffffffff82ebb734 t __initcall__kmod_trace__397_9768_tracer_init_tracefs5   &gt;&gt;__initcall__kmod_trace__397_9768_tracer_init_tracefs5 内存地址</span><br><span class="line"></span><br><span class="line">ffffffff82d5e986 t tracer_init_tracefs </span><br></pre></td></tr></table></figure><p>也可以通过gdb 倒入vmlinux查看符号表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info address __initcall__kmod_trace__397_9768_tracer_init_tracefs5</span><br><span class="line">Symbol <span class="string">&quot;__initcall__kmod_trace__397_9768_tracer_init_tracefs5&quot;</span> is at <span class="number">0xffffffff82ebb734</span> in a file compiled without debugging.</span><br><span class="line">(gdb) info symbol <span class="number">0xffffffff82ebb734</span></span><br><span class="line">__initcall__kmod_trace__397_9768_tracer_init_tracefs5 in section .init.data  &gt;&gt;奇怪？为什么在vmlinux中是.init.data section，而不是本身的.initcall5.init</span><br><span class="line"></span><br><span class="line">(gdb) info address tracer_init_tracefs</span><br><span class="line">Symbol <span class="string">&quot;tracer_init_tracefs&quot;</span> is a function at address <span class="number">0xffffffff82d5e986</span>.</span><br><span class="line">(gdb) info symbol tracer_init_tracefs</span><br><span class="line">tracer_init_tracefs in section .init.text</span><br><span class="line">(gdb) info symbol <span class="number">0xffffffff82d5e986</span></span><br><span class="line">tracer_init_tracefs in section .init.text</span><br><span class="line"></span><br><span class="line">➜  linux git:(master) ✗ objdump -t vmlinux  | grep -n <span class="string">&quot;tracer_init_tracefs&quot;</span></span><br><span class="line"><span class="number">18786</span>:ffffffff82ebb734 l       .init.data       <span class="number">0000000000000000</span> __initcall__kmod_trace__397_9768_tracer_init_tracefs5 &gt;&gt;为什么变成.init.data呢？</span><br><span class="line"><span class="number">18787</span>:ffffffff82d5e986 l     F .init.text       <span class="number">00000000000002b</span>4 tracer_init_tracefs</span><br><span class="line"></span><br><span class="line">&gt;&gt;但是vmlinux.o还是正常的</span><br><span class="line">➜  linux git:(master) ✗ objdump -t vmlinux.o  | grep -n <span class="string">&quot;tracer_init_tracefs&quot;</span></span><br><span class="line"><span class="number">32887</span>:<span class="number">0000000000000018</span> l       .initcall5.init  <span class="number">0000000000000000</span> __initcall__kmod_trace__397_9768_tracer_init_tracefs5</span><br><span class="line"><span class="number">32888</span>:<span class="number">000000000002e986</span> l     F .init.text       <span class="number">00000000000002b</span>4 tracer_init_tracefs</span><br><span class="line"><span class="number">33178</span>:<span class="number">0000000000004</span>c28 l     O .discard.addressable     <span class="number">0000000000000008</span> __UNIQUE_ID___addressable_tracer_init_tracefs398</span><br></pre></td></tr></table></figure><p>发现一个问题，即vmlinux中的<code>__initcall__kmod_trace__397_9768_tracer_init_tracefs5</code> section 变为.init.data</p><p>检查vmlinux,既然作为一个not stripped 的ELF文件，肯定是带有section的，通过ojbdump解析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  linux git:(master) ✗ objdump -h vmlinux</span><br><span class="line">vmlinux：     文件格式 elf64-x86<span class="number">-64</span>    </span><br><span class="line">    </span><br><span class="line">节：    </span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn    </span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00e020</span>e0  ffffffff81000000  <span class="number">0000000001000000</span>  <span class="number">00200000</span>  <span class="number">2</span>**<span class="number">12</span>    </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE   </span><br><span class="line"> <span class="number">19</span> .init.text    <span class="number">0006</span>c870  ffffffff82d30000  <span class="number">0000000002</span>d30000  <span class="number">02130000</span>  <span class="number">2</span>**<span class="number">4</span>    </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line"> <span class="number">21</span> .init.data    <span class="number">0011b</span>fa0  ffffffff82da0000  <span class="number">0000000002</span>da0000  <span class="number">021</span>a0000  <span class="number">2</span>**<span class="number">13</span>    </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, DATA </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>发现并没有找到.initcall5.init section，思考：肯定是先编译出来的kernel/trace/trace.o，再整合出来的vmlinux，那么从单个.o到vmlinux，<br>函数的symbol肯定进行一个合并，而且section也会发现变化，这个整合section的规则是什么？因此开始研究第二部分</p><h2 id="section整合规则"><a href="#section整合规则" class="headerlink" title="section整合规则"></a>section整合规则</h2><p>在之前<a href="https://sholck.top/archives/16.html">Kbuild-Makefile</a>的学习中了解到</p><ol><li>ld有自己的默认链接方式，也可以指定链接脚本进行链接</li><li>在链接vmlinux时会先链接.tmp_vmlinux.kallsyms1,<br>链接参数为<code>--script=./arch/x86/kernel/vmlinux.lds</code></li><li>vmlinux.lds是vmlinux.lds.S通过gcc预处理而来，-E选项代表只进行预处理，不进行编译<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;gcc -E -Wp,-MMD,arch/x86/kernel/.vmlinux.lds.d  -nostdinc -I./arch/x86/include -I./arch/x86/include/generated  -I./include -I./arch/x86/include/uapi -I./arch/x86/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/compiler-version.h -include ./include/linux/kconfig.h -D__KERNEL__     -Ux86_64 -P -Ux86 -D__ASSEMBLY__ -DLINKER_SCRIPT -o arch/x86/kernel/vmlinux.lds arch/x86/kernel/vmlinux.lds.S&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>因此重点关注</p><ol><li><p>vmlinux.lds.S如何进行预处理的? 预处理时针对内核进行了哪些动态的设置？</p><p>预处理应该是进行一些注释的删除，文件包含，宏定义，条件编译<br>动态设置包括：输出格式，函数入口，section的内存存放地址和整合规则<br>下面是.init.data section的封装设置</p><details><summary>.init.data section的封装</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vmlinux.lds.S</span></span><br><span class="line">INIT_DATA_SECTION(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//include/asm-generic/vmlinux.lds.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_DATA_SECTION(initsetup_align)                              \     </span></span><br><span class="line">    .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) &#123;               \     </span><br><span class="line">            INIT_DATA                                               \                                                                                                                                           </span><br><span class="line">            INIT_SETUP(initsetup_align)                             \                                                                                                                                           </span><br><span class="line">            INIT_CALLS                                              \                                                                                                                                           </span><br><span class="line">            CON_INITCALL                                            \                                                                                                                                           </span><br><span class="line">            INIT_RAM_FS                                             \                                                                                                                                           </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CALLS_LEVEL(level)                                         \</span></span><br><span class="line">            __initcall#<span class="meta">#level##_start = .;                          \</span></span><br><span class="line">            KEEP(*(.initcall#<span class="meta">#level##.init))                        \</span></span><br><span class="line">            KEEP(*(.initcall#<span class="meta">#level##s.init))                       \</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CALLS                                                      \                                                                                                                                           </span></span><br><span class="line">            __initcall_start = .;                                   \</span><br><span class="line">            KEEP(*(.initcallearly.init))                            \</span><br><span class="line">            INIT_CALLS_LEVEL(<span class="number">0</span>)                                     \</span><br><span class="line">            INIT_CALLS_LEVEL(<span class="number">1</span>)                                     \</span><br><span class="line">            INIT_CALLS_LEVEL(<span class="number">2</span>)                                     \</span><br><span class="line">            INIT_CALLS_LEVEL(<span class="number">3</span>)                                     \</span><br><span class="line">            INIT_CALLS_LEVEL(<span class="number">4</span>)                                     \</span><br><span class="line">            INIT_CALLS_LEVEL(<span class="number">5</span>)                                     \</span><br><span class="line">            INIT_CALLS_LEVEL(rootfs)                                \</span><br><span class="line">            INIT_CALLS_LEVEL(<span class="number">6</span>)                                     \</span><br><span class="line">            INIT_CALLS_LEVEL(<span class="number">7</span>)                                     \</span><br><span class="line">            __initcall_end = .;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details></li><li><p>section的调整规则？</p><p>在vmlinux.lds的SECTIONS部分，针对.init.data section，通过以上宏扩展，<br>部分扩展如下<code>__initcall5_start = .; KEEP(*(.initcall5.init))</code>，<br>强制将<code>.initcall5.init</code> section保留并合并到<code>.init.data section</code>分区</p></li></ol><h2 id="启动调用分析"><a href="#启动调用分析" class="headerlink" title="启动调用分析"></a>启动调用分析</h2><p>我们将各级的.initcall都整合到<code>.init.data</code> section之后链接到vmlinux。此时各对象(比如trace.o)下<code>.initcall5.init</code>的symbol都链接到<code>.init.data</code>的同一块内存区域，<br>组成了一块从__initcall5_start地址开始的一个类型为initcall_t的数组, 可以理解为 <code>initcall_t __initcall5_start[];</code> 在init.c中就可以通过<code>__initcall5_start</code>这个数组去调用每一个<br>通过<code>fs_initcall</code>调用的模块接口</p><p>下面是具体的调用实现</p><details><summary>__initcall5_start调用</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//init/main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_entry_t</span> __initcall5_start[];     </span><br><span class="line">...    </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_entry_t</span> __initcall_end[];     </span><br><span class="line">     </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">initcall_entry_t</span> *initcall_levels[] __initdata = &#123;                                                                                                                                                           </span><br><span class="line">        __initcall0_start,     </span><br><span class="line">        __initcall1_start,     </span><br><span class="line">        __initcall2_start,     </span><br><span class="line">        __initcall3_start,     </span><br><span class="line">        __initcall4_start,     </span><br><span class="line">        __initcall5_start,     </span><br><span class="line">        __initcall6_start,     </span><br><span class="line">        __initcall7_start,     </span><br><span class="line">        __initcall_end,     </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从名字可以看出每个阶段应该做的事情</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *initcall_level_names[] __initdata = &#123;</span><br><span class="line">        <span class="string">&quot;pure&quot;</span>,</span><br><span class="line">        <span class="string">&quot;core&quot;</span>,</span><br><span class="line">        <span class="string">&quot;postcore&quot;</span>,</span><br><span class="line">        <span class="string">&quot;arch&quot;</span>,</span><br><span class="line">        <span class="string">&quot;subsys&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;device&quot;</span>,</span><br><span class="line">        <span class="string">&quot;late&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">do_initcall_level</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">char</span> *command_line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">initcall_entry_t</span> *fn;</span><br><span class="line"></span><br><span class="line">        parse_args(initcall_level_names[level],</span><br><span class="line">                   command_line, __start___param,</span><br><span class="line">                   __stop___param - __start___param,</span><br><span class="line">                   level, level,</span><br><span class="line">                   <span class="literal">NULL</span>, ignore_unknown_bootoption);</span><br><span class="line"></span><br><span class="line">        trace_initcall_level(initcall_level_names[level]);</span><br><span class="line">        <span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++) &gt;&gt;获取连续的每一个<span class="number">5</span>级别symbol内存存放的地址</span><br><span class="line">                do_one_initcall(initcall_from_entry(fn));&gt;&gt; *fn获取每一个<span class="number">5</span>级别函数的symbol</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init_or_module <span class="title">do_one_initcall</span><span class="params">(<span class="keyword">initcall_t</span> fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">        do_trace_initcall_start(fn);</span><br><span class="line">        ret = fn();   &gt;&gt;开始真正的调用                                                                                                                                                                                              </span><br><span class="line">        do_trace_initcall_finish(fn, ret);          </span><br><span class="line">...      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="启动调用gdb分析"><a href="#启动调用gdb分析" class="headerlink" title="启动调用gdb分析"></a>启动调用gdb分析</h3><h4 id="大坑疑问"><a href="#大坑疑问" class="headerlink" title="大坑疑问"></a>大坑疑问</h4><p>在设置gdb断点时碰到了大坑，代码部分如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1359</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">do_initcall_level</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">char</span> *command_line)</span></span></span><br><span class="line"><span class="function">1360 </span>&#123;                                    </span><br><span class="line"><span class="number">1361</span>         <span class="keyword">initcall_entry_t</span> *fn;                           </span><br><span class="line"><span class="number">1362</span>                             </span><br><span class="line"><span class="number">1363</span>         parse_args(initcall_level_names[level],                    </span><br><span class="line"><span class="number">1364</span>                    command_line, __start___param,</span><br><span class="line"><span class="number">1365</span>                    __stop___param - __start___param,</span><br><span class="line"><span class="number">1366</span>                    level, level,                          </span><br><span class="line"><span class="number">1367</span>                    <span class="literal">NULL</span>, ignore_unknown_bootoption);          </span><br><span class="line"><span class="number">1368</span>  </span><br><span class="line"><span class="number">1369</span>         trace_initcall_level(initcall_level_names[level]);</span><br><span class="line"><span class="number">1370</span>         <span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++) </span><br><span class="line"><span class="number">1371</span>                 do_one_initcall(initcall_from_entry(fn)); &gt;&gt;offset_to_ptr(entry);<span class="comment">//CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=y</span></span><br><span class="line"><span class="number">1372</span> &#125;   </span><br></pre></td></tr></table></figure><p>下面是疑问？</p><ol><li><p><code>b do_initcall_level</code>可以设置成功，但是symbol里应该没有这个函数，但是为什么可以设置成功</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b do_initcall_level</span><br><span class="line">Breakpoint <span class="number">3</span> at <span class="number">0xffffffff82d3197d</span>: file init/main.c, line <span class="number">1365.</span></span><br></pre></td></tr></table></figure></li><li><p><code>b do_initcall_level</code>既然可以设置成功，但是为什么断点只触发一次？</p></li><li><p>为什么设置的断点在line 1365.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info symbol <span class="number">0xffffffff82d3197d</span> </span><br><span class="line">kernel_init_freeable + <span class="number">367</span> in section .init.text</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>设置<code>b init/main.c:1359</code>为什么也只触发一次？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b init/main.c:<span class="number">1359</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0xffffffff82d31984</span>: file init/main.c, line <span class="number">1363.</span></span><br></pre></td></tr></table></figure></li><li><p>设置<code>b __initcall__kmod_nmi__312_102_nmi_warning_debugfs5</code>无效？但是symbol对应的地址都是正确的。 –&gt;因为symbol的类型不是function</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info address __initcall__kmod_nmi__312_102_nmi_warning_debugfs5</span><br><span class="line">Symbol <span class="string">&quot;__initcall__kmod_nmi__312_102_nmi_warning_debugfs5&quot;</span> is at <span class="number">0xffffffff82ebb71c</span> in a file compiled without debugging.</span><br><span class="line">(gdb) b __initcall__kmod_nmi__312_102_nmi_warning_debugfs5</span><br><span class="line">Function <span class="string">&quot;__initcall__kmod_nmi__312_102_nmi_warning_debugfs5&quot;</span> <span class="keyword">not</span> defined.</span><br></pre></td></tr></table></figure></li></ol><h4 id="分析CONFIG-HAVE-ARCH-PREL32-RELOCATIONS-y情况"><a href="#分析CONFIG-HAVE-ARCH-PREL32-RELOCATIONS-y情况" class="headerlink" title="分析CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=y情况"></a>分析CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=y情况</h4><p>为了分析.init.data section中的<code>.initcall5.init</code>内存地址，设置如下断点</p><ol><li><p>init/main.c:1369或者trace_initcall_level(更好)</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//设置断点init/main.c:1369时的触发打印</span></span><br><span class="line"> (gdb) info b </span><br><span class="line"> Num     Type           Disp Enb Address            What</span><br><span class="line"> breakpoint     keep y   <span class="number">0xffffffff82d319f1</span> <span class="keyword">in</span> do_initcall_level at init/main.c:<span class="number">1369</span></span><br><span class="line"> </span><br><span class="line"> Continuing.</span><br><span class="line"></span><br><span class="line"> Thread <span class="number">1</span> hit Breakpoint <span class="number">1</span>, do_initcall_level (command_line=<span class="number">0xffff888003783100</span> <span class="string">&quot;root&quot;</span>, </span><br><span class="line">     level=&lt;optimized <span class="keyword">out</span>&gt;) at init/main.c:<span class="number">1369</span></span><br><span class="line"> <span class="number">1369</span>                trace_initcall_level(initcall_level_names[level]);</span><br><span class="line"></span><br><span class="line"> (gdb) p level</span><br><span class="line"> $<span class="number">1</span> = &lt;optimized <span class="keyword">out</span>&gt;  &gt;&gt;编译器优化无法查看level，无法判定走到哪个级别的内存处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置断点trace_initcall_level时的触发打印</span></span><br><span class="line"> (gdb) b trace_initcall_level</span><br><span class="line"> Breakpoint <span class="number">1</span> at <span class="number">0xffffffff81b07600</span>: trace_initcall_level. (<span class="number">2</span> locations)</span><br><span class="line"> (gdb) info b</span><br><span class="line"> Num     Type           Disp Enb Address            What</span><br><span class="line"> <span class="number">1</span>       breakpoint     keep y   &lt;MULTIPLE&gt;         </span><br><span class="line"> <span class="number">1.1</span>                         y     <span class="number">0xffffffff81b07600</span> <span class="keyword">in</span> trace_initcall_level </span><br><span class="line">                                                    at ./arch/x86/include/asm/jump_label.h:<span class="number">27</span></span><br><span class="line"> <span class="number">1.2</span>                         y     <span class="number">0xffffffff82d591ba</span> <span class="keyword">in</span> trace_initcall_level </span><br><span class="line">                                                    at ./arch/x86/include/asm/jump_label.h:<span class="number">27</span></span><br><span class="line"></span><br><span class="line">(gdb) c</span><br><span class="line"> Continuing.</span><br><span class="line"><span class="string"> [Switching to Thread 2]</span></span><br><span class="line"> </span><br><span class="line"> Thread <span class="number">2</span> hit Breakpoint <span class="number">1</span>, trace_initcall_level (level=<span class="number">0xffffffff8237c4a7</span> <span class="string">&quot;fs&quot;</span>) &gt;&gt;此时可以看到initcall_level_names</span><br><span class="line">     at ./include/trace/events/initcall.h:<span class="number">10</span></span><br><span class="line"> <span class="number">10</span>      TRACE_EVENT(initcall_level,</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p><code>init/main.c:1370</code> 和 <code>do_one_initcall</code> 到了流程跑到级别5的时候再去设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">trace_initcall_level (level=<span class="number">0xffffffff8237c4a7</span> <span class="string">&quot;fs&quot;</span>) &gt;&gt;级别<span class="number">5</span></span><br><span class="line"></span><br><span class="line">(gdb) b init/main.c:<span class="number">1370</span></span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0xffffffff82d319fe</span>: file init/main.c, line <span class="number">1370.</span> </span><br><span class="line">(gdb) b do_one_initcall</span><br><span class="line">Breakpoint <span class="number">3</span> at <span class="number">0xffffffff81000f90</span>: file init/main.c, line <span class="number">1289.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//do_one_initcall是有symbol的</span></span><br><span class="line">ffffffff81000f90 g     F .text  <span class="number">00000000000001</span>d6 do_one_initcall</span><br><span class="line"></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">2</span>, do_initcall_level (command_line=<span class="number">0xffff888003783100</span> <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    level=&lt;optimized out&gt;) at init/main.c:<span class="number">1370</span></span><br><span class="line"><span class="number">1370</span>            <span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++)</span><br><span class="line">(gdb) p fn</span><br><span class="line">$<span class="number">1</span> = &lt;optimized out&gt;  &gt;&gt;fn也被编译器优化了</span><br><span class="line">(gdb) p level</span><br><span class="line">$<span class="number">2</span> = &lt;optimized out&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>此时开始检查内存中存放<code>.initcall5.init</code> section的内存存储的symbol</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_one_initcall (fn=<span class="number">0xffffffff82d3dd47</span> &lt;nmi_warning_debugfs&gt;)</span><br><span class="line">    at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">1289</span>    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) p initcall_levels</span><br><span class="line">$<span class="number">3</span> = &#123;<span class="number">0xffffffff82ebb2b4</span>, <span class="number">0xffffffff82ebb2c8</span>, <span class="number">0xffffffff82ebb3c0</span>, <span class="number">0xffffffff82ebb444</span>, <span class="number">0xffffffff82ebb4a8</span>, <span class="number">0xffffffff82ebb71c</span>, <span class="number">0xffffffff82ebb848</span>, <span class="number">0xffffffff82ebbc28</span>, <span class="number">0xffffffff82ebbd84</span>&#125;</span><br><span class="line">(gdb) p initcall_levels[<span class="number">5</span>]</span><br><span class="line">$<span class="number">6</span> = (<span class="keyword">initcall_entry_t</span> *) <span class="number">0xffffffff82ebb71c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时发现0xffffffff82ebb71c为 initcall5.init section的首地址</span></span><br><span class="line">ffffffff82ebb71c g       .init.data     <span class="number">0000000000000000</span> __initcall5_start</span><br><span class="line"><span class="comment">//也是第一个symbol的地址值，此地址应该存放的是nmi_warning_debugfs的symbol地址</span></span><br><span class="line">ffffffff82ebb71c l       .init.data     <span class="number">0000000000000000</span> __initcall__kmod_nmi__312_102_nmi_warning_debugfs5 </span><br><span class="line"></span><br><span class="line"><span class="comment">//ffffffff82d3dd47 l     F .init.text     0000000000000027 nmi_warning_debugfs</span></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82ebb71c</span></span><br><span class="line"><span class="number">0xffffffff82ebb71c</span>:     <span class="number">0xffe8ae5dffe8262b</span> &gt;&gt;为什么不是nmi_warning_debugfs的symbol <span class="number">0xffffffff82d3dd47</span>呢？这儿是偏移</span><br><span class="line"></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_one_initcall (fn=<span class="number">0xffffffff82d4657d</span> &lt;save_microcode_in_initrd&gt;) at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">1289</span>    &#123;</span><br><span class="line">(gdb) p fn</span><br><span class="line">$<span class="number">10</span> = (<span class="keyword">initcall_t</span>) <span class="number">0xffffffff82d4657d</span> &lt;save_microcode_in_initrd&gt;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_one_initcall (fn=<span class="number">0xffffffff82d4e996</span> &lt;hpet_late_init&gt;) at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">1289</span>    &#123;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_one_initcall (fn=<span class="number">0xffffffff82d4ecfa</span> &lt;init_amd_nbs&gt;) at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">1289</span>    &#123;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_one_initcall (fn=<span class="number">0xffffffff82d5608d</span> &lt;iomem_init_inode&gt;) at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">1289</span>    &#123;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_one_initcall (fn=<span class="number">0xffffffff82d5aded</span> &lt;clocksource_done_booting&gt;) at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">1289</span>    &#123;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_one_initcall (fn=<span class="number">0xffffffff82d5e986</span> &lt;tracer_init_tracefs&gt;) at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">1289</span>    &#123;</span><br><span class="line">(gdb) p fn</span><br><span class="line">$<span class="number">11</span> = (<span class="keyword">initcall_t</span>) <span class="number">0xffffffff82d5e986</span> &lt;tracer_init_tracefs&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>能发现<code>.initcall5.init</code> section的内存地址的存储的symbol地址如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ffffffff82d3dd47 l     F .init.text     <span class="number">0000000000000027</span> nmi_warning_debugfs &lt;--</span><br><span class="line"></span><br><span class="line">ffffffff82d4657d l     F .init.text     <span class="number">00000000000000</span>a3 save_microcode_in_initrd &lt;--</span><br><span class="line"></span><br><span class="line">ffffffff82d4e996 l     F .init.text     <span class="number">0000000000000364</span> hpet_late_init &lt;--</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ffffffff82d5aded l     F .init.text     <span class="number">0000000000000042</span> clocksource_done_booting &lt;--</span><br><span class="line"></span><br><span class="line">ffffffff82d5e986 l     F .init.text     <span class="number">00000000000002b</span>4 tracer_init_tracefs &lt;--</span><br></pre></td></tr></table></figure><p>fn是<code>initcall_entry_t *</code>类型，fn++是地址偏移 指针指向类型 的大小，从symbol来看，<code>.initcall5.init</code> section下的symbol都是地址都是偏移4个字节，此时发现.config配置为CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=y</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ffffffff82ebb71c l       .init.data     <span class="number">0000000000000000</span> __initcall__kmod_nmi__312_102_nmi_warning_debugfs5</span><br><span class="line">ffffffff82ebb720 l       .init.data     <span class="number">0000000000000000</span> __initcall__kmod_microcode__275_891_save_microcode_in_initrd5</span><br><span class="line">ffffffff82ebb724 l       .init.data     <span class="number">0000000000000000</span> __initcall__kmod_hpet__211_1165_hpet_late_init5</span><br><span class="line">...</span><br><span class="line">ffffffff82ebb730 l       .init.data     <span class="number">0000000000000000</span> __initcall__kmod_clocksource__211_1038_clocksource_done_booting5</span><br><span class="line">ffffffff82ebb734 l       .init.data     <span class="number">0000000000000000</span> __initcall__kmod_trace__397_9768_tracer_init_tracefs5</span><br></pre></td></tr></table></figure><p>地址类型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="function">p <span class="title">sizeof</span><span class="params">(<span class="keyword">initcall_entry_t</span> *)</span></span></span><br><span class="line">$12 = 8</span><br><span class="line">(gdb) <span class="function">p <span class="title">sizeof</span><span class="params">(<span class="keyword">initcall_entry_t</span>)</span>       CONFIG_HAVE_ARCH_PREL32_RELOCATIONS</span>=y  <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">initcall_entry_t</span>;                                                                                                                                                                              </span><br><span class="line">$<span class="number">13</span> = <span class="number">4</span></span><br><span class="line">(gdb) p <span class="keyword">sizeof</span>(<span class="keyword">initcall_t</span>)</span><br><span class="line">$<span class="number">14</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>可以发现问题, 从<code>.initcall5.init</code> section下的内存取出来的symbol 地址不对</p><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x <span class="number">0xffffffff82ebb71c</span></span><br><span class="line"><span class="number">0xffffffff82ebb71c</span>:     <span class="number">0xffe8ae5dffe8262b</span></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82ebb720</span></span><br><span class="line"><span class="number">0xffffffff82ebb720</span>:     <span class="number">0xffe93272ffe8ae5d</span></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82ebb724</span></span><br><span class="line"><span class="number">0xffffffff82ebb724</span>:     <span class="number">0xffe935d2ffe93272</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><p>怀疑问题和<code>CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=y</code>有关</p><h5 id="禁止编译优化分析"><a href="#禁止编译优化分析" class="headerlink" title="禁止编译优化分析"></a>禁止编译优化分析</h5><p>禁止编译优化的几种尝试</p><ol><li><p>内核设置编译优化等级为O0编译失败，内核支持-O2和-Os的编译优化</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE   &gt;&gt;默认                                                                                                                                                                           </span><br><span class="line">KBUILD_CFLAGS += -O0</span><br></pre></td></tr></table></figure></li><li><p>内核设置编译等级为O1,但是启动panic</p></li><li><p>init部分优化, 修改init/Makefile 如下，编译失败</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ccflags-y := -fno-function-sections -fno-data-sections</span><br><span class="line">+ ccflags-y := -fno-function-sections -fno-data-sections -O2</span><br></pre></td></tr></table></figure><p>修改为-O1，依旧为optimized out</p></li></ol><ol start="4"><li><p>增加如下，打印log为<code>print fn is (____ptrval____),size is 8:4</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1369</span>         trace_initcall_level(initcall_level_names[level]);</span><br><span class="line"><span class="number">1370</span>         <span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++)&#123;                                                                                                                                </span><br><span class="line"><span class="number">1371</span>                 pr_info(<span class="string">&quot;print fn is %p,size is %ld:%ld/n&quot;</span>, fn, <span class="keyword">sizeof</span>(fn),  <span class="keyword">sizeof</span>(<span class="keyword">initcall_entry_t</span>));</span><br><span class="line"><span class="number">1372</span>                 do_one_initcall(initcall_from_entry(fn));</span><br><span class="line"><span class="number">1373</span>         &#125;  </span><br></pre></td></tr></table></figure><p>重新调整打印指针为%px，打印如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_one_initcall (fn=<span class="number">0xffffffff82d31cf6</span> &lt;nmi_warning_debugfs&gt;)</span><br><span class="line">    at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">1289</span>    &#123;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_one_initcall (fn=<span class="number">0xffffffff82d3a502</span> &lt;save_microcode_in_initrd&gt;)</span><br><span class="line">    at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">1289</span>    &#123;</span><br><span class="line"></span><br><span class="line">(gdb) p initcall_levels</span><br><span class="line">$<span class="number">1</span> = &#123;<span class="number">0xffffffff82ea0190</span>, <span class="number">0xffffffff82ea01a4</span>, <span class="number">0xffffffff82ea0290</span>, <span class="number">0xffffffff82ea0314</span>, </span><br><span class="line"><span class="number">0xffffffff82ea0378</span>, <span class="number">0xffffffff82ea05e8</span>, <span class="number">0xffffffff82ea070c</span>, <span class="number">0xffffffff82ea0ae8</span>, <span class="number">0xffffffff82ea0c38</span>&#125;</span><br><span class="line"></span><br><span class="line">[    <span class="number">1.175606</span>] print fn is ffffffff82ea05e8,size is <span class="number">8</span>:<span class="number">4</span> &gt;&gt;逻辑正确,<span class="keyword">sizeof</span>大小也正确</span><br><span class="line">[    <span class="number">1.211950</span>] print fn is ffffffff82ea05ec,size is <span class="number">8</span>:<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82ea05e8</span></span><br><span class="line"><span class="number">0xffffffff82ea05e8</span>:     <span class="number">0xffe9170e</span> &gt;&gt;这个怎么找到<span class="number">0xffffffff82d31cf6</span> &lt;nmi_warning_debugfs&gt;？</span><br><span class="line"></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82ea05ec</span></span><br><span class="line"><span class="number">0xffffffff82ea05ec</span>:     <span class="number">0xffe99f16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>最终发现，0xffe9170e是一个偏移,见<code>offset_to_ptr</code>， 0xffffffff82d31cf6 = 0xffffffff82ea05e8 + 0xffe9170e，最终找到<code>nmi_warning_debugfs</code>的symbol<br>由此可见，CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=y的情况下<code>function symbol addr = fn addr + *fn</code>, <code>.initcall5.init</code> section下存储的是偏移(也可以理解为相对地址)</p><ol start="5"><li><p>以下两种是没有symbol的(-O2)</p><pre><code> a. static 标记的并且只被调用过一次的可能被编译器优化为inline, 比如`do_initcall_level`
 b. static inline标记的函数,比如`initcall_from_entry`</code></pre><p>因此可能编译优化导致参数gdb打印为<code>optimized out</code></p><p>修改为noinline如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">do_initcall_level</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">char</span> *command_line)</span></span></span><br><span class="line">+static noinline void __init do_initcall_level(int level, char *command_line)</span><br><span class="line"></span><br><span class="line">-<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">initcall_t</span> <span class="title">initcall_from_entry</span><span class="params">(<span class="keyword">initcall_entry_t</span> *entry)</span></span></span><br><span class="line">+static noinline initcall_t initcall_from_entry(initcall_entry_t *entry)</span><br><span class="line"></span><br><span class="line">-<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">offset_to_ptr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *off)</span></span></span><br><span class="line">+static noinline void *offset_to_ptr(const int *off)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，因为init.h是被很多模块都包含的，但是如果没有调用<code>initcall_from_entry</code>，就会在编译时提示如下，可以增加<code>__maybe_unused</code><br>或者<code>attribute((unused))</code>消除警告提示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./include/linux/init.h:<span class="number">122</span>:<span class="number">28</span>: 警告：‘initcall_from_entry’ defined but <span class="keyword">not</span> used [-Wunused-function]</span><br><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">initcall_t</span> <span class="title">initcall_from_entry</span><span class="params">(<span class="keyword">initcall_entry_t</span> *entry)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>新的符号表如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//符号表</span></span><br><span class="line">ffffffff82d2578f l     F .init.text     <span class="number">000000000000008</span>e do_initcall_level</span><br><span class="line">...</span><br><span class="line">ffffffff81aee60c l     F .text  <span class="number">0000000000000007</span> initcall_from_entry  &gt;&gt;这里出现两次，应该是被两个目标文件生成的  init/main.c  </span><br><span class="line">ffffffff81af001d l     F .text  <span class="number">0000000000000007</span> initcall_from_entry  &gt;&gt;  kernel/printk/printk.c</span><br></pre></td></tr></table></figure><p>调试如下： 0xffffffff82d272f2 =0xffffffff82ea074c + 0xffe86ba6</p><details><summary>noinline测试</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) b do_initcall_level</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0xffffffff82d2578f</span>: file init/main.c, line <span class="number">1360.</span></span><br><span class="line"></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">1</span>, do_initcall_level (level=level@entry=<span class="number">6</span>, </span><br><span class="line">    command_line=command_line@entry=<span class="number">0xffff888003c18100</span> <span class="string">&quot;root=/dev/sda rdinit=init crashkernel=128M console=ttyS0 rw nokaslr&quot;</span>) at init/main.c:<span class="number">1360</span></span><br><span class="line"><span class="number">1360</span>    &#123;</span><br><span class="line">(gdb) p level</span><br><span class="line">    $<span class="number">1</span> = <span class="number">6</span></span><br><span class="line">(gdb) b initcall_from_entry</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0xffffffff81aee60c</span>: initcall_from_entry. (<span class="number">2</span> locations)</span><br><span class="line">(gdb) b do_one_initcall</span><br><span class="line">Breakpoint <span class="number">3</span> at <span class="number">0xffffffff81000f90</span>: file init/main.c, line <span class="number">1289.</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">2</span>, initcall_from_entry (entry=entry@entry=<span class="number">0xffffffff82ea074c</span>)</span><br><span class="line">    at ./include/linux/init.h:<span class="number">123</span></span><br><span class="line"><span class="number">123</span>     &#123;</span><br><span class="line">(gdb) p initcall_levels</span><br><span class="line">$<span class="number">2</span> = &#123;<span class="number">0xffffffff82ea01d0</span>, <span class="number">0xffffffff82ea01e4</span>, <span class="number">0xffffffff82ea02d0</span>, <span class="number">0xffffffff82ea0354</span>, </span><br><span class="line">  <span class="number">0xffffffff82ea03b8</span>, <span class="number">0xffffffff82ea0628</span>, <span class="number">0xffffffff82ea074c</span>, <span class="number">0xffffffff82ea0b28</span>, <span class="number">0xffffffff82ea0c78</span>&#125;</span><br><span class="line">(gdb) b offset_to_ptr</span><br><span class="line">Breakpoint <span class="number">4</span> at <span class="number">0xffffffff8114a7b0</span>: offset_to_ptr. (<span class="number">5</span> locations)</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line"><span class="number">1</span>       breakpoint     keep y   <span class="number">0xffffffff82d2578f</span> in do_initcall_level at init/main.c:<span class="number">1360</span></span><br><span class="line">        breakpoint already hit <span class="number">7</span> times</span><br><span class="line"><span class="number">2</span>       breakpoint     keep y   &lt;MULTIPLE&gt;         </span><br><span class="line">        breakpoint already hit <span class="number">1</span> time</span><br><span class="line"><span class="number">2.1</span>                         y   <span class="number">0xffffffff81aee60c</span> in initcall_from_entry at ./include/linux/init.h:<span class="number">123</span></span><br><span class="line"><span class="number">2.2</span>                         y   <span class="number">0xffffffff81af001d</span> in initcall_from_entry at ./include/linux/init.h:<span class="number">123</span></span><br><span class="line"><span class="number">3</span>       breakpoint     keep y   <span class="number">0xffffffff81000f90</span> in do_one_initcall at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">4</span>       breakpoint     keep y   &lt;MULTIPLE&gt;         </span><br><span class="line"><span class="number">4.1</span>                         y   <span class="number">0xffffffff8114a7b0</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line"><span class="number">4.2</span>                         y   <span class="number">0xffffffff8118f220</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line"><span class="number">4.3</span>                         y   <span class="number">0xffffffff815f6370</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line"><span class="number">4.4</span>                         y   <span class="number">0xffffffff81aee600</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line"><span class="number">4.5</span>                         y   <span class="number">0xffffffff81af0011</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">4</span>, offset_to_ptr (off=off@entry=<span class="number">0xffffffff82ea074c</span>)</span><br><span class="line">    at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line"><span class="number">233</span>     &#123;</span><br><span class="line">(gdb) b include/linux/compiler.h:<span class="number">235</span></span><br><span class="line">Breakpoint <span class="number">5</span> at <span class="number">0xffffffff8114a7bb</span>: include/linux/compiler.h:<span class="number">235.</span> (<span class="number">5</span> locations)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">5</span>, offset_to_ptr (off=off@entry=<span class="number">0xffffffff82ea074c</span>)</span><br><span class="line">    at ./include/linux/compiler.h:<span class="number">235</span></span><br><span class="line"><span class="number">235</span>     &#125;</span><br><span class="line">(gdb) p off</span><br><span class="line">$<span class="number">3</span> = (<span class="keyword">const</span> <span class="keyword">int</span> *) <span class="number">0xffffffff82ea074c</span></span><br><span class="line"></span><br><span class="line">(gdb) x/x *off</span><br><span class="line"><span class="number">0xffffffffffe86ba6</span>:     Cannot access memory at address <span class="number">0xffffffffffe86ba6</span></span><br><span class="line"></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82ea074c</span></span><br><span class="line"><span class="number">0xffffffff82ea074c</span>:     <span class="number">0xffe86ba6</span></span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line"><span class="number">1</span>       breakpoint     keep y   <span class="number">0xffffffff82d2578f</span> in do_initcall_level at init/main.c:<span class="number">1360</span></span><br><span class="line">        breakpoint already hit <span class="number">7</span> times</span><br><span class="line"><span class="number">2</span>       breakpoint     keep y   &lt;MULTIPLE&gt;         </span><br><span class="line">        breakpoint already hit <span class="number">1</span> time</span><br><span class="line"><span class="number">2.1</span>                         y   <span class="number">0xffffffff81aee60c</span> in initcall_from_entry at ./include/linux/init.h:<span class="number">123</span></span><br><span class="line"><span class="number">2.2</span>                         y   <span class="number">0xffffffff81af001d</span> in initcall_from_entry at ./include/linux/init.h:<span class="number">123</span></span><br><span class="line"><span class="number">3</span>       breakpoint     keep y   <span class="number">0xffffffff81000f90</span> in do_one_initcall at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">4</span>       breakpoint     keep y   &lt;MULTIPLE&gt;         </span><br><span class="line">        breakpoint already hit <span class="number">1</span> time</span><br><span class="line"><span class="number">4.1</span>                         y   <span class="number">0xffffffff8114a7b0</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line"><span class="number">4.2</span>                         y   <span class="number">0xffffffff8118f220</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line"><span class="number">4.3</span>                         y   <span class="number">0xffffffff815f6370</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line"><span class="number">4.4</span>                         y   <span class="number">0xffffffff81aee600</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line"><span class="number">4.5</span>                         y   <span class="number">0xffffffff81af0011</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">233</span></span><br><span class="line"><span class="number">5</span>       breakpoint     keep y   &lt;MULTIPLE&gt;         </span><br><span class="line">        breakpoint already hit <span class="number">1</span> time</span><br><span class="line"><span class="number">5.1</span>                         y   <span class="number">0xffffffff8114a7bb</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">235</span></span><br><span class="line"><span class="number">5.2</span>                         y   <span class="number">0xffffffff8118f22b</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">235</span></span><br><span class="line"><span class="number">5.3</span>                         y   <span class="number">0xffffffff815f637b</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">235</span></span><br><span class="line"><span class="number">5.4</span>                         y   <span class="number">0xffffffff81aee60b</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">235</span></span><br><span class="line"><span class="number">5.5</span>                         y   <span class="number">0xffffffff81af001c</span> in offset_to_ptr at ./include/linux/compiler.h:<span class="number">235</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_one_initcall (fn=<span class="number">0xffffffff82d272f2</span> &lt;ia32_binfmt_init&gt;) at init/main.c:<span class="number">1289</span></span><br><span class="line"><span class="number">1289</span>    &#123;</span><br></pre></td></tr></table></figure></details></li></ol><h4 id="分析CONFIG-HAVE-ARCH-PREL32-RELOCATIONS-n情况"><a href="#分析CONFIG-HAVE-ARCH-PREL32-RELOCATIONS-n情况" class="headerlink" title="分析CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=n情况"></a>分析CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=n情况</h4><p>调整<code>CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=n</code>时需要将<br><code>select HAVE_ARCH_PREL32_RELOCATIONS</code>从arch/x86/Kconfig中注释掉，因为这里将其默认使能<code>def_bool y</code></p><p>此时<code>typedef initcall_t initcall_entry_t;</code> 且<code>initcall_from_entry</code> 直接<code>return *entry;</code>，此时应该<code>.initcall5.init</code> section下存储的是symbol地址</p><p>从vmlinux解析出来的符号表就可以验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffffffff82ea0ab8 g       .init.data     <span class="number">0000000000000000</span> __initcall5_start</span><br><span class="line"></span><br><span class="line">ffffffff82ea0ab8 l     O .init.data     <span class="number">0000000000000008</span> __initcall__kmod_nmi__312_102_nmi_warning_debugfs5</span><br><span class="line">ffffffff82ea0ac0 l     O .init.data     <span class="number">0000000000000008</span> __initcall__kmod_microcode__275_891_save_microcode_in_initrd5  &gt;&gt;偏移是<span class="number">8</span>字节</span><br><span class="line">ffffffff82ea0ac8 l     O .init.data     <span class="number">0000000000000008</span> __initcall__kmod_hpet__210_1165_hpet_late_init5</span><br></pre></td></tr></table></figure><p>从内存存储空间来看，直接显示内存存储的指针指向funtion空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这块内存需要在init没有释放前去打印</span></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82ea0ab8</span></span><br><span class="line"><span class="number">0xffffffff82ea0ab8</span> &lt;__initcall__kmod_nmi__312_102_nmi_warning_debugfs5&gt;:        <span class="number">0x82d31cd6</span></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82ea0ac0</span></span><br><span class="line"><span class="number">0xffffffff82ea0ac0</span> &lt;__initcall__kmod_microcode__275_891_save_microcode_in_initrd5&gt;:     <span class="number">0x82d3a4e2</span></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82ea0ac8</span></span><br><span class="line"><span class="number">0xffffffff82ea0ac8</span> &lt;__initcall__kmod_hpet__210_1165_hpet_late_init5&gt;:   <span class="number">0x82d4284d</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/juS3Ve/article/details/82455491">宋宝华： 关于Linux编译优化几个必须掌握的姿势</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.eet-china.com/mp/a36824.html">Linux内核是如何巧妙的初始化各个模块的</a></li></ol></div><div class="popular-posts-header">推荐文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/2.html" rel="bookmark">内核实践-linux5.12.0-rc8</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/16.html" rel="bookmark">Kbuild-Makefile学习</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/14.html" rel="bookmark">crash库的开源提交</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/15.html" rel="bookmark">gdb调试linux内核&驱动模块</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/13.html" rel="bookmark">linux-likely学习</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/gdb/" rel="tag"># gdb</a> <a href="/tags/objcopy/" rel="tag"># objcopy</a> <a href="/tags/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/" rel="tag"># 内核编译</a> <a href="/tags/used/" rel="tag"># __used__</a> <a href="/tags/section/" rel="tag"># __section__</a> <a href="/tags/%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/" rel="tag"># 链接脚本</a> <a href="/tags/vmlinux-lds/" rel="tag"># vmlinux.lds</a> <a href="/tags/%E5%AE%8F%E6%89%A9%E5%B1%95/" rel="tag"># 宏扩展</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/16.html" rel="prev" title="Kbuild-Makefile学习"><i class="fa fa-chevron-left"></i> Kbuild-Makefile学习</a></div><div class="post-nav-item"><a href="/archives/18.html" rel="next" title="cmpxchg kernel-api学习">cmpxchg kernel-api学习 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">模块接口分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91"><span class="nav-number">1.1.</span> <span class="nav-text">模块编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%85%A5%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text">模块入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3%E6%89%A9%E5%B1%95"><span class="nav-number">1.3.</span> <span class="nav-text">入口扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%88%86%E6%9E%90"><span class="nav-number">1.4.</span> <span class="nav-text">扩展分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section%E6%95%B4%E5%90%88%E8%A7%84%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">section整合规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">启动调用分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%B0%83%E7%94%A8gdb%E5%88%86%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">启动调用gdb分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E5%9D%91%E7%96%91%E9%97%AE"><span class="nav-number">3.1.1.</span> <span class="nav-text">大坑疑问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90CONFIG-HAVE-ARCH-PREL32-RELOCATIONS-y%E6%83%85%E5%86%B5"><span class="nav-number">3.1.2.</span> <span class="nav-text">分析CONFIG_HAVE_ARCH_PREL32_RELOCATIONS&#x3D;y情况</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">禁止编译优化分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90CONFIG-HAVE-ARCH-PREL32-RELOCATIONS-n%E6%83%85%E5%86%B5"><span class="nav-number">3.1.3.</span> <span class="nav-text">分析CONFIG_HAVE_ARCH_PREL32_RELOCATIONS&#x3D;n情况</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Sholck</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">19</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">59</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xiaer1921" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaer1921" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:xiaer1921@aliyun.com" title="E-Mail → mailto:xiaer1921@aliyun.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/sholck222" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;sholck222" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa-fw"></i>CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://hackret.com/" title="https:&#x2F;&#x2F;hackret.com&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">RedHat Kairui</a></li><li class="links-of-blogroll-item"><a href="https://linux-kernel-labs.github.io/refs/heads/master/index.html#" title="https:&#x2F;&#x2F;linux-kernel-labs.github.io&#x2F;refs&#x2F;heads&#x2F;master&#x2F;index.html#" rel="noopener external nofollow noreferrer" target="_blank">Linux Kernel Teaching</a></li><li class="links-of-blogroll-item"><a href="https://tding.top/" title="https:&#x2F;&#x2F;tding.top&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">小丁</a></li><li class="links-of-blogroll-item"><a href="https://xiaozhou.net/" title="https:&#x2F;&#x2F;xiaozhou.net&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">iTimpthy</a></li><li class="links-of-blogroll-item"><a href="https://consen.github.io/" title="https:&#x2F;&#x2F;consen.github.io&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">Consen</a></li></ul></div><div><canvas id="canvas" style="width:60%">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){var o,a,r,f,t,i=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],e=document.getElementById("canvas");function h(t,e){for(var n=[1,2,3],l=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],o=0;o<i[e].length;o++)for(var a,h=0;h<i[e][o].length;h++){1==i[e][o][h]&&(a={x:14*(f+2)*t+2*h*(f+1)+(f+1),y:2*o*(f+1)+(f+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*n[Math.floor(Math.random()*n.length)],color:l[Math.floor(Math.random()*l.length)],disY:1},r.push(a))}}function n(){e.height=100;for(var t=0;t<a.length;t++)!function(t,e){for(var n=0;n<i[e].length;n++)for(var l=0;l<i[e][n].length;l++)1==i[e][n][l]&&(o.beginPath(),o.arc(14*(f+2)*t+2*l*(f+1)+(f+1),2*n*(f+1)+(f+1),f,0,2*Math.PI),o.closePath(),o.fill())}(t,a[t]);for(t=0;t<r.length;t++)o.beginPath(),o.arc(r[t].x,r[t].y,f,0,2*Math.PI),o.fillStyle=r[t].color,o.closePath(),o.fill()}e.getContext&&(o=e.getContext("2d"),e.height=100,e.width=700,o.fillStyle="#f00",o.fillRect(10,10,50,50),a=[],r=[],f=e.height/20-1,t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),a.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6]),clearInterval(void 0),setInterval(function(){!function(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),n=[];n.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var l=a.length-1;0<=l;l--)n[l]!==a[l]&&t.push(l+"_"+(Number(a[l])+1)%10);for(l=0;l<t.length;l++)h.apply(this,t[l].split("_"));a=n.concat()}(),function(){for(var t=0;t<r.length;t++)r[t].stepY+=r[t].disY,r[t].x+=r[t].stepX,r[t].y+=r[t].stepY,(r[t].x>700+f||r[t].y>100+f)&&(r.splice(t,1),t--)}(),n()},50))}()</script><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-history fa-" aria-hidden="true"></i> 近期文章</div><ul class="links-of-blogroll-list"><li><a href="/archives/19.html" title="linux-assembly入门学习" target="_blank">linux-assembly入门学习</a></li><li><a href="/archives/18.html" title="cmpxchg kernel-api学习" target="_blank">cmpxchg kernel-api学习</a></li><li><a href="/archives/17.html" title="linux模块初始化分析" target="_blank">linux模块初始化分析</a></li><li><a href="/archives/16.html" title="Kbuild-Makefile学习" target="_blank">Kbuild-Makefile学习</a></li><li><a href="/archives/14.html" title="crash库的开源提交" target="_blank">crash库的开源提交</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="user"></i> </span><span class="author" itemprop="copyrightHolder">Sholck</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">197k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">2:59</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Muse</a> 强力驱动</div><script src="/lib/mermaid/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script></body></html>