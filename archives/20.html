<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/sholck2.jfif"><link rel="icon" type="image/png" sizes="32x32" href="/images/sholck2.jfif"><link rel="icon" type="image/png" sizes="16x16" href="/images/sholck2.jfif"><link rel="mask-icon" href="/images/sholck2.jfif" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"sholck.top",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"right",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="x86下系统调用背景经过之前的汇编实践-解析命令行参数学习，发现在进行系统调用时，不管是调用syscall(), 还是libc封装的系统调用，最终都是通过int $0x80(32位 i386)或者syscall(x86_64)进入内核态从而调用对应的底层实现，x86_32是通过一个0x80的软中断实现的，而x86_64是通过汇编指令syscall实现。 疑问：  0x80的软中断策略如何实现系统调"><meta property="og:type" content="article"><meta property="og:title" content="x86下系统调用"><meta property="og:url" content="http://sholck.top/archives/20.html"><meta property="og:site_name" content="Sholck"><meta property="og:description" content="x86下系统调用背景经过之前的汇编实践-解析命令行参数学习，发现在进行系统调用时，不管是调用syscall(), 还是libc封装的系统调用，最终都是通过int $0x80(32位 i386)或者syscall(x86_64)进入内核态从而调用对应的底层实现，x86_32是通过一个0x80的软中断实现的，而x86_64是通过汇编指令syscall实现。 疑问：  0x80的软中断策略如何实现系统调"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://sholck.top/images/linux/stack-switch.png"><meta property="article:published_time" content="2022-06-16T16:00:00.000Z"><meta property="article:modified_time" content="2022-12-12T15:25:11.806Z"><meta property="article:author" content="Sholck"><meta property="article:tag" content="系统调用"><meta property="article:tag" content="中断"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://sholck.top/images/linux/stack-switch.png"><link rel="canonical" href="http://sholck.top/archives/20.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>x86下系统调用 | Sholck</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Sholck" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Sholck</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">不积跬步,无以至千里.不积小流,无以成江海</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">62</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a></li><li class="menu-item menu-item-project"><a href="/project/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>项目</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://sholck.top/archives/20.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Sholck"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sholck"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">x86下系统调用</h1><div class="post-meta"><i class="fa fa-thumb-tack"></i> <font color="7D26CD">置顶</font> <span class="post-meta-divider">|</span> <span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-06-17 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-17T00:00:00+08:00">2022-06-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-12 23:25:11" itemprop="dateModified" datetime="2022-12-12T23:25:11+08:00">2022-12-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>30k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>27 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="x86下系统调用"><a href="#x86下系统调用" class="headerlink" title="x86下系统调用"></a>x86下系统调用</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>经过之前的<a href="https://sholck.top/archives/19.html#%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">汇编实践-解析命令行参数</a>学习，发现在进行系统调用时，不管是调用syscall(), 还是libc封装的系统调用，最终都是通过int $0x80(32位 i386)或者syscall(x86_64)进入内核态从而调用对应的底层实现，x86_32是通过一个0x80的软中断实现的，而x86_64是通过汇编指令syscall实现。</p><p>疑问：</p><ol><li>0x80的软中断策略如何实现系统调用</li><li>syscall汇编指令具体做了什么？(64bit)</li></ol><a id="more"></a><p>之前已经简单的学习过内嵌汇编 <a href="https://sholck.top/archives/19.html">linux-assembly入门学习</a>，在深入探究之前简单的实践学习一下函数调用逻辑。</p><h2 id="实践-函数调用堆栈逻辑"><a href="#实践-函数调用堆栈逻辑" class="headerlink" title="实践-函数调用堆栈逻辑"></a>实践-函数调用堆栈逻辑</h2><p>实践分为三部分，验证call进行函数调用时堆栈，rbp, rsp指针的处理，不进行编译优化</p><ol><li>两个参数传递</li><li>八个参数传递</li><li>复杂参数传递</li></ol><h3 id="两个参数"><a href="#两个参数" class="headerlink" title="两个参数"></a>两个参数</h3><p>汇编模拟实现call add，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c = a + b;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> c = add(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc -S add.c进行编译生成汇编进行修改成可以运行的汇编语言</p><details><summary>汇编实现call add</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//call-args-1.s</span></span><br><span class="line">.text</span><br><span class="line">.globl	_start</span><br><span class="line">add:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	movl	%edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">	movl	%esi, <span class="number">-24</span>(%rbp)</span><br><span class="line">	movl	<span class="number">-20</span>(%rbp), %edx</span><br><span class="line">	movl	<span class="number">-24</span>(%rbp), %eax</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	movl	%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">	movl	<span class="number">-4</span>(%rbp), %eax</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$<span class="number">16</span>, %rsp</span><br><span class="line">	movl	$<span class="number">1</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">2</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">	movl	<span class="number">-8</span>(%rbp), %edx</span><br><span class="line">	movl	<span class="number">-4</span>(%rbp), %eax</span><br><span class="line">	movl	%edx, %esi</span><br><span class="line">	movl	%eax, %edi</span><br><span class="line">	call	add</span><br><span class="line">	movl	%eax, <span class="number">-12</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">0</span>, %eax</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">        movq    $<span class="number">60</span>, %rax</span><br><span class="line">        movq    $<span class="number">0</span>, %rdi</span><br><span class="line">        syscall</span><br></pre></td></tr></table></figure></details><hr><p>通过gdb记录rbp, rsp的变化</p><details><summary>gdb记录rbp, rsp的变化</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">➜  call-args1 git:(master) ✗ gdb call-args<span class="number">-1</span> </span><br><span class="line">(gdb) b _start</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x400092</span>: file call-args<span class="number">-1.</span>s, line <span class="number">17.</span></span><br><span class="line">(gdb) b add</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x400078</span>: file call-args<span class="number">-1.</span>s, line <span class="number">4.</span></span><br><span class="line">(gdb) run</span><br><span class="line">Breakpoint <span class="number">1</span>, _start () at call-args<span class="number">-1.</span>s:<span class="number">17</span></span><br><span class="line"><span class="number">17</span>              pushq   %rbp</span><br><span class="line">(gdb) p/x $rsp</span><br><span class="line">$<span class="number">1</span> = <span class="number">0x7fffffffda90</span></span><br><span class="line">(gdb) x/x <span class="number">0x7fffffffda90</span></span><br><span class="line"><span class="number">0x7fffffffda90</span>: <span class="number">0x00000001</span>   &gt;&gt;_start 只有一个参数，就是call-args<span class="number">-1</span> 目标本身</span><br><span class="line">(gdb) p/x $rbp</span><br><span class="line">$<span class="number">2</span> = <span class="number">0x0</span>  &gt;&gt;rbp此时还是<span class="number">0</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">18</span>              movq    %rsp, %rbp</span><br><span class="line">(gdb) x/x $rsp</span><br><span class="line"><span class="number">0x7fffffffda88</span>: <span class="number">0x00000000</span>   &gt;&gt;push以后，栈增长，地址<span class="number">-8</span>字节</span><br><span class="line"></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">19</span>              subq    $<span class="number">16</span>, %rsp</span><br><span class="line"></span><br><span class="line">(gdb) x/x $rbp</span><br><span class="line"><span class="number">0x7fffffffda88</span>: <span class="number">0x00000000</span>  &gt;&gt; rbp = rsp</span><br><span class="line"></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">20</span>              movl    $<span class="number">1</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line"></span><br><span class="line">(gdb) x/x $rsp</span><br><span class="line"><span class="number">0x7fffffffda78</span>: <span class="number">0x00000000</span>   &gt;&gt;栈顶下移<span class="number">16</span></span><br><span class="line"></span><br><span class="line">(gdb) n <span class="number">6</span></span><br><span class="line"><span class="number">26</span>              call    add</span><br><span class="line">(gdb) info registers </span><br><span class="line">rax            <span class="number">0x1</span>                 <span class="number">1</span></span><br><span class="line">rbx            <span class="number">0x0</span>                 <span class="number">0</span></span><br><span class="line">rcx            <span class="number">0x0</span>                 <span class="number">0</span></span><br><span class="line">rdx            <span class="number">0x2</span>                 <span class="number">2</span></span><br><span class="line">rsi            <span class="number">0x2</span>                 <span class="number">2</span></span><br><span class="line">rdi            <span class="number">0x1</span>                 <span class="number">1</span></span><br><span class="line">rbp            <span class="number">0x7fffffffda88</span>      <span class="number">0x7fffffffda88</span></span><br><span class="line">rsp            <span class="number">0x7fffffffda78</span>      <span class="number">0x7fffffffda78</span></span><br><span class="line"></span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">2</span>, add () at call-args<span class="number">-1.</span>s:<span class="number">4</span></span><br><span class="line"><span class="number">4</span>               pushq   %rbp</span><br><span class="line">(gdb) info registers </span><br><span class="line">rax            <span class="number">0x1</span>                 <span class="number">1</span></span><br><span class="line">rbx            <span class="number">0x0</span>                 <span class="number">0</span></span><br><span class="line">rcx            <span class="number">0x0</span>                 <span class="number">0</span></span><br><span class="line">rdx            <span class="number">0x2</span>                 <span class="number">2</span></span><br><span class="line">rsi            <span class="number">0x2</span>                 <span class="number">2</span></span><br><span class="line">rdi            <span class="number">0x1</span>                 <span class="number">1</span></span><br><span class="line">rbp            <span class="number">0x7fffffffda88</span>      <span class="number">0x7fffffffda88</span></span><br><span class="line">rsp            <span class="number">0x7fffffffda70</span>      <span class="number">0x7fffffffda70</span>  &gt;&gt;可以发现call调用会使rsp下移<span class="number">8</span>个字节，说明有入栈操作，开始add的堆栈</span><br><span class="line"></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">5</span>               movq    %rsp, %rbp</span><br><span class="line">(gdb) x/x $rsp</span><br><span class="line"><span class="number">0x7fffffffda68</span>: <span class="number">0xffffda88</span>  &gt;&gt;rbp入栈，栈顶下移<span class="number">8</span>位</span><br><span class="line"></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">6</span>               movl    %edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">(gdb) x/x $rbp</span><br><span class="line"><span class="number">0x7fffffffda68</span>: <span class="number">0xffffda88</span>  &gt;&gt;保证add开始前rbp = rsp，代表栈底 = 栈顶</span><br><span class="line"></span><br><span class="line">(gdb) n <span class="number">7</span></span><br><span class="line"><span class="number">13</span>              popq    %rbp &gt;&gt;add栈底的rbp出栈给rbp, 即调用者的栈底地址</span><br><span class="line"></span><br><span class="line">(gdb) n</span><br><span class="line">add () at call-args<span class="number">-1.</span>s:<span class="number">14</span></span><br><span class="line"><span class="number">14</span>              ret  </span><br><span class="line"></span><br><span class="line">(gdb) x/x $rbp</span><br><span class="line"><span class="number">0x7fffffffda88</span>: <span class="number">0x00000000</span>  &gt;&gt;_start的栈底</span><br><span class="line">(gdb) x/x $rsp</span><br><span class="line"><span class="number">0x7fffffffda70</span>: <span class="number">0x004000b7</span> &gt;&gt;rbp出栈， rsp+<span class="number">8</span>, 发现call时入栈时存放的是调用者调用完成之后的下一条指令</span><br><span class="line"></span><br><span class="line">(gdb) n</span><br><span class="line">_start () at call-args<span class="number">-1.</span>s:<span class="number">27</span></span><br><span class="line"><span class="number">27</span>              movl    %eax, <span class="number">-12</span>(%rbp)</span><br><span class="line"></span><br><span class="line">(gdb) x/x $rsp</span><br><span class="line"><span class="number">0x7fffffffda78</span>: <span class="number">0x00000000</span>   &gt;&gt;ret会将保存的rip出栈，给到rip</span><br><span class="line">(gdb) p/x $rip</span><br><span class="line">$<span class="number">4</span> = <span class="number">0x4000b7</span></span><br><span class="line"></span><br><span class="line">(gdb) disassemble _start</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function _start:</span><br><span class="line">   <span class="number">0x0000000000400092</span> &lt;+<span class="number">0</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x0000000000400093</span> &lt;+<span class="number">1</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000000400096</span> &lt;+<span class="number">4</span>&gt;:     sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">0x000000000040009a</span> &lt;+<span class="number">8</span>&gt;:     movl   $<span class="number">0x1</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   <span class="number">0x00000000004000a1</span> &lt;+<span class="number">15</span>&gt;:    movl   $<span class="number">0x2</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">   <span class="number">0x00000000004000a8</span> &lt;+<span class="number">22</span>&gt;:    mov    <span class="number">-0x8</span>(%rbp),%edx</span><br><span class="line">   <span class="number">0x00000000004000ab</span> &lt;+<span class="number">25</span>&gt;:    mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">   <span class="number">0x00000000004000ae</span> &lt;+<span class="number">28</span>&gt;:    mov    %edx,%esi</span><br><span class="line">   <span class="number">0x00000000004000b0</span> &lt;+<span class="number">30</span>&gt;:    mov    %eax,%edi</span><br><span class="line">   <span class="number">0x00000000004000b2</span> &lt;+<span class="number">32</span>&gt;:    call   <span class="number">0x400078</span> &lt;add&gt;</span><br><span class="line">=&gt; <span class="number">0x00000000004000b7</span> &lt;+<span class="number">37</span>&gt;:    mov    %eax,<span class="number">-0xc</span>(%rbp)</span><br><span class="line">   <span class="number">0x00000000004000ba</span> &lt;+<span class="number">40</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br></pre></td></tr></table></figure></details><hr><p>对应的堆栈调用为如下，从上往下增长</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈调用</span></span><br><span class="line">data                addr          代表</span><br><span class="line"><span class="number">0x1</span>         &lt;--- <span class="number">0x7fffffffda90</span>   参数个数        </span><br><span class="line"><span class="number">0x0</span>         &lt;--- <span class="number">0x7fffffffda88</span>                      pushq   %rbp</span><br><span class="line"><span class="number">0x0</span>         &lt;--- <span class="number">0x7fffffffda78</span>   _start栈顶         subq    $<span class="number">16</span>, %rsp</span><br><span class="line"><span class="number">0x004000b7</span>  &lt;--- <span class="number">0x7fffffffda70</span>   保存返回后的rip        call    add</span><br><span class="line"><span class="number">0xffffda88</span>  &lt;--- <span class="number">0x7fffffffda68</span>   _start栈底         pushq   %rbp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上我们可以看出堆栈调用的规律和顺序</p><pre><code>1. 将调用者的栈底地址(即rbp的值) 入栈
2. rbp = rsp, 栈底和栈顶一致，栈顶可以subl设置
3. 对栈的处理为rbp - offset处理
4. 调用函数(call)时将 回调以后的下一个指令(rip)入栈
5. 函数重复1, 2
6. 函数执行完成将调用者的rbp出栈
7. ret返回，将保存的rip出栈，此时rbp, rsp，rip都指向调用者</code></pre><p>当参数小于6个时，采用寄存器按照顺序传参</p><h3 id="八个参数"><a href="#八个参数" class="headerlink" title="八个参数"></a>八个参数</h3><p>汇编模拟实现call add，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f, <span class="keyword">int</span> g, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ext = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> j = a+b+c+d+e+f+g+h+ext;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>, d = <span class="number">4</span>, e = <span class="number">5</span>, f = <span class="number">6</span>, g = <span class="number">7</span>, h = <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span> i = add(a, b, c, d, e, f, g, h);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc -s add.c进行编译生成汇编进行修改成可以运行的汇编语言</p><details><summary>汇编实现call add, 8个参数</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl	_start</span><br><span class="line"></span><br><span class="line">add:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	movl	%edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">	movl	%esi, <span class="number">-24</span>(%rbp)</span><br><span class="line">	movl	%edx, <span class="number">-28</span>(%rbp)</span><br><span class="line">	movl	%ecx, <span class="number">-32</span>(%rbp)</span><br><span class="line">	movl	%r8d, <span class="number">-36</span>(%rbp)</span><br><span class="line">	movl	%r9d, <span class="number">-40</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">20</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">	movl	<span class="number">-20</span>(%rbp), %edx</span><br><span class="line">	movl	<span class="number">-24</span>(%rbp), %eax</span><br><span class="line">	addl	%eax, %edx</span><br><span class="line">	movl	<span class="number">-28</span>(%rbp), %eax</span><br><span class="line">	addl	%eax, %edx</span><br><span class="line">	movl	<span class="number">-32</span>(%rbp), %eax</span><br><span class="line">	addl	%eax, %edx</span><br><span class="line">	movl	<span class="number">-36</span>(%rbp), %eax</span><br><span class="line">	addl	%eax, %edx</span><br><span class="line">	movl	<span class="number">-40</span>(%rbp), %eax</span><br><span class="line">	addl	%eax, %edx</span><br><span class="line">	movl	<span class="number">16</span>(%rbp), %eax</span><br><span class="line">	addl	%eax, %edx</span><br><span class="line">	movl	<span class="number">24</span>(%rbp), %eax</span><br><span class="line">	addl	%eax, %edx</span><br><span class="line">	movl	<span class="number">-4</span>(%rbp), %eax</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	movl	%eax, <span class="number">-8</span>(%rbp)</span><br><span class="line">	movl	<span class="number">-8</span>(%rbp), %eax</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$<span class="number">48</span>, %rsp</span><br><span class="line">	movl	$<span class="number">1</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">2</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">3</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">4</span>, <span class="number">-16</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">5</span>, <span class="number">-20</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">6</span>, <span class="number">-24</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">7</span>, <span class="number">-28</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">8</span>, <span class="number">-32</span>(%rbp)</span><br><span class="line">	movl	<span class="number">-24</span>(%rbp), %r9d</span><br><span class="line">	movl	<span class="number">-20</span>(%rbp), %r8d</span><br><span class="line">	movl	<span class="number">-16</span>(%rbp), %ecx</span><br><span class="line">	movl	<span class="number">-12</span>(%rbp), %edx</span><br><span class="line">	movl	<span class="number">-8</span>(%rbp), %esi</span><br><span class="line">	movl	<span class="number">-4</span>(%rbp), %eax</span><br><span class="line">	movl	<span class="number">-32</span>(%rbp), %edi</span><br><span class="line">	pushq	%rdi</span><br><span class="line">	movl	<span class="number">-28</span>(%rbp), %edi</span><br><span class="line">	pushq	%rdi</span><br><span class="line">	movl	%eax, %edi</span><br><span class="line">	call	add</span><br><span class="line">	addq	$<span class="number">16</span>, %rsp</span><br><span class="line">	movl	%eax, <span class="number">-36</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">0</span>, %eax</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">        movq    $<span class="number">60</span>, %rax</span><br><span class="line">        movq    $<span class="number">0</span>, %rdi</span><br><span class="line">        syscall</span><br></pre></td></tr></table></figure></details><p>gdb验证逻辑结果如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  call-args2 git:(master) ✗ gdb call-args<span class="number">-2</span></span><br><span class="line">(gdb) b call-args<span class="number">-2.</span>s:<span class="number">32</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x4000c5</span>: file call-args<span class="number">-2.</span>s, line <span class="number">32.</span></span><br><span class="line">(gdb) run</span><br><span class="line">Breakpoint <span class="number">1</span>, add () at call-args<span class="number">-2.</span>s:<span class="number">32</span></span><br><span class="line"><span class="number">32</span>              movl    <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">(gdb) p/x $eax</span><br><span class="line">$<span class="number">1</span> = <span class="number">0x38</span></span><br></pre></td></tr></table></figure><p>从汇编发现第7个参数和第8个参数采用入栈的方式，在add汇编中通过16(%rbp)和24(%rbp)寻址。栈的变化如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">value  </span><br><span class="line"><span class="number">7</span>    _start_rbp - <span class="number">28</span></span><br><span class="line"><span class="number">8</span>    _start_rbp - <span class="number">32</span></span><br><span class="line"><span class="number">8</span>    入栈 add_rbp +<span class="number">24</span>,</span><br><span class="line"><span class="number">7</span>    入栈 add_rbp +<span class="number">16</span>,</span><br><span class="line">ret_next_rip</span><br><span class="line">_start_rbp</span><br></pre></td></tr></table></figure><p>从上实践看出，当参数大于6个时，会通过参数倒序入栈，被调用者通过rbp + offset调用</p><h3 id="结构体参数"><a href="#结构体参数" class="headerlink" title="结构体参数"></a>结构体参数</h3><p>汇编模拟实现call add，如下</p><details><summary>汇编实现call add，结构体参数</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试复杂参数传参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TEST</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a1;</span><br><span class="line">        <span class="keyword">int</span> a2;</span><br><span class="line">        <span class="keyword">int</span> a3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_func</span><span class="params">(struct TEST *test_argv, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        sum = test_argv-&gt;a2 + test_argv-&gt;a3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TEST</span> <span class="title">test_argv</span> =</span> &#123;.a2 = <span class="number">2</span>, .a3=<span class="number">3</span>&#125;;</span><br><span class="line">        test_func(&amp;test_argv, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><hr><p>gcc -s add.c进行编译生成汇编进行修改成可以运行的汇编语言</p><details><summary>汇编实现call add, 结构体参数</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl	_start</span><br><span class="line">test_func:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	movq	%rdi, <span class="number">-24</span>(%rbp)</span><br><span class="line">	movl	%esi, <span class="number">-28</span>(%rbp)</span><br><span class="line">	movq	<span class="number">-24</span>(%rbp), %rax</span><br><span class="line">	movl	<span class="number">4</span>(%rax), %edx</span><br><span class="line">	movq	<span class="number">-24</span>(%rbp), %rax</span><br><span class="line">	movl	<span class="number">8</span>(%rax), %eax</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	movl	%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">	nop</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$<span class="number">16</span>, %rsp</span><br><span class="line">	movq	$<span class="number">0</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">0</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">2</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">3</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">	leaq	<span class="number">-12</span>(%rbp), %rax   #相当于把<span class="number">-12</span>(%rbp) 这块内存的地址给到rax</span><br><span class="line">	movl	$<span class="number">10</span>, %esi</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	call	test_func</span><br><span class="line">	movl	$<span class="number">0</span>, %eax</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">        movq    $<span class="number">60</span>, %rax</span><br><span class="line">        movq    $<span class="number">0</span>, %rdi</span><br><span class="line">        syscall</span><br></pre></td></tr></table></figure></details><p>栈的变化和调用如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00</span>      _start_rbp</span><br><span class="line"><span class="number">3</span>         rbp - <span class="number">4</span>     ------&gt;rax+<span class="number">8</span></span><br><span class="line"><span class="number">2</span>         rbp - <span class="number">8</span>      -----&gt;rax+<span class="number">4</span></span><br><span class="line"><span class="number">0</span>         rbp - <span class="number">12</span>     ----&gt;地址给rax</span><br><span class="line">          rbp <span class="number">-16</span>   _start_rip</span><br><span class="line">_start_rbp</span><br><span class="line">ret_next_rip</span><br></pre></td></tr></table></figure><p>从上看出，参数作为指针时， 参数指向的内存在栈上呈倒序，传递的是通过lea获取到的内存指针</p><p>从实验2和实验3也可以看出，虽然两块add栈都存储了参数，但是因为实验3参数其实是指针，因此通过<code>-&gt;</code>进行操作其实是操作指针指向的空间的偏移部分。</p><h2 id="IA-32下系统调用的实现"><a href="#IA-32下系统调用的实现" class="headerlink" title="IA-32下系统调用的实现"></a>IA-32下系统调用的实现</h2><p>32位系统调用是通过软中断0x80来实现的，因此重点追踪IA-32下软中断的实现。</p><h3 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h3><p>IDT全称INTERRUPT DESCRIPTOR TABLE ，记录这中断的相关信息</p><p>linux中使用的IDT申明在<code>def_idts</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> __initconst <span class="class"><span class="keyword">struct</span> <span class="title">idt_data</span> <span class="title">def_idts</span>[] =</span> &#123;</span><br><span class="line">    	</span><br><span class="line">        INTG(X86_TRAP_DE,               asm_exc_divide_error),</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">        TSKG(X86_TRAP_DF,               GDT_ENTRY_DOUBLEFAULT_TSS),</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        ISTG(X86_TRAP_DF,               asm_exc_double_fault, IST_INDEX_DF),</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ...</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IA32_EMULATION)    </span></span><br><span class="line">        SYSG(IA32_SYSCALL_VECTOR,       entry_INT80_compat), </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的每一项称为gate，<code>def_idts</code>下包含了如下四种gate</p><ol><li><code>Interrupte gate</code></li><li><code>trap gate</code></li><li><code>task gate</code> X86_32</li><li><code>Interrupte gate with interrupt stack</code></li></ol><p><code>IDT</code>和<code>gate</code>的结构实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idt_data</span> &#123;</span>                                                                 </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    <span class="built_in">vector</span>; &gt;&gt;中断号</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    segment;    &gt;&gt;GDT_ENTRY_KERNEL_CS*<span class="number">8</span> = <span class="number">16</span></span><br><span class="line">        struct idt_bits bits;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>      *addr; &gt;&gt;中断入口</span><br><span class="line">&#125;;                                                                              </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_struct</span> &#123;</span></span><br><span class="line">        u16             offset_low;</span><br><span class="line">        u16             segment;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">idt_bits</span> <span class="title">bits</span>;</span></span><br><span class="line">        u16             offset_middle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">        u32             offset_high;</span><br><span class="line">        u32             reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_struct</span> <span class="title">gate_desc</span>;</span></span><br><span class="line"><span class="keyword">static</span> gate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;  &gt;&gt;注意，这是个页对齐的，之后需要映射到cea</span><br></pre></td></tr></table></figure><p>在系统启动阶段通过<code>trap_init</code>进行配置，通过<code>idt_setup_traps</code>将全部的gate 描述填充在<code>idt_table</code>，并将对应的中断向量bit设置为1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/<span class="number">8</span>x system_vectors  &gt;&gt;第<span class="number">128</span>位设置为<span class="number">0</span></span><br><span class="line"><span class="number">0xffffffff82edd880</span> &lt;system_vectors&gt;:    <span class="number">0x000fffff</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0xffffffff82edd890</span> &lt;system_vectors+<span class="number">16</span>&gt;: <span class="number">0x00000001</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure><p>在<code>cpu_init_exception_handling</code>内部通过<code>load_current_idt</code>将<code>idt_descr</code>保存在<code>IDTR</code>寄存器中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">desc_ptr</span> <span class="title">idt_descr</span> __<span class="title">ro_after_init</span> =</span> &#123;                 </span><br><span class="line">        .size           = IDT_TABLE_SIZE - <span class="number">1</span>,   &gt;&gt;<span class="number">4095</span> = <span class="number">256</span>*<span class="number">16</span><span class="number">-1</span>，实际作为偏移，<span class="number">0</span>~<span class="number">4095</span></span><br><span class="line">        .address        = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) idt_table,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>IDTR对应的读写指令为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">store_idt</span><span class="params">(struct desc_ptr *dtr)</span>                                         </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;sidt %0&quot;</span>:<span class="string">&quot;=m&quot;</span> (*dtr))</span></span>;                                            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">native_load_idt</span><span class="params">(<span class="keyword">const</span> struct desc_ptr *dtr)</span>                 </span></span><br><span class="line"><span class="function"></span>&#123;                                                                                   </span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;lidt %0&quot;</span>::<span class="string">&quot;m&quot;</span> (*dtr))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IDTR</code>是一个64+16 bit构成的寄存器，前面保存线性基地址，后面保存偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">47</span>(<span class="number">79</span>)                                <span class="number">1615</span>                        <span class="number">0</span></span><br><span class="line">+--------------------------------------+---------------------------+</span><br><span class="line">|                                      |                           |</span><br><span class="line">|      <span class="number">32</span>(<span class="number">64</span>)-bit Linear Base Address  |    <span class="number">16</span>-Bit Table Limit	   |</span><br><span class="line">|                                      |                           |</span><br><span class="line">+------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>下面通过一个动态模块获取<code>IDTR</code>保存的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">store_idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;    </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">desc_ptr</span> <span class="title">desc_ptr_test</span>;</span>    </span><br><span class="line">        pr_info(<span class="string">&quot;module store_idt enter\n&quot;</span>);    </span><br><span class="line">        store_idt(&amp;desc_ptr_test);    </span><br><span class="line">        pr_info(<span class="string">&quot;idt size is %u, idt base addr is %px in arch x86_64\n&quot;</span>, desc_ptr_test.size, (<span class="keyword">void</span> *)desc_ptr_test.address);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">store_idt_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;    </span><br><span class="line">        pr_info(<span class="string">&quot;module store_idt exit\n&quot;</span>);    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line">module_init(store_idt_init);    </span><br><span class="line">module_exit(store_idt_exit);</span><br></pre></td></tr></table></figure><p>运行如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[   <span class="number">33.018534</span>] <span class="keyword">module</span> store_idt enter</span><br><span class="line">[   <span class="number">33.018736</span>] idt size is <span class="number">4095</span>, idt base addr is fffffe0000000000 in arch x86_64</span><br></pre></td></tr></table></figure><p>gdb运行检查，保存的线性基地址和idt_table的地址不同，但是存储的数据是一致的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x &amp;idt_table</span><br><span class="line">$<span class="number">58</span> = <span class="number">0xffffffff82eab000</span></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82eab000</span></span><br><span class="line"><span class="number">0xffffffff82eab000</span> &lt;idt_table&gt;: <span class="number">0x00100860</span></span><br><span class="line">(gdb) x/x <span class="number">0xfffffe0000000000</span></span><br><span class="line"><span class="number">0</span>x fe0000000000:     <span class="number">0x00100860</span></span><br><span class="line">(gdb) p/x &amp;idt_table[<span class="number">1</span>]</span><br><span class="line">$<span class="number">59</span> = <span class="number">0xffffffff82eab010</span></span><br><span class="line">(gdb) x/x <span class="number">0xfffffe0000000010</span></span><br><span class="line"><span class="number">0xfffffe0000000010</span>:     <span class="number">0x00100b30</span></span><br><span class="line">(gdb) x/x <span class="number">0xffffffff82eab010</span></span><br><span class="line"><span class="number">0xffffffff82eab010</span> &lt;idt_table+<span class="number">16</span>&gt;:      <span class="number">0x00100b30</span></span><br></pre></td></tr></table></figure><p>奇怪，为什么地址是不同的呢？检查地址区域，内存分配见<a target="_blank" rel="noopener external nofollow noreferrer" href="https://elixir.bootlin.com/linux/v5.0/source/Documentation/x86/x86_64/mm.txt">x86_64/mm.txt</a>， 发现这是一块<code>cpu_entry_area</code>区域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fffffe0000000000 |   <span class="number">-2</span>    TB | fffffe7fffffffff |  <span class="number">0.5</span> TB | cpu_entry_area mapping</span><br></pre></td></tr></table></figure><p>检查代码流程，发现在<code>trap_init</code>中的<code>cpu_init_exception_handling</code>先保存了一次<code>idt_table</code>的symbol到IDTR，但是之后<code>init_IRQ</code>阶段通过<code>idt_map_in_cea</code>之后并且将<code>cpu_entry_area</code>的线性基地址保存在IDTR中，因此导致地址虽然不同，但是数据是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cea_set_pte(CPU_ENTRY_AREA_RO_IDT_VADDR, __pa_symbol(idt_table),PAGE_KERNEL_RO); &gt;&gt;将对应的idt_table物理页映射到cea, 且<span class="number">4096</span>字节正好一页，并且将页设置为只读</span><br></pre></td></tr></table></figure><h3 id="cea"><a href="#cea" class="headerlink" title="cea"></a>cea</h3><p>cea是一块指定了的线性内存区域，从<code>fffffe0000000000</code>开始，实际的内存分布为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPU_ENTRY_AREA_BASE                                      映射到  idt_table</span><br><span class="line">CPU_ENTRY_AREA_BASE + PAGE_SIZE                          cpu <span class="number">0</span> 的 cea区域<span class="number">0xfffffe0000001000</span></span><br><span class="line">CPU_ENTRY_AREA_BASE + PAGE_SIZE + <span class="number">1</span>*CPU_ENTRY_AREA_SIZE  cpu <span class="number">1</span> 的 cea区域<span class="number">0xfffffe000003C000</span></span><br><span class="line">CPU_ENTRY_AREA_BASE + PAGE_SIZE + <span class="number">2</span>*CPU_ENTRY_AREA_SIZE</span><br></pre></td></tr></table></figure><p>单个cpu的cea区域抽象结构体大致为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct cpu_entry_area &#123;                  </span><br><span class="line">        char gdt[PAGE_SIZE];      &#x2F;&#x2F;cs&amp;ds段 + tss段 16字节  + ldt 16字节</span><br><span class="line">        struct entry_stack_page entry_stack_page;  &#x2F;&#x2F;per_cpu  entry_stack_storage</span><br><span class="line">        struct tss_struct tss;  &#x2F;&#x2F;tss  per_cpu  cpu_tss_rw</span><br><span class="line">        #上面这三个都是per-cpu变量，且都是页对齐</span><br><span class="line">        struct cea_exception_stacks estacks;  &gt;&gt;IST entry  per_cpu  </span><br><span class="line">		...                </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>cea的设置也在<code>trap_init</code>阶段，通过<code>setup_cpu_entry_areas</code>将映射cea的<code>gdt</code>和<code>entry_stack_page</code>，<code>tss</code>等映射到每个cpu 这些参数对应的物理地址区域。</p><p>每一个cpu的<code>gdt_page</code>中保存的是kernel和user模式下的代码段和数据段描述符，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = &#123; .gdt = &#123;</span><br><span class="line">        [GDT_ENTRY_KERNEL32_CS]         = GDT_ENTRY_INIT(<span class="number">0xc09b</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">        [GDT_ENTRY_KERNEL_CS]           = GDT_ENTRY_INIT(<span class="number">0xa09b</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">        [GDT_ENTRY_KERNEL_DS]           = GDT_ENTRY_INIT(<span class="number">0xc093</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">        [GDT_ENTRY_DEFAULT_USER32_CS]   = GDT_ENTRY_INIT(<span class="number">0xc0fb</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">        [GDT_ENTRY_DEFAULT_USER_DS]     = GDT_ENTRY_INIT(<span class="number">0xc0f3</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">        [GDT_ENTRY_DEFAULT_USER_CS]     = GDT_ENTRY_INIT(<span class="number">0xa0fb</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>除了<code>CS</code>和<code>DS</code>段描述符，<code>TSS</code>和<code>LDT</code>描述符之后也会加入其中，见<code>fix_processor_context</code></p><h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><p>GDT全称为<code>global descriptor table</code>，是一些<code>段描述符</code>的集合，这些<code>段描述符</code>提供了段的基地址，访问权限等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">        u16     limit0;</span><br><span class="line">        u16     base0;</span><br><span class="line">        u16     base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">        u16     limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_page</span> &#123;</span>                                                </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">gdt</span>[<span class="title">GDT_ENTRIES</span>];</span>                     </span><br><span class="line">&#125; __attribute__((aligned(PAGE_SIZE)));</span><br></pre></td></tr></table></figure><p>这些段描述通过段选择(segment selector)分为以下几类，我们通过这些段选择来找到对应的段描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL32_CS           1                                    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_CS             2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_DS             3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_DEFAULT_USER32_CS     4                                    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_DEFAULT_USER_DS       5                                    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_DEFAULT_USER_CS       6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_TSS                   8   &gt;&gt;2*8=16字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_LDT                   10  &gt;&gt;2*8=16字节</span></span><br></pre></td></tr></table></figure><p>每个cpu都有自己的GDT，在启动时也被映射到cea区域。我们将GDT线性基地址(cea或者per cpu)保存在<code>GDTR</code>寄存器中，注意，如果之后我们需要通过<code>LTR</code>指令写<code>TR</code>寄存器时，需要将该cpu的gdt地址写入，因为<code>ltr</code>标记TSS描述符实际内存<code>flag部分的B位</code>为<code>busy</code>时会写内存(gdtr + TSS偏移作为立即数)，但是cea区域是<code>RO</code>的，因此使用cpu的gdt地址，不然会产生<code>PG</code>异常。见<code>native_load_tr_desc</code></p><h3 id="MSR-GS-BASE"><a href="#MSR-GS-BASE" class="headerlink" title="MSR_GS_BASE"></a>MSR_GS_BASE</h3><p>这是gs寄存器，用户态可以用来自定义(不知道其他方法，因为wrmsr指令是用户层不可用的)，内核态指向该cpu的per cpu区域地址。</p><p>在<code>cpu_init</code>过程中，通过<code>load_percpu_segment</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wrmsrl(MSR_GS_BASE, cpu_kernelmode_gs_base(cpu));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">cpu_kernelmode_gs_base</span><span class="params">(<span class="keyword">int</span> cpu)</span>                    </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)per_cpu(fixed_percpu_data.gs_base, cpu);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将该cpu对应的per cpu部分的<code>fixed_percpu_data.gs_base</code>地址给到<code>gs寄存器</code>，由于<code>fixed_percpu_data</code>是per cpu区域的第一个成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU_FIRST(struct fixed_percpu_data,fixed_percpu_data) __aligned(PAGE_SIZE) __visible;</span><br><span class="line">EXPORT_PER_CPU_SYMBOL_GPL(fixed_percpu_data)</span><br></pre></td></tr></table></figure><p>因此该cpu下的gs寄存器保存的是per cpu的基地址，也是该cpu对应的<code>__per_cpu_offset</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__per_cpu_start(<span class="number">0x0</span>) --------__per_cpu_end    -----percpu0区域           ------percpu1区域</span><br><span class="line">  |                                                   |                         |</span><br><span class="line">  |-------------------__per_cpu_offset[<span class="number">0</span>]-------------|                         |</span><br><span class="line">  |                                                                             |</span><br><span class="line">  |------------------------__per_cpu_offset[<span class="number">1</span>]----------------------------------|   </span><br></pre></td></tr></table></figure><p>打印每个cpu的gs寄存器，查看每个per cpu的基址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x __per_cpu_offset</span><br><span class="line">$<span class="number">22</span> = &#123;<span class="number">0xffff88803fc00000</span>, <span class="number">0xffff88803fd00000</span>, <span class="number">0xffffffff82cf5000</span> &lt;repeats <span class="number">510</span> times&gt;&#125;  &gt;&gt;前两个有效，因为guest只有两个cpu</span><br></pre></td></tr></table></figure><h3 id="MSR-KERNEL-GS-BASE"><a href="#MSR-KERNEL-GS-BASE" class="headerlink" title="MSR_KERNEL_GS_BASE"></a>MSR_KERNEL_GS_BASE</h3><p>因为<code>MSR_GS_BASE</code>寄存器 用户态和内核态的数值不一样，因此需要<code>MSR_KERNEL_GS_BASE</code>做为其暂储，正如其定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_KERNEL_GS_BASE  0xc0000102 <span class="comment">/* SwapGS GS shadow */</span></span></span><br></pre></td></tr></table></figure><p>因此用户态<code>MSR_KERNEL_GS_BASE</code>保存该cpu下的<code>per cpu</code>地址，内核态保存<code>MSR_GS_BASE</code>用户态的数值</p><h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h3><p>任务管理包括</p><ol><li>TSS</li><li>TSS 描述符 实际需要写入GDT TSS段描述符，占16字节</li><li>task任务寄存器</li><li>task 门描述符 IDT门 (暂不研究)</li></ol><p>TSS用来保存任务在cpu中的状态方便恢复，比如指向弹性栈的指针sp0等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> &#123;</span>     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">x86_hw_tss</span>       <span class="title">x86_tss</span>;</span><span class="comment">//硬件强相关，需要将其地址写入TSS描述符</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">x86_io_bitmap</span>    <span class="title">io_bitmap</span>;</span>    </span><br><span class="line">&#125; __aligned(PAGE_SIZE); </span><br></pre></td></tr></table></figure><p>实际流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见cpu_init_exception_handling下set_tss_desc和load_TR_desc两部分</span></span><br><span class="line">+----------------+</span><br><span class="line">|  x86_hw_tss    | &lt;-----------------|</span><br><span class="line">|--------------- |----&gt;per cpu tss   |</span><br><span class="line">|   io_bitmap    |                   |</span><br><span class="line">+----------------+                   |</span><br><span class="line">                                     |</span><br><span class="line">+----------------+                   |</span><br><span class="line">|      base0     |                   |</span><br><span class="line">|--------------- |                   |</span><br><span class="line">|      base1     |                   |</span><br><span class="line">+----------------+ 指向---------------|</span><br><span class="line">|      base2     | </span><br><span class="line">+----------------+</span><br><span class="line">|      base2     | </span><br><span class="line">+----------------+ per cpu gdt TSS段部分 ------ltr指令---写入任务寄存器,主要是指向x86_hw_tss地址</span><br></pre></td></tr></table></figure><h3 id="弹性栈"><a href="#弹性栈" class="headerlink" title="弹性栈"></a>弹性栈</h3><p>在进行系统调用时，是从用户态ring3切换到内核态ring0，linux实现中只有<code>ring3</code>和<code>ring0</code>，不同权限级别的切换，需要从用户栈切到内核栈，但并不是直接切到内核栈，而是先切换到弹性栈，再切到内核栈，这样可以在切换到内核栈前增加一些代码操作，该特性的增加见<a target="_blank" rel="noopener external nofollow noreferrer" href="https://lore.kernel.org/lkml/20171127104529.12435-17-mingo@kernel.org/">Use a per-CPU trampoline stack for IDT entries</a>。</p><p>本身sp0指向内核栈，rsp先切换到sp0指向的地址，但是由于引入弹性栈，因此sp0指向弹性栈，sp1指向内核栈，之后内核栈的指针也从sp1改动到<code>cpu_current_top_of_stack</code>，修改引入见<code>git show 1591584</code>。</p><p>对应task的stack <code>entry_INT80_compat</code>断点调试如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  linux git:(master) ✗ gdb vmlinux                                  </span><br><span class="line">GNU gdb (Ubuntu 11.1-0ubuntu2) 11.1  </span><br><span class="line"></span><br><span class="line">(gdb) b entry_INT80_compat                                           </span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0xffffffff81c015a0</span>: file arch/x86/entry/entry_64_compat.S, line <span class="number">268.</span></span><br><span class="line">(gdb) target remote:<span class="number">1234</span>            </span><br><span class="line">Remote debugging <span class="keyword">using</span> :<span class="number">1234</span> </span><br><span class="line">0xffffffff81b3e810 in default_idle () at arch/x86/kernel/process.c:729</span><br><span class="line"></span><br><span class="line">(gdb) c                                                              </span><br><span class="line">Continuing.   &gt;&gt;之后通过汇编进行系统调用 <span class="keyword">int</span> <span class="number">0x80</span></span><br><span class="line">Thread 1 hit Breakpoint 1, 0xffffffff81c015a0 in entry_INT80_compat () at arch/x86/entry/entry_64_compat.S:268</span><br><span class="line"><span class="number">268</span>             int3</span><br><span class="line"></span><br><span class="line">(gdb) n                                                              </span><br><span class="line"><span class="number">304</span>             SWAPGS </span><br><span class="line">(gdb) p $rsp                                                         </span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0xfffffe000003dfd8</span>  &gt;&gt;此时已经在弹性栈中</span><br></pre></td></tr></table></figure><p>sp0的设置在<code>cpu_init</code>过程中如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">load_sp0((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(cpu_entry_stack(cpu) + <span class="number">1</span>)); &gt;&gt;注意+<span class="number">1</span>其实是+ <span class="keyword">sizeof</span>(struct entry_stack)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline struct entry_stack *<span class="title">cpu_entry_stack</span><span class="params">(<span class="keyword">int</span> cpu)</span>               </span></span><br><span class="line"><span class="function"></span>&#123;                                                                                  </span><br><span class="line">    <span class="keyword">return</span> &amp;get_cpu_entry_area(cpu)-&gt;entry_stack_page.<span class="built_in">stack</span>;       </span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p>可以发现其实是<code>CEA</code>中该cpu的<code>entry_stack_page</code>部分</p><p>首先需要确定任务调动在哪个cpu上，确定在第二个cpu上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p $lx_current().thread_info</span><br><span class="line">$<span class="number">3</span> = &#123;flags = <span class="number">536870912</span>, syscall_work = <span class="number">0</span>, status = <span class="number">0</span>, cpu = <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p><code>CEA</code>的内存分配如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IDT   一页<span class="number">0x1000</span> </span><br><span class="line"><span class="function">CPU0  <span class="title">sizeof</span><span class="params">(struct cpu_entry_area)</span> </span>= <span class="number">0x3b000</span></span><br><span class="line">CPU1  gdt 一页 之后才是entry_stack_page，size也是一页</span><br></pre></td></tr></table></figure><p>而切换到sp0指向的栈(弹性栈)时会自动push相关寄存器，而且是从sp0指向的栈顶向下增长，注意<code>Error Code</code>不是硬件自动push的</p><p><img src="/images/linux/stack-switch.png" alt="stack-switch"></p><p>计算如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0xfffffe0000000000 + 0x1000 + 0x3b000 + 0x1000 + 0x1000  正好是栈顶的上面，因此入栈正好从栈顶开始</span></span><br><span class="line">(gdb) p/x <span class="number">0xfffffe0000000000</span> + <span class="number">0x1000</span> + <span class="number">0x3b000</span> + <span class="number">0x1000</span> + <span class="number">0x1000</span></span><br><span class="line">$<span class="number">16</span> = <span class="number">0xfffffe000003e000</span></span><br><span class="line"><span class="comment">//push了5个寄存器后，此时的rsp为</span></span><br><span class="line">(gdb) p/x <span class="number">0xfffffe000003e000</span> - <span class="number">40</span></span><br><span class="line">$<span class="number">18</span> = <span class="number">0xfffffe000003dfd8</span>  &gt;&gt;因此这是entry_INT80_compat 的入口栈顶，也是CEA区域，但是CEA部分是只读部分</span><br></pre></td></tr></table></figure><p>之后将rax寄存器push，此时<code>Error Code</code>保存的是系统调用号</p><p>然后切到内核栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">(gdb) n</span><br><span class="line">325             movq    PER_CPU_VAR(cpu_current_top_of_stack), %rsp   &gt;&gt;  movq %gs:cpu_current_top_of_stack, %rsp</span><br><span class="line">(gdb) n</span><br><span class="line">entry_INT80_compat () at arch/x86/entry/entry_64_compat.S:<span class="number">327</span></span><br><span class="line"><span class="number">327</span>             pushq   <span class="number">5</span>*<span class="number">8</span>(%rax)               <span class="comment">/* regs-&gt;ss */</span></span><br><span class="line">(gdb) p $rsp</span><br><span class="line">$<span class="number">19</span> = (<span class="keyword">void</span> *) <span class="number">0xffffc900003b0000</span></span><br><span class="line">(gdb) p $lx_current().<span class="built_in">stack</span>   &gt;&gt;当前任务的内核栈</span><br><span class="line">$<span class="number">20</span> = (<span class="keyword">void</span> *) <span class="number">0xffffc900003ac000</span></span><br><span class="line"><span class="comment">//注意内核栈大小为page&lt;&lt;2，为0x4000，因此内核栈上一位为如下，因此push之后就push到了内核栈底</span></span><br><span class="line"><span class="number">0xffffc900003ac000</span> + <span class="number">0x4000</span> =  <span class="number">0xffffc900003b0000</span></span><br></pre></td></tr></table></figure><p>在切换到新task <code>__switch_to</code>时，进行该任务下内核栈指针<code>cpu_current_top_of_stack</code>的设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this_cpu_write(cpu_current_top_of_stack, task_top_of_stack(next_p));</span><br></pre></td></tr></table></figure><p><code>%gs:cpu_current_top_of_stack</code>指的该cpu下的<code>cpu_current_top_of_stack</code> 变量，计算方式为 <code>per cpu区域基址 + cpu_current_top_of_stack的符号</code>地址存储的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x __per_cpu_offset</span><br><span class="line">$<span class="number">22</span> = &#123;<span class="number">0xffff88803fc00000</span>, <span class="number">0xffff88803fd00000</span>, <span class="number">0xffffffff82cf5000</span> &lt;repeats <span class="number">510</span> times&gt;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//System.map</span></span><br><span class="line"><span class="number">000000000001b</span>f10 D cpu_current_top_of_stack</span><br><span class="line">所以cpu1上的%gs:cpu_current_top_of_stack的值为 <span class="number">0xffff88803fd00000</span> + <span class="number">0x1bf10</span>  = <span class="number">0xffff88803fd1bf10</span>指向的数据</span><br><span class="line"></span><br><span class="line">(gdb) x/<span class="number">2</span>x <span class="number">0xffff88803fd1bf10</span>       &gt;&gt;注意这是一个指向<span class="number">64</span>位的地址</span><br><span class="line"><span class="number">0xffff88803fd1bf10</span>:     <span class="number">0x003b0000</span>  <span class="number">0xffffc900</span>    &gt;&gt;<span class="number">0xffffc900003b0000</span></span><br></pre></td></tr></table></figure><h3 id="内核栈"><a href="#内核栈" class="headerlink" title="内核栈"></a>内核栈</h3><p>内核栈指向当前该cpu上执行任务的线程栈，为任务结构体<code>task_struct</code>中的stack指向的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p $lx_current().<span class="built_in">stack</span>   &gt;&gt;当前任务的内核栈</span><br><span class="line">$<span class="number">20</span> = (<span class="keyword">void</span> *) <span class="number">0xffffc900003ac000</span></span><br></pre></td></tr></table></figure><p>内核栈顶表示为<code>cpu_current_top_of_stack</code></p><p>内核栈分配为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------------+  &lt;--高位</span><br><span class="line">|                |</span><br><span class="line">| <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> |   &lt;</span>--寄存器保存，方便任务切换现场恢复</span><br><span class="line">|                |</span><br><span class="line">+----------------+</span><br><span class="line">|                |</span><br><span class="line">|                |</span><br><span class="line">|                |</span><br><span class="line">+----------------- &lt;---低位</span><br></pre></td></tr></table></figure><h3 id="x64-32-系统调用中断流程总结"><a href="#x64-32-系统调用中断流程总结" class="headerlink" title="x64_32 系统调用中断流程总结"></a>x64_32 系统调用中断流程总结</h3><p>系统中断处理分为四部分</p><ol><li><p>IDT和GDT组成的硬件中断处理寻址</p></li><li><p>进入内核态，<code>entry_INT80_compat</code>内部汇编处理，系统中断硬件强相关部分</p><ul><li><p><code>SWAPGS</code>切换gs寄存器，保证内核栈寻址正确</p></li><li><p><code>rax</code>和<code>rdi</code>保存在弹性栈中</p></li><li><p><code>cr3</code>进行页表切换，清除<code>PCID</code>和<code>PGTABLE</code>两位， KPTI相关</p></li><li><p>切换rsp到该任务运行cpu的内核栈底，并push相关寄存器</p></li><li><p><code>cld</code>清除方向标志，将栈顶rsp给到第一个参数rdi</p></li><li><p>进入<code>do_int80_syscall_32</code></p></li></ul></li><li><p><code>do_int80_syscall_32</code>内部处理</p><ul><li>中断处理</li><li>系统调用号对应的内核函数处理</li></ul></li><li><p>返回用户态 <code>swapgs_restore_regs_and_return_to_usermode</code></p><ul><li><code>POP_REGS pop_rdi=0</code>将内核栈的寄存器pop到对应寄存器</li><li>rsp切到弹性栈，保存返回时的寄存器信息到弹性栈</li><li>通过<code>SWITCH_TO_USER_CR3_STACK</code>进行cr3相关控制</li><li><code>SWAPGS</code>切换gs寄存器</li></ul></li></ol><h2 id="64位下系统调用的实现"><a href="#64位下系统调用的实现" class="headerlink" title="64位下系统调用的实现"></a>64位下系统调用的实现</h2><h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><p>关于SYSCALL， Intel架构文档是这么描述的</p><blockquote><p>5.8.8 Fast System Calls in 64-Bit Mode<br>For SYSCALL, the processor saves RFLAGS into R11 and the RIP of the next instruction into RCX; it then gets the privilege-level 0 target code segment, instruction pointer, stack segment, and flags as follows:<br>•<br>• Target code segment — Reads a non-NULL selector from IA32_STAR[47:32].<br>•<br>• Stack segment — Computed by adding 8 to the value in IA32_STAR[47:32].<br>Target instruction pointer — Reads a 64-bit address from IA32_LSTAR. (The WRMSR instruction ensures<br>that the value of the IA32_LSTAR MSR is canonical.)<br>Flags — The processor sets RFLAGS to the logical-AND of its current value with the complement of the value in<br>the IA32_FMASK MSR.</p></blockquote><p>从以上可以得知syscall调用后将从IA32_LSTAR MSR寄存器中读一个64位的地址，当作下一个执行的指令，存放在RIP寄存器，当然我们系统启动时得先通过WRMSR指令将一个地址写到IA32_LSTAR下。同时获取目标代码段，堆栈等。</p><p>linux下整体的中断向量表定义为：<code>linux/arch/x86/include/asm/irq_vectors.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IA32_SYSCALL_VECTOR             0x80</span></span><br></pre></td></tr></table></figure><p>系统调用对应底层RIP入口实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/arch/x86/entry/entry_64_compat.S</span></span><br><span class="line">SYM_CODE_START(entry_INT80_compat)</span><br><span class="line"></span><br><span class="line"><span class="comment">//linux/arch/x86/entry/entry_64.S</span></span><br><span class="line">SYM_CODE_START(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure><p>在系统启动CPU 初始化时，通过wrmsr函数写<code>MSR_LSTAR</code>完成MSR IA32_LSTAR寄存器的赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* May not be marked __init: used by software suspend */</span>     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_init</span><span class="params">(<span class="keyword">void</span>)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">        wrmsr(MSR_STAR, <span class="number">0</span>, (__USER32_CS &lt;&lt; <span class="number">16</span>) | __KERNEL_CS);     </span><br><span class="line">        wrmsrl(MSR_LSTAR, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)entry_SYSCALL_64);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>wrmsr函数的具体实现</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wrmsrl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> msr, u64 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                             </span><br><span class="line">        native_write_msr(msr, (u32)(val &amp; <span class="number">0xffffffff</span>ULL), (u32)(val &gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> noinline __attribute__((__unused__)) <span class="keyword">void</span> notrace</span><br><span class="line">native_write_msr(<span class="keyword">unsigned</span> <span class="keyword">int</span> msr, u32 low, u32 high)</span><br><span class="line">&#123;</span><br><span class="line">        __wrmsr(msr, low, high);</span><br><span class="line">        <span class="keyword">if</span> (tracepoint_enabled(write_msr))                       </span><br><span class="line">                do_trace_write_msr(msr, ((u64)high &lt;&lt; <span class="number">32</span> | low), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __wrmsr(<span class="keyword">unsigned</span> <span class="keyword">int</span> msr, u32 low, u32 high)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;1: wrmsr\n&quot;</span>                     </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="string">&quot;2:\n&quot;</span>                                           </span></span></span><br><span class="line"><span class="function"><span class="params">                     _ASM_EXTABLE_TYPE(<span class="number">1b</span>, <span class="number">2b</span>, EX_TYPE_WRMSR)</span></span></span><br><span class="line"><span class="function"><span class="params">                     : : <span class="string">&quot;c&quot;</span> (msr), <span class="string">&quot;a&quot;</span>(low), <span class="string">&quot;d&quot;</span> (high) : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>从代码看，内联汇编 输入部分为 MSR_LSTAR给ecx, 函数地址低位给eax, 高位给edx.</p><p>当然既然有wrmsr，就有rdmsr.</p><p>Inter 文档是这么描述<code>wrmsr</code> 和 <code>rdmsr</code>指令的</p><blockquote><p>2.8.7 Reading and Writing Model-Specific Registers<br>The RDMSR (read model-specific register) and WRMSR (write model-specific register) instructions allow a<br>processor’s 64-bit model-specific registers (MSRs) to be read and written, respectively. The MSR to be read or written is specified by the value in the ECX register.<br>RDMSR reads the value from the specified MSR to the EDX:EAX registers; WRMSR writes the value in the EDX:EAX<br>registers to the specified MSR. RDMSR and WRMSR were introduced into the IA-32 architecture with the Pentium<br>processor.<br>See Section 9.4, “Model-Specific Registers (MSRs),” for more information.</p></blockquote><blockquote><p>2.8.7.1 Reading and Writing Model-Specific Registers in 64-Bit Mode<br>RDMSR and WRMSR require an index to specify the address of an MSR. In 64-bit mode, the index is 32 bits; it is<br>specified using ECX.</p></blockquote><p>从上面我们可以看出，rdmsr和wrmsr是如何操控MSR</p><ol><li>都需要指明一个32位的地址存放在ECX<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_STAR                0xc0000081 <span class="comment">/* legacy mode SYSCALL target */</span>      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_LSTAR               0xc0000082 <span class="comment">/* long mode SYSCALL target */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_CSTAR               0xc0000083 <span class="comment">/* compat mode SYSCALL target */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>读写都是通过edx:eax 寄存器， dex-&gt;high位， eax-&gt;low位</li></ol><h3 id="实践-内联汇编读取MSR-指定寄存器"><a href="#实践-内联汇编读取MSR-指定寄存器" class="headerlink" title="实践-内联汇编读取MSR 指定寄存器"></a>实践-内联汇编读取MSR 指定寄存器</h3><details><summary>Arch:x86_64 一个读取MSR 中存储SYSCALL地址寄存器的驱动</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Arch:x86_64 一个读取MSR 中存储SYSCALL地址寄存器的驱动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_LSTAR 0xc0000082</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> asm __asm__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> volatile __volatile__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ULL1 unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="function">ULL1 noinline <span class="title">rdmsr_test</span><span class="params">(ULL1 msr)</span></span>&#123;</span><br><span class="line">        ULL1 low, high;</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;1: rdmsr\n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="string">&quot;2: \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">                      : <span class="string">&quot;=a&quot;</span> (low), <span class="string">&quot;=d&quot;</span> (high)</span></span></span><br><span class="line"><span class="function"><span class="params">                      : <span class="string">&quot;c&quot;</span> (msr)</span></span></span><br><span class="line"><span class="function"><span class="params">                      :)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> (low | high &lt;&lt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(rdmsr_test);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rdmsr_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        ULL1 syscall_address;</span><br><span class="line">        pr_info(<span class="string">&quot;module rdmsr enter\n&quot;</span>);</span><br><span class="line">        syscall_address = rdmsr_test(MSR_LSTAR);</span><br><span class="line">        pr_info(<span class="string">&quot;syscall address is %px in arch x86_64\n&quot;</span>, (<span class="keyword">void</span> *)syscall_address);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rdmsr_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;module rdmsr exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>插入模块打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># insmod rdmsr.ko </span></span><br><span class="line">[  <span class="number">222.170159</span>] <span class="keyword">module</span> rdmsr enter</span><br><span class="line">[  <span class="number">222.183059</span>] syscall address is ffffffff81c00000 in arch x86_64</span><br></pre></td></tr></table></figure><p>实际上ffffffff81c00000就是entry_SYSCALL_64的symbol</p><h3 id="linux实现代码细节"><a href="#linux实现代码细节" class="headerlink" title="linux实现代码细节"></a>linux实现代码细节</h3><p>gdb抓取guest中<code>args-x86_64</code>程序下<code>entry_SYSCALL_64</code>入口堆栈分析，代码见<a href="https://sholck.top/archives/19.html#64%E4%BD%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81">解析命令行参数-64位汇编</a>：</p><p>因为短时间内syscall触发的次数很多，我们需要通过一个关键点判断是否为args-x86_64程序触发，<br>而syscall指令会导致rcx保存为args-x86_64中的next-rip，因此检查一下对应的指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  x86-busybox-rootfs objdump -dS args-x86_64</span><br><span class="line"> ...</span><br><span class="line">     syscall</span><br><span class="line">  <span class="number">4000</span>a3:       <span class="number">0f</span> <span class="number">05</span>                   syscall </span><br><span class="line">    jmp vnext</span><br><span class="line">  <span class="number">4000</span>a5:       eb d2                   jmp    <span class="number">400079</span> &lt;vnext&gt;</span><br></pre></td></tr></table></figure><p>发现next-rip为4000a5，因此<code>entry_SYSCALL_64</code>断点触发以后rax应该是<code>4000a5</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote:<span class="number">1234</span></span><br><span class="line">Remote debugging <span class="keyword">using</span> :<span class="number">1234</span></span><br><span class="line">0xffffffff81b0e21b in native_safe_halt () at ./arch/x86/include/asm/irqflags.h:51</span><br><span class="line"><span class="number">51</span>              <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;sti; hlt&quot;</span>: : :<span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">(gdb) b entry_SYSCALL_64</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0xffffffff81c00000</span>: file arch/x86/entry/entry_64.S, line <span class="number">91.</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">...</span><br><span class="line">Thread <span class="number">2</span> hit Breakpoint <span class="number">1</span>, entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:<span class="number">91</span></span><br><span class="line"><span class="number">91</span>              swapgs</span><br><span class="line">(gdb) p/x $rcx</span><br><span class="line">$<span class="number">1</span> = <span class="number">0x4000a5</span>  &gt;&gt;是由我们触发</span><br><span class="line">(gdb) p $rsp</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">void</span> *) <span class="number">0x7ffc9fcc79f0</span>  &gt;&gt;此时在用户态堆栈，而不是在弹性栈</span><br></pre></td></tr></table></figure><p>之后将<code>pt_regs</code>需要的寄存器部分入栈，并将栈顶指针给到rdx作为第一个参数, rax(保存的是系统调用number)作为第二个参数<br>见<code>entry_SYSCALL_64</code>反汇编</p><details><summary>`entry_SYSCALL_64`反汇编</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble entry_SYSCALL_64</span><br><span class="line">...</span><br><span class="line">   &gt;&gt;swapgs</span><br><span class="line">   mov    %rsp,%gs:<span class="number">0x6014</span>   &gt;&gt;保存用户rsp到sp2</span><br><span class="line">   cr3切换，然后切到内核栈</span><br><span class="line">...</span><br><span class="line">   <span class="number">0xffffffff81c00029</span> &lt;+<span class="number">41</span>&gt;:    push   $<span class="number">0x2b</span>  &gt;&gt;用户数据段</span><br><span class="line">   <span class="number">0xffffffff81c0002b</span> &lt;+<span class="number">43</span>&gt;:    push   %gs:<span class="number">0x6014</span>  &gt;&gt;用户栈顶rsp</span><br><span class="line">   <span class="number">0xffffffff81c00033</span> &lt;+<span class="number">51</span>&gt;:    push   %r11   &gt;&gt;标志位,第一次push,作为eflags</span><br><span class="line">   <span class="number">0xffffffff81c00035</span> &lt;+<span class="number">53</span>&gt;:    push   $<span class="number">0x33</span>  &gt;&gt;用户代码段</span><br><span class="line">   <span class="number">0xffffffff81c00037</span> &lt;+<span class="number">55</span>&gt;:    push   %rcx   &gt;&gt;用户next rip，第一次push rcx，作为保留的rip</span><br><span class="line">   <span class="number">0xffffffff81c00038</span> &lt;+<span class="number">56</span>&gt;:    push   %rax</span><br><span class="line">   <span class="number">0xffffffff81c00039</span> &lt;+<span class="number">57</span>&gt;:    push   %rdi</span><br><span class="line">   <span class="number">0xffffffff81c0003a</span> &lt;+<span class="number">58</span>&gt;:    push   %rsi</span><br><span class="line">   <span class="number">0xffffffff81c0003b</span> &lt;+<span class="number">59</span>&gt;:    push   %rdx</span><br><span class="line">   <span class="number">0xffffffff81c0003c</span> &lt;+<span class="number">60</span>&gt;:    push   %rcx   &gt;&gt;第二次push rcx,</span><br><span class="line">   <span class="number">0xffffffff81c0003d</span> &lt;+<span class="number">61</span>&gt;:    push   $<span class="number">0xffffffffffffffda</span></span><br><span class="line">   <span class="number">0xffffffff81c0003f</span> &lt;+<span class="number">63</span>&gt;:    push   %r8</span><br><span class="line">   <span class="number">0xffffffff81c00041</span> &lt;+<span class="number">65</span>&gt;:    push   %r9</span><br><span class="line">   <span class="number">0xffffffff81c00043</span> &lt;+<span class="number">67</span>&gt;:    push   %r10</span><br><span class="line">   <span class="number">0xffffffff81c00045</span> &lt;+<span class="number">69</span>&gt;:    push   %r11 &gt;&gt;第二次push标志位</span><br><span class="line">   <span class="number">0xffffffff81c00047</span> &lt;+<span class="number">71</span>&gt;:    push   %rbx</span><br><span class="line">   <span class="number">0xffffffff81c00048</span> &lt;+<span class="number">72</span>&gt;:    push   %rbp</span><br><span class="line">   <span class="number">0xffffffff81c00049</span> &lt;+<span class="number">73</span>&gt;:    push   %r12</span><br><span class="line">   <span class="number">0xffffffff81c0004b</span> &lt;+<span class="number">75</span>&gt;:    push   %r13</span><br><span class="line">   <span class="number">0xffffffff81c0004d</span> &lt;+<span class="number">77</span>&gt;:    push   %r14</span><br><span class="line">   <span class="number">0xffffffff81c0004f</span> &lt;+<span class="number">79</span>&gt;:    push   %r15</span><br><span class="line">   <span class="number">0xffffffff81c00051</span> &lt;+<span class="number">81</span>&gt;:    <span class="keyword">xor</span>    %edx,%edx</span><br><span class="line">   <span class="number">0xffffffff81c00053</span> &lt;+<span class="number">83</span>&gt;:    <span class="keyword">xor</span>    %ecx,%ecx</span><br><span class="line">   <span class="number">0xffffffff81c00055</span> &lt;+<span class="number">85</span>&gt;:    <span class="keyword">xor</span>    %r8d,%r8d</span><br><span class="line">   <span class="number">0xffffffff81c00058</span> &lt;+<span class="number">88</span>&gt;:    <span class="keyword">xor</span>    %r9d,%r9d</span><br><span class="line">   <span class="number">0xffffffff81c0005b</span> &lt;+<span class="number">91</span>&gt;:    <span class="keyword">xor</span>    %r10d,%r10d</span><br><span class="line">   <span class="number">0xffffffff81c0005e</span> &lt;+<span class="number">94</span>&gt;:    <span class="keyword">xor</span>    %r11d,%r11d</span><br><span class="line">   <span class="number">0xffffffff81c00061</span> &lt;+<span class="number">97</span>&gt;:    <span class="keyword">xor</span>    %ebx,%ebx</span><br><span class="line">   <span class="number">0xffffffff81c00063</span> &lt;+<span class="number">99</span>&gt;:    <span class="keyword">xor</span>    %ebp,%ebp</span><br><span class="line">   <span class="number">0xffffffff81c00065</span> &lt;+<span class="number">101</span>&gt;:   <span class="keyword">xor</span>    %r12d,%r12d</span><br><span class="line">   <span class="number">0xffffffff81c00068</span> &lt;+<span class="number">104</span>&gt;:   <span class="keyword">xor</span>    %r13d,%r13d</span><br><span class="line">   <span class="number">0xffffffff81c0006b</span> &lt;+<span class="number">107</span>&gt;:   <span class="keyword">xor</span>    %r14d,%r14d</span><br><span class="line">   <span class="number">0xffffffff81c0006e</span> &lt;+<span class="number">110</span>&gt;:   <span class="keyword">xor</span>    %r15d,%r15d</span><br><span class="line">   <span class="number">0xffffffff81c00071</span> &lt;+<span class="number">113</span>&gt;:   mov    %rsp,%rdi     &gt;&gt;采用栈指针方式传递参数</span><br><span class="line">   <span class="number">0xffffffff81c00074</span> &lt;+<span class="number">116</span>&gt;:   movslq %eax,%rsi     &gt;&gt;为什么采用扩展位？为了安全吗？</span><br><span class="line">   <span class="number">0xffffffff81c00077</span> &lt;+<span class="number">119</span>&gt;:   call   <span class="number">0xffffffff81afa0e0</span> &lt;do_syscall_64&gt;  &gt;&gt;实际系统调用处理</span><br><span class="line">   <span class="number">0xffffffff81c0007c</span> &lt;+<span class="number">124</span>&gt;:   nop</span><br><span class="line">   <span class="number">0xffffffff81c0007d</span> &lt;+<span class="number">125</span>&gt;:   nop</span><br><span class="line">   <span class="number">0xffffffff81c0007e</span> &lt;+<span class="number">126</span>&gt;:   nop</span><br><span class="line">   <span class="number">0xffffffff81c0007f</span> &lt;+<span class="number">127</span>&gt;:   nop</span><br><span class="line">   <span class="number">0xffffffff81c00080</span> &lt;+<span class="number">128</span>&gt;:   nop</span><br><span class="line">   <span class="number">0xffffffff81c00081</span> &lt;+<span class="number">129</span>&gt;:   mov    <span class="number">0x58</span>(%rsp),%rcx  &gt;&gt;复原rcx寄存器</span><br><span class="line">   <span class="number">0xffffffff81c00086</span> &lt;+<span class="number">134</span>&gt;:   mov    <span class="number">0x80</span>(%rsp),%r11  &gt;&gt;将用户栈下一个的rip暂存在r11中</span><br><span class="line">   <span class="number">0xffffffff81c0008e</span> &lt;+<span class="number">142</span>&gt;:   cmp    %rcx,%r11   &gt;&gt;因为都是push的rcx,应该是相等的才对</span><br><span class="line">   <span class="number">0xffffffff81c00091</span> &lt;+<span class="number">145</span>&gt;:   jne    <span class="number">0xffffffff81c00ed0</span> &lt;common_interrupt_return&gt;</span><br><span class="line">   <span class="number">0xffffffff81c00097</span> &lt;+<span class="number">151</span>&gt;:   shl    $<span class="number">0x10</span>,%rcx  &gt;&gt;<span class="number">5</span>级页表特性相关</span><br><span class="line">   <span class="number">0xffffffff81c0009b</span> &lt;+<span class="number">155</span>&gt;:   sar    $<span class="number">0x10</span>,%rcx</span><br><span class="line">   <span class="number">0xffffffff81c0009f</span> &lt;+<span class="number">159</span>&gt;:   cmp    %rcx,%r11   </span><br><span class="line">   <span class="number">0xffffffff81c000a2</span> &lt;+<span class="number">162</span>&gt;:   jne    <span class="number">0xffffffff81c00ed0</span> &lt;common_interrupt_return&gt;</span><br><span class="line">   <span class="number">0xffffffff81c000a8</span> &lt;+<span class="number">168</span>&gt;:   cmpq   $<span class="number">0x33</span>,<span class="number">0x88</span>(%rsp)   &gt;&gt;检查保存的cs段选择是正确的</span><br><span class="line">   <span class="number">0xffffffff81c000b1</span> &lt;+<span class="number">177</span>&gt;:   jne    <span class="number">0xffffffff81c00ed0</span> &lt;common_interrupt_return&gt;</span><br><span class="line">   <span class="number">0xffffffff81c000b7</span> &lt;+<span class="number">183</span>&gt;:   mov    <span class="number">0x30</span>(%rsp),%r11  &gt;&gt;r11复原</span><br><span class="line">   <span class="number">0xffffffff81c000bc</span> &lt;+<span class="number">188</span>&gt;:   cmp    %r11,<span class="number">0x90</span>(%rsp)  &gt;&gt;&gt;&gt;保证r11=eflags</span><br><span class="line">   <span class="number">0xffffffff81c000c4</span> &lt;+<span class="number">196</span>&gt;:   jne    <span class="number">0xffffffff81c00ed0</span> &lt;common_interrupt_return&gt;</span><br><span class="line">   <span class="number">0xffffffff81c000ca</span> &lt;+<span class="number">202</span>&gt;:   test   $<span class="number">0x10100</span>,%r11</span><br><span class="line">   <span class="number">0xffffffff81c000d1</span> &lt;+<span class="number">209</span>&gt;:   jne    <span class="number">0xffffffff81c00ed0</span> &lt;common_interrupt_return&gt;</span><br><span class="line">   <span class="number">0xffffffff81c000d7</span> &lt;+<span class="number">215</span>&gt;:   cmpq   $<span class="number">0x2b</span>,<span class="number">0xa0</span>(%rsp)  &gt;&gt;检查保存的ds段选择是正确的</span><br><span class="line">   <span class="number">0xffffffff81c000e0</span> &lt;+<span class="number">224</span>&gt;:   jne    <span class="number">0xffffffff81c00ed0</span> &lt;common_interrupt_return&gt;</span><br><span class="line">   &gt;&gt;开始恢复用户栈现场</span><br><span class="line">   <span class="number">0xffffffff81c000e6</span> &lt;+<span class="number">230</span>&gt;:   pop    %r15</span><br><span class="line">   <span class="number">0xffffffff81c000e8</span> &lt;+<span class="number">232</span>&gt;:   pop    %r14</span><br><span class="line">   <span class="number">0xffffffff81c000ea</span> &lt;+<span class="number">234</span>&gt;:   pop    %r13</span><br><span class="line">   <span class="number">0xffffffff81c000ec</span> &lt;+<span class="number">236</span>&gt;:   pop    %r12</span><br><span class="line">   <span class="number">0xffffffff81c000ee</span> &lt;+<span class="number">238</span>&gt;:   pop    %rbp</span><br><span class="line">   <span class="number">0xffffffff81c000ef</span> &lt;+<span class="number">239</span>&gt;:   pop    %rbx</span><br><span class="line">   <span class="number">0xffffffff81c000f0</span> &lt;+<span class="number">240</span>&gt;:   pop    %rsi  &gt;&gt;r11的值保存在了rsi中，之后rsi会被保存的rsi覆盖</span><br><span class="line">   <span class="number">0xffffffff81c000f1</span> &lt;+<span class="number">241</span>&gt;:   pop    %r10</span><br><span class="line">   <span class="number">0xffffffff81c000f3</span> &lt;+<span class="number">243</span>&gt;:   pop    %r9</span><br><span class="line">   <span class="number">0xffffffff81c000f5</span> &lt;+<span class="number">245</span>&gt;:   pop    %r8</span><br><span class="line">   <span class="number">0xffffffff81c000f7</span> &lt;+<span class="number">247</span>&gt;:   pop    %rax</span><br><span class="line">   <span class="number">0xffffffff81c000f8</span> &lt;+<span class="number">248</span>&gt;:   pop    %rsi</span><br><span class="line">   <span class="number">0xffffffff81c000f9</span> &lt;+<span class="number">249</span>&gt;:   pop    %rdx</span><br><span class="line">   <span class="number">0xffffffff81c000fa</span> &lt;+<span class="number">250</span>&gt;:   pop    %rsi</span><br><span class="line">   <span class="number">0xffffffff81c000fb</span> &lt;+<span class="number">251</span>&gt;:   mov    %rsp,%rdi  &gt;&gt;保存指向栈中rdi的指针</span><br><span class="line">   <span class="number">0xffffffff81c000fe</span> &lt;+<span class="number">254</span>&gt;:   mov    %gs:<span class="number">0x6004</span>,%rsp  &gt;&gt;切换到弹性栈</span><br><span class="line">   <span class="number">0xffffffff81c00107</span> &lt;+<span class="number">263</span>&gt;:   push   <span class="number">0x28</span>(%rdi)  &gt;&gt;保存rsp  <span class="number">0x7ffc9fcc79f0</span></span><br><span class="line">   <span class="number">0xffffffff81c0010a</span> &lt;+<span class="number">266</span>&gt;:   push   (%rdi)  &gt;&gt;保存rdi</span><br><span class="line">   &gt;&gt;cr3切换开始</span><br><span class="line">   <span class="number">0xffffffff81c0010c</span> &lt;+<span class="number">268</span>&gt;:   push   %rax  <span class="number">0x00000001</span></span><br><span class="line">   <span class="number">0xffffffff81c0010d</span> &lt;+<span class="number">269</span>&gt;:   jmp    <span class="number">0xffffffff81c00152</span> &lt;entry_SYSCALL_64+<span class="number">338</span>&gt;</span><br><span class="line">   <span class="number">0xffffffff81c0010f</span> &lt;+<span class="number">271</span>&gt;:   mov    %cr3,%rdi</span><br><span class="line">   <span class="number">0xffffffff81c00112</span> &lt;+<span class="number">274</span>&gt;:   jmp    <span class="number">0xffffffff81c00148</span> &lt;entry_SYSCALL_64+<span class="number">328</span>&gt;</span><br><span class="line">   <span class="number">0xffffffff81c00114</span> &lt;+<span class="number">276</span>&gt;:   mov    %rdi,%rax</span><br><span class="line">   <span class="number">0xffffffff81c00117</span> &lt;+<span class="number">279</span>&gt;:   <span class="keyword">and</span>    $<span class="number">0x7ff</span>,%rdi</span><br><span class="line">   <span class="number">0xffffffff81c0011e</span> &lt;+<span class="number">286</span>&gt;:   bt     %rdi,%gs:<span class="number">0x2ca96</span></span><br><span class="line">   <span class="number">0xffffffff81c00128</span> &lt;+<span class="number">296</span>&gt;:   jae    <span class="number">0xffffffff81c00139</span> &lt;entry_SYSCALL_64+<span class="number">313</span>&gt;</span><br><span class="line">   <span class="number">0xffffffff81c0012a</span> &lt;+<span class="number">298</span>&gt;:   btr    %rdi,%gs:<span class="number">0x2ca96</span></span><br><span class="line">   <span class="number">0xffffffff81c00134</span> &lt;+<span class="number">308</span>&gt;:   mov    %rax,%rdi</span><br><span class="line">   <span class="number">0xffffffff81c00137</span> &lt;+<span class="number">311</span>&gt;:   jmp    <span class="number">0xffffffff81c00141</span> &lt;entry_SYSCALL_64+<span class="number">321</span>&gt;</span><br><span class="line">   <span class="number">0xffffffff81c00139</span> &lt;+<span class="number">313</span>&gt;:   mov    %rax,%rdi</span><br><span class="line">   <span class="number">0xffffffff81c0013c</span> &lt;+<span class="number">316</span>&gt;:   bts    $<span class="number">0x3f</span>,%rdi</span><br><span class="line">   <span class="number">0xffffffff81c00141</span> &lt;+<span class="number">321</span>&gt;:   <span class="keyword">or</span>     $<span class="number">0x800</span>,%rdi</span><br><span class="line">   <span class="number">0xffffffff81c00148</span> &lt;+<span class="number">328</span>&gt;:   <span class="keyword">or</span>     $<span class="number">0x1000</span>,%rdi</span><br><span class="line">   <span class="number">0xffffffff81c0014f</span> &lt;+<span class="number">335</span>&gt;:   mov    %rdi,%cr3</span><br><span class="line">   <span class="number">0xffffffff81c00152</span> &lt;+<span class="number">338</span>&gt;:   pop    %rax &gt;&gt;弹性栈出栈</span><br><span class="line">   &gt;&gt;cr3切换结束</span><br><span class="line">   <span class="number">0xffffffff81c00153</span> &lt;+<span class="number">339</span>&gt;:   pop    %rdi</span><br><span class="line">   <span class="number">0xffffffff81c00154</span> &lt;+<span class="number">340</span>&gt;:   pop    %rsp</span><br><span class="line">   <span class="number">0xffffffff81c00155</span> &lt;+<span class="number">341</span>&gt;:   swapgs </span><br><span class="line">   <span class="number">0xffffffff81c00158</span> &lt;+<span class="number">344</span>&gt;:   rex.W sysret</span><br></pre></td></tr></table></figure></details><p>继续gdb debug</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b do_syscall_64</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0xffffffff81afa0e0</span>: file arch/x86/entry/common.c, line <span class="number">74.</span></span><br><span class="line">(gdb) n <span class="number">10</span></span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span> hit Breakpoint <span class="number">2</span>, do_syscall_64 (regs=<span class="number">0xffffc900004cbf58</span>, nr=<span class="number">1</span>) at arch/x86/entry/common.c:<span class="number">74</span></span><br><span class="line"><span class="number">74</span>      &#123;</span><br><span class="line">(gdb) p/x $rax</span><br><span class="line">$<span class="number">2</span> = <span class="number">0x1</span>        &gt;&gt;对应sys_write num</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">75</span>              add_random_kstack_offset();</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">76</span>              nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">80</span>              <span class="keyword">if</span> (!do_syscall_x64(regs, nr) &amp;&amp; !do_syscall_x32(regs, nr) &amp;&amp; nr != <span class="number">-1</span>) &#123;</span><br><span class="line">(gdb) b do_syscall_x64</span><br><span class="line">Breakpoint <span class="number">3</span> at <span class="number">0xffffffff81afa0f5</span>: file arch/x86/entry/common.c, line <span class="number">48.</span></span><br><span class="line"></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> hit Breakpoint <span class="number">3</span>, do_syscall_x64 (nr=<span class="number">1</span>, regs=<span class="number">0xffffc90000427f58</span>) at arch/x86/entry/common.c:<span class="number">48</span></span><br><span class="line"><span class="number">48</span>              <span class="keyword">if</span> (likely(unr &lt; NR_syscalls)) &#123;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">49</span>                      unr = array_index_nospec(unr, NR_syscalls);</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">50</span>                      regs-&gt;ax = sys_call_table[unr](regs);   &gt;&gt;我们构建的syscall函数表 ,下标<span class="number">1</span> 对应__x64_sys_write</span><br><span class="line">(gdb) p sys_call_table</span><br><span class="line">$<span class="number">11</span> = <span class="number">0xffffffff820002a0</span> &lt;sys_call_table&gt;</span><br><span class="line">(gdb) p sys_call_table[<span class="number">1</span>]</span><br><span class="line">$<span class="number">12</span> = (<span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span>) <span class="number">0xffffffff8130f9b0</span> &lt;__x64_sys_write&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) disassemble __x64_sys_write</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function __x64_sys_write:</span><br><span class="line">   <span class="number">0xffffffff8130f9b0</span> &lt;+<span class="number">0</span>&gt;:     nopl   <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line">   <span class="number">0xffffffff8130f9b5</span> &lt;+<span class="number">5</span>&gt;:     mov    <span class="number">0x60</span>(%rdi),%rdx</span><br><span class="line">   <span class="number">0xffffffff8130f9b9</span> &lt;+<span class="number">9</span>&gt;:     mov    <span class="number">0x68</span>(%rdi),%rsi</span><br><span class="line">   <span class="number">0xffffffff8130f9bd</span> &lt;+<span class="number">13</span>&gt;:    mov    <span class="number">0x70</span>(%rdi),%rdi</span><br><span class="line">   <span class="number">0xffffffff8130f9c1</span> &lt;+<span class="number">17</span>&gt;:    jmp    <span class="number">0xffffffff8130f8d0</span> &lt;ksys_write&gt;   -&gt;最终执行的函数，三个参数，rdi, rsi, rdx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>grep发现__x64_sys_write在fs/read_write.o，因此从read_write找函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(write, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fd, <span class="keyword">const</span> <span class="keyword">char</span> __user *, buf,                                                                                                                                                  </span><br><span class="line">                <span class="keyword">size_t</span>, count)     </span><br><span class="line">&#123;     </span><br><span class="line">        <span class="keyword">return</span> ksys_write(fd, buf, count);  &gt;&gt;write属于使用三个参数的,因此使用SYSCALL_DEFINE3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//include/linux/syscalls.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)                          \     </span></span><br><span class="line">        SYSCALL_METADATA(sname, x, __VA_ARGS__)                 \       &gt;&gt;默认CONFIG_FTRACE_SYSCALLS=y，方便我们ftrace 抓取系统调用事件</span><br><span class="line">        __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br></pre></td></tr></table></figure><h3 id="x64-64-syscall流程总结"><a href="#x64-64-syscall流程总结" class="headerlink" title="x64_64 syscall流程总结"></a>x64_64 syscall流程总结</h3><p>系统启动时存放syscall底层入口到指定MSR，之后应用程序 通过<code>syscall</code>汇编指令将该MSR的值放到RIP，切到内核态，或者称为特权模式(ring 0)，即获取内核对应的代码段和堆栈，之后进行内核态执行</p><h3 id="x86与x86-64系统调用对比"><a href="#x86与x86-64系统调用对比" class="headerlink" title="x86与x86_64系统调用对比"></a>x86与x86_64系统调用对比</h3><ol><li>x86是通过中断trap门逻辑，而x86_64是通过MSR来切换RIP的。</li></ol><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>现在都是直接寻址，即虚拟地址都是线性地址，不再需要段寻址，直接页寻址即可，因此cs和ss(数据段)除了兼容之外，在直接寻址的堆栈保存和恢复中没有作用</li></ol><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><pre><code>       1. IDT  INTERRUPT DESCRIPTOR TABLE  
       2. TSS Task-State Segment  通过segment中保存的task信息来恢复处理现场
       3. IST Interrupt Stack Table  </code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://lkml.iu.edu/hypermail/linux/kernel/2104.3/01302.html">add_random_kstack_offset</a></li><li>Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1</li></ol></div><div class="popular-posts-header">推荐文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/17.html" rel="bookmark">linux模块初始化分析</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/16.html" rel="bookmark">Kbuild-Makefile学习</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="tag"># 系统调用</a> <a href="/tags/%E4%B8%AD%E6%96%AD/" rel="tag"># 中断</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/19.html" rel="prev" title="linux-assembly入门学习"><i class="fa fa-chevron-left"></i> linux-assembly入门学习</a></div><div class="post-nav-item"><a href="/archives/21.html" rel="next" title="ION内存泄漏导致稳定性排查">ION内存泄漏导致稳定性排查 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#x86%E4%B8%8B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">x86下系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E9%80%BB%E8%BE%91"><span class="nav-number">1.2.</span> <span class="nav-text">实践-函数调用堆栈逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">两个参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">八个参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">结构体参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IA-32%E4%B8%8B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.</span> <span class="nav-text">IA-32下系统调用的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IDT"><span class="nav-number">1.3.1.</span> <span class="nav-text">IDT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cea"><span class="nav-number">1.3.2.</span> <span class="nav-text">cea</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GDT"><span class="nav-number">1.3.3.</span> <span class="nav-text">GDT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MSR-GS-BASE"><span class="nav-number">1.3.4.</span> <span class="nav-text">MSR_GS_BASE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MSR-KERNEL-GS-BASE"><span class="nav-number">1.3.5.</span> <span class="nav-text">MSR_KERNEL_GS_BASE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.6.</span> <span class="nav-text">任务管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B9%E6%80%A7%E6%A0%88"><span class="nav-number">1.3.7.</span> <span class="nav-text">弹性栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A0%88"><span class="nav-number">1.3.8.</span> <span class="nav-text">内核栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x64-32-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.9.</span> <span class="nav-text">x64_32 系统调用中断流程总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64%E4%BD%8D%E4%B8%8B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.</span> <span class="nav-text">64位下系统调用的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">实现流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E8%AF%BB%E5%8F%96MSR-%E6%8C%87%E5%AE%9A%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">实践-内联汇编读取MSR 指定寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82"><span class="nav-number">1.4.3.</span> <span class="nav-text">linux实现代码细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x64-64-syscall%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.4.</span> <span class="nav-text">x64_64 syscall流程总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86%E4%B8%8Ex86-64%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AF%B9%E6%AF%94"><span class="nav-number">1.4.5.</span> <span class="nav-text">x86与x86_64系统调用对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%96%91%E9%97%AE"><span class="nav-number">1.5.</span> <span class="nav-text">疑问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8D%E8%AF%8D"><span class="nav-number">1.6.</span> <span class="nav-text">名词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">1.7.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Sholck</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">62</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xiaer1921" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaer1921" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:xiaer1921@aliyun.com" title="E-Mail → mailto:xiaer1921@aliyun.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/sholck222" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;sholck222" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa-fw"></i>CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://hackret.com/" title="https:&#x2F;&#x2F;hackret.com&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">RedHat Kairui</a></li><li class="links-of-blogroll-item"><a href="https://linux-kernel-labs.github.io/refs/heads/master/index.html#" title="https:&#x2F;&#x2F;linux-kernel-labs.github.io&#x2F;refs&#x2F;heads&#x2F;master&#x2F;index.html#" rel="noopener external nofollow noreferrer" target="_blank">Linux Kernel Teaching</a></li><li class="links-of-blogroll-item"><a href="https://tding.top/" title="https:&#x2F;&#x2F;tding.top&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">小丁</a></li><li class="links-of-blogroll-item"><a href="https://xiaozhou.net/" title="https:&#x2F;&#x2F;xiaozhou.net&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">iTimpthy</a></li><li class="links-of-blogroll-item"><a href="https://consen.github.io/" title="https:&#x2F;&#x2F;consen.github.io&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">Consen</a></li></ul></div><div><canvas id="canvas" style="width:60%">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){var o,a,r,f,t,i=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],e=document.getElementById("canvas");function h(t,e){for(var n=[1,2,3],l=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],o=0;o<i[e].length;o++)for(var a,h=0;h<i[e][o].length;h++){1==i[e][o][h]&&(a={x:14*(f+2)*t+2*h*(f+1)+(f+1),y:2*o*(f+1)+(f+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*n[Math.floor(Math.random()*n.length)],color:l[Math.floor(Math.random()*l.length)],disY:1},r.push(a))}}function n(){e.height=100;for(var t=0;t<a.length;t++)!function(t,e){for(var n=0;n<i[e].length;n++)for(var l=0;l<i[e][n].length;l++)1==i[e][n][l]&&(o.beginPath(),o.arc(14*(f+2)*t+2*l*(f+1)+(f+1),2*n*(f+1)+(f+1),f,0,2*Math.PI),o.closePath(),o.fill())}(t,a[t]);for(t=0;t<r.length;t++)o.beginPath(),o.arc(r[t].x,r[t].y,f,0,2*Math.PI),o.fillStyle=r[t].color,o.closePath(),o.fill()}e.getContext&&(o=e.getContext("2d"),e.height=100,e.width=700,o.fillStyle="#f00",o.fillRect(10,10,50,50),a=[],r=[],f=e.height/20-1,t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),a.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6]),clearInterval(void 0),setInterval(function(){!function(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),n=[];n.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var l=a.length-1;0<=l;l--)n[l]!==a[l]&&t.push(l+"_"+(Number(a[l])+1)%10);for(l=0;l<t.length;l++)h.apply(this,t[l].split("_"));a=n.concat()}(),function(){for(var t=0;t<r.length;t++)r[t].stepY+=r[t].disY,r[t].x+=r[t].stepX,r[t].y+=r[t].stepY,(r[t].x>700+f||r[t].y>100+f)&&(r.splice(t,1),t--)}(),n()},50))}()</script><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-history fa-" aria-hidden="true"></i> 近期文章</div><ul class="links-of-blogroll-list"><li><a href="/archives/21.html" title="ION内存泄漏导致稳定性排查" target="_blank">ION内存泄漏导致稳定性排查</a></li><li><a href="/archives/20.html" title="x86下系统调用" target="_blank">x86下系统调用</a></li><li><a href="/archives/19.html" title="linux-assembly入门学习" target="_blank">linux-assembly入门学习</a></li><li><a href="/archives/18.html" title="cmpxchg kernel-api学习" target="_blank">cmpxchg kernel-api学习</a></li><li><a href="/archives/17.html" title="linux模块初始化分析" target="_blank">linux模块初始化分析</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="user"></i> </span><span class="author" itemprop="copyrightHolder">Sholck</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">235k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">3:33</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Muse</a> 强力驱动</div><script src="/lib/mermaid/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script></body></html>